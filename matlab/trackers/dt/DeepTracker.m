classdef DeepTracker < LabelTracker
  
  properties (Dependent)
    algorithmName
    algorithmNamePretty
    sPrm % new-style DT params
  end
  properties (Constant,Hidden)
    SAVEPROPS = {'sPrmAll' 'containerBindPaths' ...
      'trnNetType' 'trnNetMode' 'trnLastDMC' 'movIdx2trkfile' 'hideViz' }
%       'jrcgpuqueue' 'jrcnslots' 'jrcnslotstrack'}; 
    
    pretrained_weights_urls = {...
      'http://download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC.tar.gz'
      'http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz'...
      };
    pretrained_weights_files_relative_path = {...
      'pretrained/resnet_v2_fp32_savedmodel_NHWC/1538687283/variables/variables.index'... 
      'pretrained/resnet_v1_50.ckpt'... 
      };
    pretrained_download_script_py = '%s/download_pretrained.py'; % fill in deepnetroot
    
%     default_jrcgpuqueue = 'gpu_a100';
%     default_jrcnslots_train = 1;
%     default_jrcnslots_track = 1;
    
    MDN_OCCLUDED_THRESH = 0.5;
  end
%   properties (GetAccess=public,SetAccess=protected) % MOVE THIS TO BE
%     jrcgpuqueue = '';
%     jrcnslots = 4;
%     jrcnslotstrack = 4; % transient
%   end
  properties
    dryRunOnly % transient, scalar logical. If true, config files, cmds 
      % are generated for DL, but actual DL train/track are not spawned
    skip_dlgs % MK: Skip save/delete dialogs for testing.
    isTrainingSplits_  
      % transient, scalar logical.  true iff the ongoing training is training splits.
      % Underscore indicates it is private by convention.
  end
  properties
    containerBindPaths % cellstr of bind paths for sing/docker
      % Will be used if it is nonempty; otherwise an attempt will be made 
      % to autogenerate the required bind/mount paths.
  end
  properties (Dependent)
    % condaEnv  % = 'APT'; % name of conda environment
    % configFileExt
    backend
    isTrainingSplits
  end
      
    %% train
    
    % - The trained model lives in the fileSys in <cacheDir>/<proj>view%d/trnName.
    % - Right now you can only have one train running at a time.
    
    % chars, currently autogenerated.
    % - When you retrain, you make a new trnName, every time.
    % - In the cacheDir, a subfolder is created .../<trnName>. This
    % subfolder holds the entire state for your trained model.
    % - Within the subfolder, multiple config files may exist:
    %   .../<trnName>/<trnNameJson1>, .../<trnName>/<trnNameJson2>, ...
    %   representing restarts-with-data-augmentation. The current config
    %   file (ie typically the one used in the most recent train) is
    %   identified by .trnNameLbl.
    % - As far as DeepTracker.m is concerned, the only output/artifacts 
    % generated by training are these two identifiers.
    % FUTURE TODO: what happens when user alters cacheDir?
      
  properties % (SetAccess=private)
    trnNetType = DLNetType.mdn; % scalar DLNetType
    trnNetMode = DLNetMode.singleAnimal;
  end
  properties (Dependent)
    trnName
    trnNameLbl
    %filesep
  end
  properties
    % Notes on trnLastDMC.
    %
    % This prop represents the "most recently trained model" for this
    % tracker obj. In many/most workflows the APT UI and backend share a
    % local filesystem and this most recent model lives on this local 
    % filesystem.
    %
    % In some cases, training and tracking occurs remotely relative to the 
    % APT frontend. In this case, there are two relevant filesystems: the 
    % local one available to APT, and the remote one available to the 
    % backend. At various points in a training/tracking workflow, trained 
    % models will exist on BOTH filesystems:
    %
    % * At project load, an existing model might be untarred locally, or 
    % there might be no existing model for a new project.
    % * At train time, a new model model is generated remotely.
    % * At retrain-, augmentedtrain-, or track-time, the local model will 
    % first be uploaded to the remote filesys if necessary.
    % * At project save time, remote models will be downloaded locally
    % before tarring into the project.
    %
    % With regards to this issue, our invariant for .trnLastDMC is that 
    %
    %   .trnLastDMC contains the most recently updated model for the 
    %   tracker, with the .reader property correctly indicating the 
    %   filesystem location of that model. This model is the one that
    %   should be used for inference, saved to projects, etc. Let's call it
    %   the "latest model" (for this tracker).
    %
    % * At project load, all .trnLastDMCs will point to the local
    % filesystem/cache.
    % * When a remote fresh train is spawned, .trnLastDMC is immediately 
    % set to the remote location. Even if the train fails or is killed
    % early, whatever is there remotely is still the latest model.
    % * If a remote track is spawned and the latest model is local, it is
    % uploaded first so the track can occur. The moment this upload 
    % completes, the latest model is moved/set to the remote location.
    % * For now we punt on retrains/augmentedtrains. These pose an issue in
    % that depending on the result of the remote train, the latest model
    % may remain local (eg if the remote train fails, maybe). Maybe the 
    % rule is as simple as "the remote model becomes the latest model if 
    % training completes successfully" but I am not sure. Skip it for now.
    % * At project save-time, the latest model (whereever it may be) is
    % tarred into the project. If the latest model is remote, then it is
    % downloaded first. This download does not update the latest model
    % pointer as the user may continue using the remote/latest model for 
    % tracking.
    %
    % So for now, for the AWS backend, the latest model may start locally, 
    % but once a train or track operation occurs, it will be remote from
    % that point onwards. Conceptually a user could switch backends to
    % local and that would allow the movie to "move back down" but we're
    % not going to worry about that for now.
    trnLastDMC % Last DeepModelChainOnDisk, set during training
    trnTblP % transient, unmanaged. Training rows for last retrain
    
    trnSplitLastDMC % [nsplit] Last DMCs, one per split; transient/unmanaged
    
    bgTrnMonitor % BgMonitor obj
    bgTrainPoller % BgTrainPoller for last/current train
        
    %% track

    % - Right now you can only have one track running at a time.
    
    trkDockerCPU = false; % transient, scalar logical. If true and using Docker backend, use CPU for tracking
    
    trkGenHeatMaps % transient, scalar logical. If true, include --hmaps opt
      % to generate heatmaps on disk
      
    trkGTtrkTbl % transient, table of gt results
   
    trkSysInfo % [nview] transient, unmanaged. struct array of info used 
               % for current or most recent tracking codegen/system call. currently 
               % only used for debugging, printing logfiles etc.
    
    bgTrkMonitor % BgMonitor obj
    bgTrackPoller % bgTrackWorkerObj for last/current track
    
    % trackres: tracking results DB is in filesys
    movIdx2trkfile % map from MovieIndex.id to [ntrkxnview] cellstrs of trkfile fullpaths
  end
  
  % properties (SetObservable)
  %   trackerInfo = []  % information about the current tracker being used for tracking
  % end

  properties (Dependent)
    trackerInfo  % information about the current tracker being used for tracking
  end
  
  properties (Dependent)
    bgTrnIsRunning
    bgTrkIsRunning
    lastTrainEndCause 
      % Did the last bout of training complete or error or was it aborted by user.
      % Only meaningful if training has been run at least once in the current session.
      % Defaults to EndCause.undefined if training has not been run in the current session.
      % In other words not persisted to the .lbl file in any way.
    lastTrackEndCause  
      % Did the last bout of tracking complete or error or was it aborted by user.
      % Only meaningful if tracking has been run at least once in the current session.
      % Defaults to EndCause.undefined if tracking has not been run in the current session.
      % In other words not persisted to the .lbl file in any way.
  end

  properties (Transient)
    lastTrainEndCause_ = EndCause.undefined
    lastTrackEndCause_ = EndCause.undefined
  end

  properties    
    % track curr res -- in-mem tracking results for current mov    
    %
    % The raw tracking DB are trkfiles on disk. Trkfiles are single-view,
    % and there may be arbitrarily many trkfiles for a single (mov,view)
    % since users may repeatedly track segments.
    %
    % trkP merges all results for a given movieset into a single TrkFile.
    % TrkFile is prob better named 'Trk'. The design of 'Trk' between
    % serializtaion and runtime is a little unclear. At runtime it may make
    % sense to store tracking results in custom/redundant data structures
    % for performance reasons. TrkFile has some relevant machinery (eg
    % conversion between full/tracklet can be added) and maybe it ends up
    % covering all bases. A separate class may end up making sense. For now
    % we use a TrkFile and see.
    trkP   % scalar TrkFile obj. tracking results for current mov, views merged
    
    %trkPTS % [npt x nfrm x ntgt] timestamp for trkP*    
    %trkAux % [npt x nfrm x ntgt x naux] auxiliary per-pt results eg confidences
    %trkAuxLbl % [naux] labels for 4th dim of trxAux
              % naux given in DLNetType
  end

  properties (Dependent)
    nPts % number of label points     
    nview 
    nFramesToTrack
  end
  
  properties
    trkVizer % scalar TrackingVisualizer
    
    % *Tracking results and viz*
    % For optimization, trkVizer is not created until/when there are
    % tracking results (trkP) to display. Various states:
    % - trkP=[], trkVizer=[].
    % - trkP nonempty, trkVizer=[] if DeepTracker is deactivated.
    % - trkP nonempty, trkVizer nonempty.
    % 
    % vizInit() create/initializes trkVizer (or deletes an existing 
    % trkVizer) based on trkP.    
  end
  
  properties (Transient)
    nFramesToTrack_
  end

  methods
    function v = get.algorithmName(obj)
      v = getAlgorithmNameHook(obj);
    end
    function v = getAlgorithmNameHook(obj)
      v = char(obj.trnNetType);
    end
    function v = get.algorithmNamePretty(obj)
      v = obj.getAlgorithmNamePrettyHook();
    end
    function v = getAlgorithmNamePrettyHook(obj)
      v = ['Deep Convolutional Network - ' obj.trnNetType.displayString];
    end
    function v = getNumStages(obj)  %#ok<MANU> 
      v = 1;
    end
    function v = getNetsUsed(obj)
      v = cellstr(obj.trnNetType);
    end
    % function v = get.condaEnv(obj)
    %   v = obj.lObj.trackDLBackEnd.condaEnv;
    % end
    function result = get.backend(obj)
      labeler = obj.lObj ; 
      if ~isempty(labeler) && isa(labeler, 'handle') && isvalid(labeler) ,
        result = labeler.trackDLBackEnd ;
      else
        result = [] ;
      end
    end
    % function v = get.configFileExt(obj) %#ok<MANU> 
    %   v = DeepModelChainOnDisk.configFileExt;
    % end
    function v = get.trnName(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = DeepModelChainOnDisk.getCheckSingle(dmc.getModelChainID());
      end
    end
    function v = get.trnNameLbl(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = DeepModelChainOnDisk.getCheckSingle(dmc.getTrainID());
      end
    end
    % function v = get.filesep(obj) %#ok<MANU> 
    %   %v = obj.lObj.trackDLBackEnd.filesep;
    %   v = '/' ;
    % end
    function v = get.nPts(obj)
      v = obj.lObj.nLabelPoints;
    end
    function v = get.nview(obj)
      v = obj.lObj.nview;
    end
    function v = get.bgTrnIsRunning(obj)
      % Whether training is running.  Technically, only checks whether the
      % background process that polls for training progress is running.
      btm = obj.bgTrnMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
    function v = get.bgTrkIsRunning(obj)
      % Whether tracking is running.  Technically, only checks whether the
      % background process that polls for tracking progress is running.      
      btm = obj.bgTrkMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
%     function setJrcgpuqueue(obj,v)
%       obj.jrcgpuqueue = v;
%     end
%     function setJrcnslots(obj,v)
%       obj.jrcnslots = v;
%     end
%     function setJrcnslotstrack(obj,v)
%       obj.jrcnslotstrack = v;
%     end
  end
  
  methods
    function obj = DeepTracker(lObj,varargin)
      obj@LabelTracker(lObj);
      %obj.setJrcgpuqueue(DeepTracker.default_jrcgpuqueue);
      
      for i=1:2:numel(varargin)
        prop = varargin{i};
        val = varargin{i+1};
        obj.(prop) = val;
      end
      
      % Init .trnNetMode here for SA projs. Maybe a little strange 
      if lObj.projectHasTrx
        % Has to be SA
        obj.trnNetMode = DLNetMode.multiAnimalTDPoseTrx;
      end        
              
      obj.bgTrnMonitor = [];
      %obj.bgTrnMonitorVizClass = 'TrainMonitorViz';
      obj.bgTrkMonitor = [];
      %obj.bgTrkMonitorVizClass = 'TrackMonitorViz';

      obj.trkVizer = []; 
      obj.skip_dlgs = false;
    end
    function delete(obj)
      obj.trnResInit();
      obj.bgTrkReset_();
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function initHook(obj)
      obj.trnResInit();
      obj.bgTrkReset_();
      obj.trackResInit();
      obj.trackCurrResInit();
      obj.vizInit();
      % obj.syncInfoFromDMC_();
    end
    function deactivate(obj)
      deactivate@LabelTracker(obj);
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function activate(obj)
      activate@LabelTracker(obj);
      obj.vizInit(false);
      % obj.syncInfoFromDMC_();
    end
  end
  
  %% Params
  methods (Static)
    
    function sPrmAll = massageParamsIfNecStc(net, ~, sPrmAll, varargin)
      % net-specific parameter treatments
      %
      % net: DLNetType
      %
      % Openpose currently requires particular constraints between
      % parameters that are not required for other DL trackers. Current
      % treatment is
      % - lObj.trackParams continues to be "anything", ie user continues
      % to specify whatever they like in Tracking Parameters. (More
      % precisely, there may be constraints amongst parameters at this
      % level, but these constraints are common to all DL trackers.)
      % - When the universal params are to be set on a specific DL
      % tracker, we may mutate them to meet any DLnet-specific
      % constraints.
      % - So in normal "steady" usage, specific DeepTrackers may have
      % parameters that differ (typically v slightly) from the "main"
      % params. This may be noted in the trackerInfoString.
      
      [throwwarnings] = myparse(varargin,...
        'throwwarnings',true...
        );
      
      switch net
        case {DLNetType.openpose}
          dl_steps = sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps;
          save_step = sPrmAll.ROOT.DeepTrack.Saving.save_step;
          display_step = sPrmAll.ROOT.DeepTrack.Saving.display_step;
          
          if dl_steps < display_step
            dl_steps = display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be greater than or equal to the display step. Updating to %d DL steps.',...
                net.displayString,dl_steps);
            end
          end
          
          if mod(dl_steps,display_step)~=0
            dl_steps = ceil(dl_steps/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be an even multiple of the display step. Increasing DL steps to %d.',...
                net.displayString,dl_steps);
            end
          end
          
          if save_step < display_step
            save_step = display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be greater than or equal to display step. Updating the DL save step to %d.',...
                net.displayString,save_step);
            end
          end
          
          if mod(save_step,display_step)~=0
            save_step = ceil(save_step/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be an even multiple of the display step. Increasing the DL save step to %d.',...
                net.displayString,save_step);
            end
          end
          
          sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps = dl_steps;
          sPrmAll.ROOT.DeepTrack.Saving.save_step = save_step;
      
        otherwise
          % none
      end
      
%       sPrmAll.ROOT.MultiAnimal.TargetCrop.AlignUsingTrxTheta = ...
%         netmode.isHeadTail || netmode==DLNetMode.multiAnimalTDPoseTrx;      
    end
    
  end
  methods
    
    % AL 20190415. Note on DeepTrack.Saving.CacheDir
    % Currently nothing never refers to
    % DeepTrackerObj.sPrmAll.Saving.CacheDir. Instead, only lObj.DLCacheDir
    % and DeepTrackerObj.trnLastDMC.rootDir are used. 
    %
    % - (re)train time: DeepTrackerObj uses lObj.DLCacheDir and sets 
    % .trnLastDMC.rootDir to this location.
    % - track time: currently we assert that lObj.DLCacheDir matches the
    % .rootDir of any local DMCs to be used
    
    function [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        didParamsChange_(obj, sPrmAll)  % obj const
      % Compare sPrmAll to obj.sPrmAll, reporting if various parts are different.
      % This is used to determine what follow-on actions are needed after
      % obj.sPrmAll is set to sPrmAll.

      tfDiffEmptiness = xor(isempty(obj.sPrmAll),isempty(sPrmAll));
      tfCommonChanged = tfDiffEmptiness || ~APTParameters.isEqualTrackDLParams(obj.sPrmAll,sPrmAll);
      tfPreProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPreProcParams(obj.sPrmAll,sPrmAll);
      tfPostProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      
      sOldSpecific = obj.sPrm;
      prmField = APTParameters.getParamField(obj.trnNetType);
      sNewSpecific = sPrmAll.ROOT.DeepTrack.(prmField);
      tfSpecificChanged = ~isequaln(sOldSpecific,sNewSpecific);
    end
      
    function sPrmAll = massageParamsIfNec(obj,sPrmAll,varargin) % obj const
      net = obj.trnNetType;
      netmode = obj.trnNetMode;
      sPrmAll = DeepTracker.massageParamsIfNecStc(net,netmode,...
                                                  sPrmAll,varargin{:});
    end
      
    function setAllParams(obj,sPrmAll)
      sPrmAll = obj.massageParamsIfNec(sPrmAll);
      
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        obj.didParamsChange_(sPrmAll);
      
      obj.sPrmAll = sPrmAll;
      
      if tfCommonChanged || tfSpecificChanged
        obj.init();
      elseif tfPreProcChanged
        % This is likely if the targetcrop size changes in which case 
        % we should only reset the second stage but for now resetting the
        % both the stages -- MK 20220520
        if (obj.lObj.maIsMA && (obj.getNumStages > 1)) || ~obj.lObj.maIsMA
          obj.init();
        end
      end
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        % obj.syncInfoFromDMC_(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end

    function sPrmAll = getAllParams(obj)
      sPrmAll = obj.sPrmAll;     
    end

    function tfPostProcChanged = setPostProcParams(obj,sPrmAll)
      tfPostProcChanged = ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      obj.sPrmAll.ROOT.PostProcess = sPrmAll.ROOT.PostProcess;
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        % obj.syncInfoFromDMC_(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
      
    function v = get.sPrm(obj)
      if isempty(obj.sPrmAll),
        v = [];
      else
        prmField = APTParameters.getParamField(obj.trnNetType);
        v = obj.sPrmAll.ROOT.DeepTrack.(prmField);
      end
    end

    function sPrm = getParams(obj)
      sPrm = obj.sPrm;
    end    

    function tc = getTrackerClassAugmented(obj)
      tc = {class(obj) 'trnNetType' obj.trnNetType};
    end

    function s = getSaveToken(obj)
      s = struct();
      prop_names = obj.SAVEPROPS;
      for i = 1:numel(prop_names) ,
        prop_name = prop_names{i} ;
        if strcmp(prop_name, 'trnLastDMC') ,
          % Handle the DMCoD in a special way, making a copy
          value = obj.(prop_name) ;
          if isempty(value) ,
            s.(prop_name) = value ;
          else
            s.(prop_name) = value.copy() ;
          end
        else
          % Normal handling, sufficient for most props
          s.(prop_name) = obj.(prop_name) ;
        end
      end
    end  % function

    function s = getTrackSaveToken(obj)
      s = obj.getSaveToken();
      s.sPrmAll = APTParameters.all2TrackParams(s.sPrmAll,false);
    end

    function loadSaveToken(obj,s)
      s = DeepTracker.modernizeSaveToken(s);
      
      obj.initHook(); % maybe handled upstream
      flds = fieldnames(s);
      flds = setdiff(flds,'hideViz');
      for f_wrapped = flds(:)' ,
        f=f_wrapped{1};
        if isprop(obj, f) ,
          obj.(f) = s.(f);
        else
          warningNoTrace('Ignoring field ''%s'' in save token, because no such property in class DeepTracker', f) ;
        end
      end
      
      obj.dryRunOnly = false;
      
%      obj.setHideViz(s.hideViz);
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end

    function updateDLCache(obj, dlcachedir)
      dmc = obj.trnLastDMC ;
      if isempty(dmc)
        return
      end
      dmc.rootDir = dlcachedir ;
    end

  end
  methods (Static)
    function s = modernizeSaveToken(s)
      % 20181215
      if isfield(s,'awsEc2')
        s = rmfield(s,'awsEc2');
      end
      if isfield(s,'backendType')
        s = rmfield(s,'backendType');
      end
      % 20181218
      if ~isfield(s,'containerBindPaths')
        s.containerBindPaths = cell(0,1);
      end 
      
      % 20190214
      % (Comment is basically C+P from CPRLabelTracker)
      % IMPORTANT philisophical note. We update/modernize .sPrmAll here,
      % but any changes should not invalidate previous trained trackers.
      % Parameters may be renamed, new parameters added, etc; but eg any 
      % new parameters added should be added with default values that 
      % effectively would have been previously used.

      assert(isfield(s,'sPrmAll') && ~isfield(s,'sPrm')); % taken care of in Labeler/lblModernize
            
      if ~isempty(s.sPrmAll)
        s.sPrmAll = APTParameters.modernize(s.sPrmAll);
      else
        % AL 20190713 leave s.sPrmAll empty for untrained trackers
        tfTrained = isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC);
        if tfTrained,
          warning('Apparent trained tracker with no parameters, setting trnLastDMC = []');
          s.trnLastDMC = [];
        end
        % assert(~tfTrained,'Apparent trained tracker with no parameters.');
        % s.sPrmAll = sPrmDflt;
        % Let's leave s.sPrmAll empty for now
      end
      
      % 20190405 
      % .trnName, .trnNameLbl removed as they dup .trnLastDMC
      if isfield(s,'trnName')
        s = rmfield(s,'trnName');
      end
      if isfield(s,'trnNameLbl')
        s = rmfield(s,'trnNameLbl');
      end

      % update trnLastDMC
      if isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC),
        % KB 20220804
        s.trnLastDMC = DeepModelChainOnDisk.modernize(s.trnLastDMC);
%         % Add .reader to any .trnLastDMCs; assume local filesys
%         if isempty(s.trnLastDMC.reader),
%           s.trnLastDMC.reader = DeepModelChainReaderLocal();
%         end
      end

      % 20190415
      % remove .movIdx2trkfile for now, with bundle-save we don't save
      % DeepTracker-stored tracking results
      if isfield(s,'movIdx2trkfile')
        s = rmfield(s,'movIdx2trkfile');
      end
      
      % % 20190520: filesep needed for local windows
      % if isfield(s,'trnLastDMC'),
      %   % I don't see how this could happen -- filesep is by default '/'
      %   if ~isempty(s.trnLastDMC),
      %     s.trnLastDMC.checkFileSep();
      %   end
      % end
      
%       if ~isfield(s,'jrcgpuqueue') || strcmp(s.jrcgpuqueue,'gpu_any') || strcmp(s.jrcgpuqueue,'gpu_tesla') || startsWith(s.jrcgpuqueue,'gpu_rtx')
%         s.jrcgpuqueue = DeepTracker.default_jrcgpuqueue;
%         warningNoTrace('Updating JRC GPU cluster queue to ''%s''.',...
%                        s.jrcgpuqueue);
%       end

      % 20240930: Things that have moved to DLBackEndClass
      if isfield(s, 'jrcgpuqueue') 
        s = rmfield(s, 'jrcgpuqueue') ;
      end
      if isfield(s, 'jrcnslots') 
        s = rmfield(s, 'jrcnslots') ;
      end
      if isfield(s, 'jrcnslotstrack') 
        s = rmfield(s, 'jrcnslotstrack') ;
      end    
    end  % function
  end  % methods (Static)
  
  
  %% Train
  methods
    
    function trainIncremental(obj)  %#ok<MANU> 
      error('Incremental training is currently unsupported for Deep Learning.');
    end
    
    % Training timeline
    %
    % - Call to retrain. this creates a new jobname every time.
    % - config file written to <cacheDir>/<trnID>.json
    % - bg trn monitor started
    % - training spawned
    % - as log/intermediate results are written, loss viz in plot.
    % - you can start tracking at any time with the latest model by calling
    % track().
    % - FUTURE TODO you can't forcibly stop training for now.
    % - FUTURE TODO you can't choose to use a trained model before the last/final
    % - FUTURE TODO clean up old/unwanted trained models.
    % one if say it looked less overtrained or better.
    % - trained models will sit on disk; config file at 
    % <cache>/<trnName>.json, and models at <cache>/.../<trnName>
    
    % For Training, there are two processes
    % 1. The backend train itself. After this is spawned, this currently 
    % cannot be managed/killed from this class. If there is an issue the
    % actual compute needs to be manually killed.
    % 2. Background monitoring of the train. This can be reset with
    % bgTrnReset().
    
    function trnResInit(obj)
      obj.trnLastDMC = [];
      obj.bgTrnReset_();
    end

    % function bgTrnStart_(obj,backend,dmc,projTempDir)
    %   % fresh start new training monitor 
    % 
    %   trainSplits = false ;      
    %   if ~isempty(obj.bgTrnMonitor)
    %     error('Training monitor exists. Call .bgTrnReset first to stop/remove existing monitor.');
    %   end
    %   assert(isempty(obj.bgTrainPoller));
    %   obj.isTrainingSplits_ = trainSplits ;
    %   netmode = obj.trnNetMode;
    %   tf2stg = netmode.isTwoStage;
    %   if dmc.nstages > 1,
    %     assert(tf2stg);        
    %   end
    % 
    %   % Create the worker, etc used to monitor training in the background
    %   trnWrkObj = BgTrainPoller(dmc, backend) ;
    %   trnVizObj = TrainMonitorViz(dmc,obj,trnWrkObj,...
    %                               backend.type,'trainSplits',trainSplits) ;                
    %   trnMonObj = BgMonitor(obj, 'train', trnVizObj, trnWrkObj, 'projTempDir', projTempDir) ;
    %   obj.bgTrnMonitor = trnMonObj;
    %   obj.bgTrainPoller = trnWrkObj;
    %   trnMonObj.start();  % Moved this after the two lines above.  Seems wise, but...  -- ALT, 2024-07-31
    % end
    
    function waitForJobsToExit(obj, train_or_track)
      % Wait for all registered jobs of the given type to exit.
      backend = obj.backend ;
      backend.waitForRegisteredJobsToExit(train_or_track) ;
    end

    function bgTrnReset_(obj)
      % stop the training monitor
      if ~isempty(obj.bgTrnMonitor)
        delete(obj.bgTrnMonitor);
      end
      obj.bgTrnMonitor = [];      
      if ~isempty(obj.bgTrainPoller)
        delete(obj.bgTrainPoller);
      end
      obj.bgTrainPoller = [];
    end    
    
    function tf = hasBeenTrained(obj)
      tf = ~isempty(obj.trnLastDMC);
    end
    
    function [tfCanTrain,reason] = canTrain(obj)      
      tfCanTrain = false;
      reason = '';
      if obj.bgTrnIsRunning
        reason = 'Training is already in progress.';
        return
      end
      if obj.bgTrkIsRunning,
        reason = 'Tracking is in progress.';
        return
      end
      
      % For now we do this check here even though the actual parfeval()
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun >= p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn training monitor.';
        return
      end

      % AL 20190321 parameters now set at start of retrain
%       if isempty(obj.sPrmAll)
%         reason = 'No tracking parameters have been set.';
%         return;
%       end
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'No cache directory has been set.';
        return
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        reason = 'Please give your project a name. The project name will be used to identify your trained models on disk.';
        return
      end
      
      backend = lblObj.trackDLBackEnd;
      [isBackendRunning,reasonBackendIsNotRunning] = backend.ensureIsRunning();
      if ~isBackendRunning
        reason = reasonBackendIsNotRunning;
        return
      end
      
      if isempty(obj.trnNetType)
        reason = 'Deep net type is empty.';
        return
      end
      
      % check batch size
      nLbledRows = sum(lblObj.movieFilesAllHaveLbls);
      fprintf(1,'Your project has %d labeled rows.\n',nLbledRows);
      bsizeFcn = @(fld,val)strcmp(fld,'batch_size') && val>nLbledRows;
      % Note: at this time, project-level params are set but NOT
      % tracker-level params
      sPrmLblObj = lblObj.trackGetTrainingParams();
      res = structapply(sPrmLblObj.ROOT,bsizeFcn);
      tfbsize = cell2mat(res.values);
      if any(tfbsize)
        reason = sprintf('Your project has fewer labeled targets (%d) than a specified training batch size.',...
          nLbledRows);
        return
      end
      
      if (obj.trnNetType==DLNetType.openpose || obj.trnNetType==DLNetType.multi_openpose) ...
          && isempty(lblObj.skeletonEdges)
        reason = 'Please define a skeleton to track with OpenPose.';
        return
      end
      
      tfCanTrain = true;      
    end  % function
    
    function pretrain_(obj)      
      if obj.bgTrnIsRunning
        error('Training is already in progress.');
      end
      
      if obj.bgTrkIsRunning
        error('Tracking is in progress.');
      end
      
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      labeler = obj.lObj;
      projname = labeler.projname;
      if isempty(projname)
        error('Please give your project a name. The project name will be used to identify your trained models on disk.');
      end      
      
      backend = labeler.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(backend.type));
      fprintf('\n'); 

      % Update code on remote filesystem, if needed
      backend.updateRepo() ;

      % Upload the movies to the backend
      nativePathFromMovieIndex = obj.lObj.movieFilesAll ;      
      backend.uploadMovies(nativePathFromMovieIndex) ;
    end
    
    function train(obj,varargin)
      % Main training function
      % Called by Labeler.train
      % Checks whether tracking results already exist, and what to do about
      % them. 
      % Sets parameters. 
      % Checks whether to start from previously trained models. 
      % calls trnSpawn to actually do anything.
      % also can call trnSpawnAWS but this is obsolete
      
      [~, dlTrnType, oldVizObj, augOnly, do_just_generate_db, do_call_apt_interface_dot_py,projTempDir] = ...
        myparse(varargin,...
                'wbObj',[],...
                'dlTrnType',DLTrainType.New, ...
                'oldVizObj',[], ...
                'augOnly',false, ...
                'do_just_generate_db', false, ...
                'do_call_apt_interface_dot_py', true, ...
                'projTempDir', '') ;
     
      obj.pretrain_();
      backend = obj.backend ;
      
      if obj.isTrkFiles() ,
        if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
          res = questdlg(['Tracking results exist for previous deep trackers. ' ...
                          'When training stops, these will be deleted. Continue training?'], ...
                         'Continue training?', ...
                         'Yes','No','Cancel', ...
                         'Yes') ;
          if ~strcmpi(res,'Yes'),
            return;
          end
        end        
      end
      
      labeler = obj.lObj;
      allParamsRaw=labeler.trackGetTrainingParams();
      obj.setAllParams(allParamsRaw);
      paramsAll=obj.sPrmAll;
      if isempty(paramsAll)
        error('No tracking parameters have been set.');
      end
      if labeler.maIsMA && strcmp(labeler.trackerAlgo, 'multi_cid') && paramsAll.ROOT.MultiAnimal.multi_loss_mask ,
        error(['For the CiD model, cannot have frames with both lableled and unlabeled animals.  ' ...
               'If all animals are labelled in each frame with any labels, set the tracking parameter "Unlabeled animals present" to false.']) ;
      end

      obj.bgTrnReset_();
      if ~isempty(oldVizObj),
        delete(oldVizObj);
      end
      
      modelChain0 = obj.trnName;
      prev_models = [];
      switch dlTrnType
        case DLTrainType.New
          modelChain = datestr(now(),'yyyymmddTHHMMSS');
          if ~isempty(modelChain0) && ~augOnly
            assert(~strcmp(modelChain,modelChain0));
            fprintf('Training new model %s.\n',modelChain);
            defaultans = 'Yes';
            if isempty(obj.skip_dlgs) || ~obj.skip_dlgs,
              res = questdlg(['Previously trained models exist for current tracking algorithm. ' ...
                              'Do you want to use the previous model for initialization?'], ...
                             'Training Initialization', ...
                             'Yes','No','Cancel', ...
                             defaultans);
            else
              res = defaultans;
            end
            if strcmp(res,'No')
              prev_models = [];
            elseif strcmp(res,'Yes')
              prev_models = obj.trnLastDMC.trainFinalModelLnx;
            else
              return
            end
          end
        case {DLTrainType.Restart DLTrainType.RestartAug}
          if isempty(modelChain0)
            error('Model has not been trained.');
          end
          modelChain = modelChain0;
          fprintf('Restarting train on model %s.\n',modelChain);
        otherwise
          assert(false);
      end

      % Spawn the training job
      obj.trnSpawn_(backend, ...
                    dlTrnType, ...
                    modelChain, ...
                    'prev_models',prev_models, ...
                    'do_just_generate_db',do_just_generate_db, ...
                    'do_call_apt_interface_dot_py', do_call_apt_interface_dot_py, ...
                    'projTempDir', projTempDir) ;
      
      % Nothing should occur here as failed trnSpawn_() will early return      
    end
    
    % function trnPrintLogs(obj)
    %   modelChainID = obj.trnName;
    %   if isempty(modelChainID) 
    %     error('Training is not complete or in progress.');
    %   end
    %   if ~obj.bgTrnIsRunning
    %     fprintf('Training is not in progress; log is for most recent training session.\n');
    %   end
    % 
    %   bgTrainPoller = obj.bgTrainPoller;
    %   bgTrainPoller.printLogfiles();      
    % end
    
    % function trnPrintModelChainDir(obj)
    %   modelChainID = obj.trnName;
    %   if isempty(modelChainID) 
    %     error('Training is not complete or in progress.');
    %   end
    %   if ~obj.bgTrnIsRunning
    %     fprintf('Training is not in progress; log is for most recent training session.\n');
    %   end
    %   bgTrainPoller = obj.bgTrainPoller;
    %   if ~isempty(bgTrainPoller)
    %     bgTrainPoller.dispModelChainDir();
    %   end
    % end
    
    % function trnPrintProjDir(obj)
    %   modelChainID = obj.trnName;
    %   if isempty(modelChainID) 
    %     error('Training is not complete or in progress.');
    %   end
    %   if ~obj.bgTrnIsRunning
    %     fprintf('Training is not in progress; information is for most recent training session.\n');
    %   end
    %   bgTrainPoller = obj.bgTrainPoller;
    %   if ~isempty(bgTrainPoller)
    %     bgTrainPoller.dispProjDir();
    %   end
    % end
    
    % function trnKill(obj)
    %   if ~obj.bgTrnIsRunning
    %     error('Training is not in progress.');
    %   end
    % 
    %   obj.bgTrainPoller.killProcess();      
    % end
    
    % % update trackerInfo from trnLastDMC
    % function syncInfoFromDMC_(obj)      
    %   % info about algorithm and training
    %   info = DeepModelChainOnDisk.trackerInfo(obj.trnLastDMC);
    %   info.algorithm = obj.algorithmNamePretty;
    %   info.isTraining = obj.bgTrnIsRunning;      
    %   obj.trackerInfo = info;
    %   %obj.lObj.doNotify('update_text_trackerinfo') ;
    % end  % function
    
    function info = get.trackerInfo(obj)      
      % info about algorithm and training
      info = DeepModelChainOnDisk.trackerInfo(obj.trnLastDMC);
      info.algorithm = obj.algorithmNamePretty;
      info.isTraining = obj.bgTrnIsRunning;      
      % obj.trackerInfo = info;
      % obj.lObj.doNotify('update_text_trackerinfo') ;
    end  % function
    
    
    % % set select properties of trackerInfo 
    % function setTrackerInfo(obj,varargin)
    % 
    %   [iterCurr] = myparse(varargin,'iterCurr',[]);
    %   ischange = false;
    % 
    %   trackerInfo = obj.trackerInfo; %#ok<PROPLC>
    %   if ~isempty(iterCurr),
    %     ischange = ischange || ~isequaln(iterCurr,trackerInfo.iterCurr); %#ok<PROPLC>
    %     trackerInfo.iterCurr = iterCurr; %#ok<PROPLC>
    %   end
    %   if ischange,
    %     obj.trackerInfo = trackerInfo; %#ok<PROPLC>
    %   end
    % 
    % end
    
    % return a cell array of strings with information about current tracker
    function result = getTrackerInfoString(obj)
      % For OpenPose, consider adding blurb about massaged params
      
      result = {};
      trackerInfo = obj.trackerInfo ;
      result{end+1} = trackerInfo.algorithm;
      if trackerInfo.isTrainStarted ,
        isNewLabels = any(trackerInfo.trainStartTS < obj.lObj.lastLabelChangeTS);

        s = '';
        for i = 1:numel(trackerInfo.trainStartTS),
          s = [s,datestr(trackerInfo.trainStartTS(i)),', ']; %#ok<AGROW> 
        end
        if ~isempty(s), s = s(1:end-2); end
        result{end+1} = sprintf('Train start: %s',s);
        s = DeepTracker.printIter(trackerInfo.iterCurr,trackerInfo.iterFinal);
        result{end+1} = sprintf('N. iterations: %s',s);
        if isempty(trackerInfo.nLabels),
          nlabelstr = '?';
        elseif numel(trackerInfo.nLabels) == 1,
          nlabelstr = num2str(trackerInfo.nLabels);
        else
          nlabelstr = mat2str(trackerInfo.nLabels);
        end          
        result{end+1} = sprintf('N. labels: %s',nlabelstr);
        if isNewLabels,
          s = 'Yes';
        else
          s = 'No';
        end
        result{end+1} = sprintf('New labels since training: %s',s);
        
        sPrmAllLabeler = obj.lObj.trackGetTrainingParams();
        sPrmAllAsSet = obj.massageParamsIfNec(sPrmAllLabeler,'throwwarnings',false);
        args = {'netsUsed',obj.getNetsUsed(),'hasTrx',obj.lObj.hasTrx,'trackerIsDL',true};
        
        if isempty(obj.sPrmAll),
          isParamChange = true;
          isParamChangeLbler = true;
        else
          isParamChange = ~APTParameters.isEqualFilteredStructProperties(...
            obj.sPrmAll,sPrmAllAsSet,args{:});
          isParamChangeLbler = ~APTParameters.isEqualFilteredStructProperties(...
            obj.sPrmAll,sPrmAllLabeler,args{:});
        end
        if isParamChange,
          s = 'Yes';
        else
          s = 'No';
        end
        result{end+1} = sprintf('Parameters changed since training: %s',s);
        
        if isParamChangeLbler
%           if ~isParamChange
%             assert(obj.trnNetType==DLNetType.openpose || obj.trnNetType==DLNetType.leap);
%           end
          result{end+1} = sprintf('Parameter adjustment: %s',obj.trnNetType.displayString);
        end        
      else
        result{end+1} = 'No tracker trained.';
      end
      
    end
    
    function props = propList(obj)
      props = obj.trnNetType.timelinePropList;
    end
    
    % I believe this is not working right now/obsolete
%     function [augims,dataAugDir] = dataAug(obj,ppdata,varargin)
%       
%       [sPrmAll,dataAugDir] = myparse(varargin,...
%         'sPrmAll',[],'dataAugDir','' ...
%         );
%       
%       if isempty(sPrmAll),
%         sPrmAll = obj.sPrmAll;
%       end
%       if isempty(sPrmAll)
%         error('Tracking parameters not set.');
%       end
%       sPrmAll = obj.lObj.addExtraParams(sPrmAll,obj.trnNetMode);
%       
%       cacheDir = obj.lObj.DLCacheDir;
%       if isempty(cacheDir)
%         error('No cache directory has been set.');
%       end
%       
%       lblObj = obj.lObj;
% %       projname = lblObj.projname;
% %       if isempty(projname)
% %         error('Please give your project a name. The project name will be used to identify your trained models on disk.');
% %       end
%             
%       trnBackEnd = lblObj.trackDLBackEnd;
%       fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
%       fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
%       fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
%       fprintf(1,'\n');      
% 
%       switch trnBackEnd.type
%         case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
%           [augims,dataAugDir] = obj.dataAugBsubDocker(ppdata,sPrmAll,...
%             trnBackEnd,'dataAugDir',dataAugDir);
%         case DLBackEnd.AWS
%           error('not implemented');
%           %obj.trnSpawnAWS(trnBackEnd,modelChain,'wbObj',wbObj);    
%         otherwise
%           assert(false);
%       end
%     end
    
    % obsolete, not called by anything
%     function dmc = restoreFromCacheDir(obj,cachedir)
%       % EXPERIMENTAL/DEV use at own risk
%       % uses stripped lbl files, which we are disabling 
%       
%       warningNoTrace('Development/experimental codepath!');
%       if ~DeepModelChainOnDisk.gen_strippedlblfile,
%         warningNoTrace('Stripped lbl file is not being generated! This might break');
%       end%d
%       fprintf(1,'Setting current tracking parameters; these are assumed to be the same as used to train.\n');
%       obj.setAllParams(obj.lObj.trackGetTrainingParams());
%       
%       assert(~obj.lObj.isMultiView,'Currently unsupported for multiview projects.');
%       
%       % Stuff from here on might be a DMC mirror meth
%       
%       dmc = DeepModelChainOnDisk(...
%         'rootDir',cachedir,...
%         'projID',obj.lObj.projname,...
%         'netType',char(obj.trnNetType),...
%         'netMode',obj.trnNetMode,...
%         'view',0,...
%         'modelChainID','',...  % tbd
%         'trainID','',... % tbd
%         'trainType',DLTrainType.New,...
%         'iterFinal','',... %tbd
%         'isMultiView',false,...
%         'reader',DeepModelChainReader.createFromBackEnd(obj.lObj.trackDLBackEnd),...
%         'filesep',obj.filesep...
%         );
%       
%       dd = dir(dmc.dirViewLnx);
%       dd = dd(3:end);
%       assert(isscalar(dd),'Multiple model chain IDs found in %s. Cannot restore.',dmc.dirModelChainLnx);
%       dmc.modelChainID = dd.name;
%       
%       dd = dir(fullfile(dmc.dirModelChainLnx,'deepnet-*.index'));
%       tfsucc = dmc.updateCurrInfo();
%       if tfsucc
%         fprintf(1,'Found latest trained model with iteration %d.\n',dmc.iterCurr);
%       else
%         error('Error finding trained model.');
%       end
%       
%       dd = dir(fullfile(dmc.dirProjLnx,'*.lbl'));
%       assert(isscalar(dd),'Could not find a unique stripped lblfile in %s',dmc.rootDir);
%       toks = regexp(dd.name,'(?<mcID>[0-9T]+)_(?<trnID>[0-9T]+).lbl','names');
%       if isempty(toks)
%         error('Could not find a unique stripped lblfile in %s',dmc.rootDir);
%       end
%       if ~strcmp(toks.mcID,dmc.modelChainID)
%         error('ModelChainID mismatch: %s vs %s.',toks.mcID,dmc.modelChainID);
%       end
%       
%       dmc.trainID = toks.trnID;
%       
%       fprintf('Loading stripped lbl %s...\n',dmc.lblStrippedLnx);
%       s = load(dmc.lblStrippedLnx,'-mat');
%       dmc.nLabels = s.nLabels;
%       fprintf('... success, %d labels.\n',s.nLabels);
%       
%       % ok we made it this far; copy the model into the current
%       % DLCacheDir, otherwise APT acts funny, prob due to save machinery
%       % expecting models to live under current cache etc.
%       dmc2 = dmc.copy();
%       dmc2.rootDir = obj.lObj.DLCacheDir;
%       assert(exist(dmc2.dirModelChainLnx,'dir')==0,'Dir %s already exists.',dmc2.dirModelChainLnx);
%       cmd = sprintf('mkdir -p %s',dmc2.dirModelChainLnx);
%       tfsucc = DeepTracker.syscmd(cmd);
%       if ~tfsucc
%         error('Failed to create dir %s.',dmc2.dirModelChainLnx);
%       end
%       fprintf(1,'Copying trained model into current cache...\n');
%       [tfsucc,msg] = copyfile(dmc.dirModelChainLnx,dmc2.dirModelChainLnx);
%       if ~tfsucc
%         error('Failed to copy model: %s.',msg);
%       end
%       [tfsucc,msg] = copyfile(dmc.lblStrippedLnx,dmc2.lblStrippedLnx);
%       if ~tfsucc
%         error('Failed to copy model: %s.',msg);
%       end
%       
%       obj.trnLastDMC = dmc2;
%       obj.trainCleanup();
%     end
    
    % function dmcs = trnGetDMCs(obj)
    %   % Return all DeepModelChainOnDisks for this obj
    %   % Overloadable meth
    % 
    %   dmcs = obj.trnLastDMC;
    % end
    
  end
  methods
    %% BSub Trainer
      
    function ntgtstot = genTrnPack(obj,dmc,varargin)
      % Generate/write a trnpack; can be used for both stages.
      %
      
      dlConfigLclDir = dmc.dirProjLnx;
      if exist(dlConfigLclDir,'dir')==0
        fprintf('Creating dir: %s\n',dlConfigLclDir);
        [succ,msg] = mkdir(dlConfigLclDir);
        if ~succ
          error('Failed to create dir %s: %s',dlConfigLclDir,msg);
        end
      end
      [~,~,~,ntgtstot] = TrnPack.genWriteTrnPack(obj.lObj,dmc,varargin{:});
    end

    function [jobs,gpuids] = SplitTrackIntoJobs(obj,backend,totrackinfo) %#ok<INUSL> 

      [movidx] = totrackinfo.getIntervals();

      nmovies = numel(movidx);
      nviews = numel(totrackinfo.views);
      % default: one movie & view per job
      jobs = cell(nmovies,nviews);
      gpuids = nan(nmovies,nviews);
      for i = 1:nmovies,
        for j = totrackinfo.views,
          jobs{i,j} = {'movie',movidx(i),'view',totrackinfo.views(j)};
        end
      end

      if backend.isGpuLocal(),
        % how many gpus do we have available?
        nmax = nmovies*nviews;
        gpuids = backend.getFreeGPUs(nmax);
        if numel(gpuids) < 1,
          warning('No GPUs with sufficient RAM available locally');
        elseif numel(gpuids) >= nmax,
          % use default, one movie/view per gpu
        elseif numel(gpuids) >= nmovies,
          gpuids = reshape(gpuids(1:nmovies),[nmovies,1]);
          jobs = cell(nmovies,1);
          for i = 1:nmovies,
            jobs{i} = {'movie',i,'view',totrackinfo.views};
          end
        else % ngpus < nmovies
          ngpus = numel(gpuids);
          movieidx0 = round(linspace(1,nmovies+1,ngpus+1));
          jobs = cell(ngpus,1);
          for i = 1:ngpus,
            jobs{i,1} = {'movie',movieidx0(i):movieidx0(i+1)-1,...
              'view',totrackinfo.views};
          end
          gpuids = reshape(gpuids,[ngpus,1]);
        end
      end


    end

    function [jobidx,view,stage,gpuids] = SplitTrainIntoJobs(obj,backend)
      nview = obj.nview; %#ok<PROPLC> 
      nstage = obj.getNumStages();
      [view,stage] = ndgrid(1:nview,1:nstage); %#ok<PROPLC> 
      view = view(:)';
      stage = stage(:)';
      nmodel = nview*nstage; %#ok<PROPLC> 
      if backend.isGpuLocal(),
        % how many gpus do we have available?
        gpuids = backend.getFreeGPUs(nmodel);
        if numel(gpuids) < nmodel,
          if numel(gpuids)<1,
            error('No GPUs with sufficient unused RAM available locally');
          else
            gpuids = gpuids(1);
            jobidx = ones([1,nmodel]);
          end
        else
          jobidx = 1:nmodel;
        end
      else
        jobidx = 1:nmodel;
        gpuids = nan(1,nmodel);
      end
    end

    function netType = getNetType(obj)
      netType = obj.trnNetType;
    end

    function netMode = getNetMode(obj)
      netMode = obj.trnNetMode;
    end

    function iterFinal = getIterFinal(obj)
      if obj.trnNetType == DLNetType.deeplabcut
        % DeepLabCut is special, it typically ignores a passed-in dl_steps...
        if obj.sPrmAll.ROOT.DeepTrack.DeepLabCut.dlc_override_dlsteps
          % ...unless dlc_override_dlsteps is true
          iterFinal = obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps ;
        else
          iterFinal = 1030000 ;
            % This is the default DeepLapCut number of iterations.
            % If the Python code for DeepLabCut chages s.t. the number of iterations
            % changes, this will have to change.
        end
      else
        % Non-DeepLabCut models honor the provided dl_steps 
        iterFinal = obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps ;
      end
    end  % function

    function trainID = configFile2TrainID(obj,dlConfigLcl) %#ok<INUSL> 
      % dlConfigLcl should look like <modelChainID>_<trainID>.<configExt>
      % FIX THIS - this looks like the trainID is parsed out of the
      % config file name...
      [tpdir,dllblf,~] = fileparts(dlConfigLcl); %#ok<ASGLU> 
      pat = sprintf('%s_(?<trainID>[0-9T]+)$',modelChainID);
      toks = regexp(dllblf,pat,'names');
      trainID = toks.trainID;
    end

    function trainID = getTrainID(obj,varargin)
      [existingTrnPackSLbl,tfGenNewConfigFile] = ...
        myparse(varargin,'existingTrnPackSLbl',[],...
        'tfGenNewConfigFile',true);

      if ~isempty(existingTrnPackSLbl)
        trainID = obj.configFile2TrainID(existingTrnPackSLbl);
      elseif tfGenNewConfigFile,
        trainID = datestr(now,'yyyymmddTHHMMSS');
      else
        trainID = obj.trnNameLbl;
      end
    end

    function res = export_coco_db(obj,outzipfile,varargin)
      % res = export_coco_db(obj,outzipfile,...)
      % Output current project's labels to COCO file format.
      % Creates a zip file outzipfile that contains all the labeled images
      % and a json file with all the labels. 
      % Inputs:
      % outzipfile: Output file path
      % Optional arguments:
      % jsonfilename: Name of COCO json file within zip file. Default:
      % labels.json.
      % Output:
      % res: cell containing relative names of all files output

      [jsonfilename] = myparse(varargin,'jsonfilename','labels.json');

      % create/ensure config file; set trainID
      nstage = obj.getNumStages();
      [view,stage] = ndgrid(1:obj.nview,1:nstage); 
      view = view(:)';
      stage = stage(:)';
      nmodel = obj.nview*nstage; 
      jobidx = 1:nmodel;

      trnType = DLTrainType.New;
      netType = obj.getNetType(); % will have one value for each stage
      netMode = obj.getNetMode();

      % determine trainID, modelChainID -- I don't understand the
      % difference between these
      modelChainID = sprintf('%s_coco_db',obj.lObj.projname);
      trainID = datetime('now','format','yyyyMMdd''T''HHmmSS');

      % Create DMC
      cacheDir = obj.lObj.DLCacheDir ;  % native cache dir
      dmc = DeepModelChainOnDisk('rootDir',cacheDir,...
                                 'projID',obj.lObj.projname,...
                                 'netType',netType(stage),...
                                 'netMode',netMode(stage),...
                                 'jobidx',jobidx,...
                                 'view',view-1,...
                                 'stage',stage,...
                                 'splitIdx',zeros(1,nmodel),...
                                 'modelChainID',modelChainID,... % will get copied for all models
                                 'trainID',trainID,... % will get copied for all models
                                 'trainType',trnType,... % will get copied for all models
                                 'iterFinal',zeros(size(stage)),...
                                 'prev_models',[] ) ;
      obj.genTrnPack(dmc,'cocoformat',true,'jsonfilename',jsonfilename);
      imdir = fullfile(dmc.dirProjLnx,TrnPack.SUBDIRIM);
      jsonfile = fullfile(dmc.dirProjLnx,jsonfilename);
      % this will zip all images in the im directory, not just those
      % generated just now
      res = zip(outzipfile,{jsonfile,imdir},dmc.dirProjLnx);
    end

    function trnSpawn_(obj, backend, trnType, modelChainID, varargin)
      % backend: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set
      %
      % Throws error if something goes wrong.

      [existingTrnPackSLbl, ...
       prev_models, ...
       do_just_generate_db, ...
       do_call_apt_interface_dot_py, ...
       projTempDir] = ...
        myparse(varargin,...
                'existingTrnPackSLbl',[], ...  % for eg topdown tracking where a trnpack/slbl is pre-generated (and applies to both stages)
                'prev_models',[], ...
                'do_just_generate_db',false, ...
                'do_call_apt_interface_dot_py', true, ...
                'projTempDir', '') ;
      
      % create/ensure config file; set trainID
      tfGenNewConfigFile = trnType==DLTrainType.New || ...
                            trnType==DLTrainType.RestartAug;

      [jobidx,view,stage,gpuids] = obj.SplitTrainIntoJobs(backend);
      netType = obj.getNetType(); % will have one value for each stage
      netMode = obj.getNetMode();
      iterFinal = obj.getIterFinal();
      nmodel = numel(jobidx);

      % determine trainID
      trainID = obj.getTrainID('existingTrnPackSLbl',existingTrnPackSLbl,...
                               'tfGenNewConfigFile',tfGenNewConfigFile);

      % Create DMC
      cacheDir = obj.lObj.DLCacheDir ;  % native cache dir      
      dmc = DeepModelChainOnDisk('rootDir',cacheDir,...
                                 'projID',obj.lObj.projname,...
                                 'netType',netType(stage),...
                                 'netMode',netMode(stage),...
                                 'jobidx',jobidx,...
                                 'view',view-1,...
                                 'stage',stage,...
                                 'splitIdx',zeros(1,nmodel),...
                                 'modelChainID',modelChainID,... % will get copied for all models
                                 'trainID',trainID,... % will get copied for all models
                                 'trainType',trnType,... % will get copied for all models
                                 'iterFinal',iterFinal(stage),...
                                 'prev_models',prev_models ) ;
      %dmc.resetFollowsObjDet();
      % TODO figure out how to know which jobs prev_models corresponds to
      % for now, assuming they are in the same order

      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      backend.updateRepo();
            
      if ~isempty(existingTrnPackSLbl),
        assert(strcmp(dmc.trainConfigLnx,existingTrnPackSLbl));
        dmc.readNLabels();
      elseif tfGenNewConfigFile
        ntgtstot = obj.genTrnPack(dmc);
        dmc.setNLabels(ntgtstot);
      else % Restart
        % TODO: implement this. We should be using trnpacks now for
        % everything
        error('Restarts not implemented.') ;
      end

      % At this point
      % We have (modelChainID,trainID) config file on disk. 

      % Upload model to remote filesystem, if needed
      backend.uploadProjectCacheIfNeeded(obj.lObj.DLCacheDir) ;

      % Clear out any old registered jobs in the backend
      backend.killAndClearRegisteredJobs('train') ;

      % Register the training jobs with the backend
      unique_jobs = unique(jobidx);
      njobs = numel(unique_jobs);
      for ijob = 1:njobs,
        assert(ijob==unique_jobs(ijob));
        dmcjob = dmc.selectSubset('jobidx',ijob);
        backend.registerTrainingJob(dmcjob, obj, gpuids(ijob), do_just_generate_db) ;
      end  % for
      
      % Maintain a handle to the DMCoD in obj
      obj.trnLastDMC = dmc;

      % If a dry run, exit early
      if obj.dryRunOnly
        fprintf('Dry run, not spawning training jobs') ;
        return
      end

      % Do various things
      trainSplits = false ;      
      if ~isempty(obj.bgTrnMonitor)
        error('Training monitor exists. Call .bgTrnReset first to stop/remove existing monitor.') ;
      end
      assert(isempty(obj.bgTrainPoller));
      obj.isTrainingSplits_ = trainSplits ;
      netmode = obj.trnNetMode;
      tf2stg = netmode.isTwoStage;
      if dmc.nstages > 1 ,
        assert(tf2stg);        
      end
      
      % Create the worker, etc used to monitor training in the background
      trnWrkObj = BgTrainPoller(dmc, backend) ;
      obj.bgTrainPoller = trnWrkObj;
      bgTrnMonitor = BgMonitor(obj, 'train', trnWrkObj, 'projTempDir', projTempDir) ;
      obj.bgTrnMonitor = bgTrnMonitor;
      % trnVizObj = TrainMonitorViz(dmc, ...
      %                             obj, ...
      %                             trnWrkObj,...
      %                             backend.type, ...
      %                             'trainSplits',trainSplits) ;                
      obj.lObj.needRefreshTrainMonitorViz() ;
      %trnMonObj.start();  % Moved this after spawning, see below

      % spawn training
      backend.spawnRegisteredJobs('train', ...
                                  'jobdesc', 'training job', ...
                                  'do_call_apt_interface_dot_py', do_call_apt_interface_dot_py) ;

      % Start the monitor.  Do this after spawning so we can do it in foreground for
      % debuging sometimes.
      bgTrnMonitor.start();
    end  % trnSpawn_() function
    
    function hfigs = trainImageMontage(obj,trnImgMats,varargin)
      % trnImgMats: cellstr, or could be loaded mats
      
      pppi = obj.lObj.labelPointsPlotInfo;
      mrkrProps = struct2paramscell(pppi.MarkerProps);
      margs0 = {'nr',3,'nc',3,'maskalpha',0.3,...
        'framelblscolor',[1 1 0],...
        'pplotargs',mrkrProps};

      hfigs = myparse(varargin,'hfigs',[]);

      if isempty(hfigs),
        hfigs = nan(1,numel(trnImgMats));
      end

      for i=1:numel(trnImgMats)
        ti = trnImgMats{i};
        if isempty(ti)
          continue;
        end
        
        dam = DataAugMontage();
        dam.init(ti);
        npts = size(dam.locs,2);
        colors = pppi.Colors(1:npts,:); % for eg H/T which has only two pts
        margs = [margs0 {'colors' colors}];
        if numel(hfigs) >= i && hfigs(i) > 0 && ishandle(hfigs(i)) && ~any(hfigs(1:i-1)==hfigs(i)),
          hfig = hfigs(i);
        else
          hfig = [];
        end
        hfigs(i) = dam.show(margs,'hfig',hfig);
      end
    end

    function [tf,tpdir] = trainPackExists(obj)
      dm = obj.trnLastDMC;      
      if ~isempty(dm) 
        [tf,tpdir] = dm(1).trnPackExists();
      else
        tf = false;
        tpdir = [];
      end
    end
    
    function trainPackMontage(obj,varargin)
      
      [maxnpages,plotnr,plotnc,tpdir] = myparse(varargin,...
        'maxnpages',6,...
        'plotnr',3,...
        'plotnc',4, ...
        'tpdir',[] ...
        );
      
      if ~isempty(tpdir)
        tfTrnPackExists = exist(tpdir,'dir')>0;
      else
        [tfTrnPackExists,tpdir] = obj.trainPackExists();     
      end
      
      tfsucc = false;
      if tfTrnPackExists
        try
          [~,~,~,locg] = TrnPack.loadPack(tpdir);
          tfsucc = true; 
        catch ME
          emsg = 'Could not load training package.';
        end                
      else
        emsg = 'Training package does not exist.';
      end
      
      if ~tfsucc
        errordlg(emsg,'Training package missing');
        return;
      end
      
      nplotpage = plotnr*plotnc;
      nplotmax = maxnpages*nplotpage;      
      ldata = locg.locdata;
      if numel(ldata)>nplotmax
        warningNoTrace('Only showing %d/%d frames available in training package.',...
          nplotmax,numel(ldata));
        ldata = ldata(1:nplotmax);
      end
      
      I = arrayfun(@(x)imread(fullfile(tpdir,x.img{1})),ldata,'uni',0);
      I = cellfun(@DataAugMontage.convertIm2Double,I,'uni',0);
      N = numel(ldata);
      D = size(ldata(1).pabs,1);
      ntgtmax = max([ldata.ntgt]);
      p = nan(N,D,ntgtmax);
      rois = cell(N,1);
      for i=1:N
        ntgt = ldata(i).ntgt;
        p(i,:,1:ntgt) = ldata(i).pabs;
        roi = ldata(i).extra_roi.'; % nroi x 8
        if ~isempty(roi)
          roi = roi(:,[2 3 5 6]); % xlo xhi ylo yhi
          rois{i} = roi;
        else
          rois{i} = nan(0,4);
        end
      end
      lbls = arrayfun(@(x)sprintf('%d.%d',x.imov,x.frm),ldata,'uni',0);
      if mean(I{1}(:))>0.5
        lblscolor = [0 0 0];
      else
        lblscolor = [1 1 1];
      end
      
      pppi = obj.lObj.labelPointsPlotInfo;
      mrkrProps = struct2paramscell(pppi.MarkerProps);
      margs0 = { ... %'framelblscolor',[1 1 0],...
        'pplotargs',mrkrProps,...
        'colors',pppi.Colors};
      roiRectArgs = {'EdgeColor' [0 0 1] 'LineWidth' 2};
    
      tstr = sprintf('Training Data (%d images)',N);
      args = {...
        'rois',rois,'titlestr',tstr,...
        'framelbls',lbls, ...
        'framelblscolor',lblscolor, ...
        'framelblsbgcolor','none',...
        'framelblsIsFullSize',true,...
        'roisRectangleArgs',roiRectArgs};
      args = [args margs0];
      h = Shape.montageTabbed(I,p,plotnr,plotnc,args{:});
      set(h,'Name',tstr);      
    end       
  end  % methods block

  methods (Static)
    function basepaths = hlpAugBasePathsWithWarn(basepaths,newpaths,descstr)
      bps = FSPath.commonbase(newpaths);
      if isempty(bps)
        % no nonempty common base found, ie common base is '/'
        warningNoTrace('No common base path found for %s.',descstr);
      else
        fprintf(1,'Found base path ''%s'' for %s.\n',bps,descstr);
        basepaths{end+1,1} = bps;
      end
    end    
  end

  % AWS Trainer    
  methods
              
    function ppdata = fetchPreProcData(obj,tblP,prmsTgtCrop)
      % Fetch preprocessed data per this tracker. Don't update any cache
      % b/c the preproc params supplied may be "trial"/random.
      % 
      % tblP: MFTable
      % ppPrms: scalar struct, preproc params only.
      % 
      % ppdata: CPRData
            
      %ppdb = obj.lObj.ppdb;
      ppdb = PreProcDB();
      ppdb.init();
      [~,ppdata] = ppdb.add(tblP,obj.lObj,'prmsTgtCrop',prmsTgtCrop,...
        'computeOnly',true);
    end
        
    % we should no longer be making stripped lbl files
    function s = trnCreateStrippedLbl(obj,varargin)
      % 
      % - Mutates .trnTblP
      % - can update .lObj.ppdb
      % - Uploads trxs via AWS (maybe obsolete now)
      % - Can throw
      % This does not actually create a stripped label file, just
      % compresses the info we need for training.
      % TODO We should rename this.
      
      [~,wbObj,ppdata,sPrmAll] = myparse(varargin,...
        'awsRemote',false,...
        'wbObj',[],...
        'ppdata',[],...
        'sPrmAll',[]...
        );
      
      [tfsucc,tblPTrn,s] = obj.lObj.trackCreateDeepTrackerStrippedLbl(...
         'wbObj',wbObj,'ppdata',ppdata,'sPrmAll',sPrmAll);
      if ~tfsucc
        error('Failed to create DL stripped lbl file.');
      end
      if isempty(ppdata),
        obj.trnTblP = tblPTrn;
      end
    end  % function
    
  end  % methods
  
  %% Splits
  methods (Static)
    function j = tblSplt2Json(tblSplit,isplit)
      % tblSplit: [nlbledrows x 4] table. cols are MFT and 'split'.
      %  tblSplit.split should be a 1-based (positive) int
      
      tfTst = tblSplit.split == isplit;
      tblTrn = tblSplit(~tfTst,MFTable.FLDSID);
      tblTst = tblSplit(tfTst,MFTable.FLDSID);
      j = jsonencode({tblTrn{:,:} tblTst{:,:}});
    end
  end
  methods 
    function trainsplit(obj,tblSplit,varargin)  %#ok<INUSD> 
      % tblSplit: 
      %   SA: [nlbledrows x 4] table. cols are MFT and .split
      %   MA: [nlbledrows x 3] table. cols are MF and .split
      %   In either case, .split should be a 1-based (positive) int
      %  
      % Any labeled rows not in tblSplit get added to tstfold 1 I guess.
      %
      % In future, can support more general splits as the splits need not
      % perfectly partition tLbl.

      error('TODO: fix trainsplit code');
      % If you want to see this code as it used to be, go back to commits on main from Aug
      % 2025 or earlier.
    end  % function trainsplit
  end  % methods
  
  %% Track  
  methods (Static)
    function [gpuids,isMultiView,isSerialMultiMov] = ...
        trackGPUAllocate(nmovset,nview,gpuidsall)
      % Decide how to break up a batch tracking job across GPUs
      %
      % We take as given a (conceptual) [nmovset x nview] array of movies 
      % to be tracked. Meanwhile the GPUs available are provided in gpuids.
      %
      % gpuidsall should be ordered in reverse GPU desirability, ie earlier
      % GPUs are used first.
      %
      % gpuids: GPUs to use; shape determined by isMultiView/isSerialMultiMov.
      % isMultiView: true if tracking across views is done serially for each movset
      % isSerialMultiMov: true if tracking across movs is done serially
      %   (assumes nview==1 currently)

      % this can be made much better!

      if isempty(gpuidsall),
        gpuids = [];
        isMultiView = nview > 1;
        isSerialMultiMov = true;
        return;
      end
      nmovs = nmovset*nview;
      ngpuall = numel(gpuidsall);
      if ngpuall>=nmovs
        % track all movs in parallel
        gpuids = gpuidsall(1:nmovs);
        gpuids = reshape(gpuids,[nmovset nview]);
        isMultiView = false;
        isSerialMultiMov = false;
      elseif ngpuall>=nmovset 
        % each movset gets a GPU, serial tracking across views.
        % Note this is theoretical atm as callers probably have nmovset==1
        % when nview>1.
        gpuids = gpuidsall(1:nmovset);
        gpuids = gpuids(:);
        isMultiView = true;
        isSerialMultiMov = false;
      elseif nview==1     
        gpuids = gpuidsall(1);
        isMultiView = false;
        isSerialMultiMov = true;
      elseif ngpuall >= nview,
        % each view gets a gpu
        gpuids = gpuidsall(1:nview);
        isMultiView = false;
        isSerialMultiMov = true;
      else
        % put everything on one gpu
        gpuids = gpuidsall(1);
        isMultiView = true;
        isSerialMultiMov = true;
%         % Shouldn't come up yet 
%         assert(false,'Unsupported tracking modality');
      end
      
      fprintf(1,'Allocating %d*%d movs to track across %d available gpus:\n',...
        nmovset,nview,ngpuall);
      fprintf(1,'... using %d gpus, multiview=%d, serialmov=%d\n',...
        numel(gpuids),isMultiView,isSerialMultiMov);
    end
    
    function tdata = massageTrackerData(tdata,lObj,varargin)
      % massage of trackerData created with getSaveToken();
      % this was part of Labeler.trackCreateDeepTrackerStrippedLbl()
      % moved here so that it could be reused
      % KB 20220517
      
      [sPrmAll,fortracking] = myparse(varargin,'sPrmAll',[],'fortracking',false);
      
      tfTD = isfield(tdata,'stg2');      
      if tfTD
        tdata = [tdata.stg1; tdata.stg2];
      end
      if isfield(tdata,'trnNetMode'),
        netmodes = [tdata.trnNetMode];
        assert(all(tfTD==[netmodes.isTwoStage]));
      end
      
      for i=1:numel(tdata)
        if ~isempty(sPrmAll)
          tdata(i).sPrmAll = sPrmAll;
        end
        if ~fortracking,
          tdata(i).sPrmAll = lObj.addExtraParams(tdata(i).sPrmAll,...
                                                 tdata(i).trnNetMode);
        end
        tdata(i).trnNetTypeString = char(tdata(i).trnNetType);
      end
      
      if tfTD
        tdata = num2cell(tdata(:)');
        
        % stage 1 trackData; move Detect.DeepTrack to top-level
        if isSubField(tdata{1}.sPrmAll,{'ROOT','MultiAnimal','Detect','DeepTrack'}),
          tdata{1}.sPrmAll.ROOT.DeepTrack = ...
            tdata{1}.sPrmAll.ROOT.MultiAnimal.Detect.DeepTrack;
          tdata{1}.sPrmAll.ROOT.MultiAnimal.Detect = rmfield(...
            tdata{1}.sPrmAll.ROOT.MultiAnimal.Detect,'DeepTrack');
        end
      else
       tdata = {[] tdata};
      end
      % remove detect/DeepTrack from stage2
      if isSubField(tdata{2}.sPrmAll,{'ROOT','MultiAnimal','Detect'}),
        tdata{2}.sPrmAll.ROOT.MultiAnimal.Detect = rmfield(...
          tdata{2}.sPrmAll.ROOT.MultiAnimal.Detect,'DeepTrack');
      end
    end
  end  % methods (Static)

  methods    
    % Tracking timeline
    % - Call to track. We are talking a single movie right now.
    % - .trnLastDMC must be set. The current backend behavior is the most 
    % recent model in <cache>/.../trnName will be used
    % - BG track monitor started. This polls the filesys for the output
    % file.
    % - Spawn track shell call.
    % - When tracking is done for a view, movIdx2trkfile is updated.
    % - When tracking is done for all views, we stop the bgMonitor and we
    % are done.
    function validateAndSetupForTracking_(obj, totrackinfo, backend)  % protected "by convention"
      % Do some basic sanity checks
      if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      if obj.bgTrnIsRunning && backend.type==DLBackEnd.AWS
        % second clause is really, "only have 1 GPU avail"
        % AWS, currently we are testing with p2.xlarge and p3.2xlarge which
        % are single-GPU EC2 instances. multi-GPU instances are avail
        % however.
        error('Tracking while training is in progress is currently unsupported on AWS.');
      end
      if isempty(obj.trnName)  % Check that a trained tracker exists
        error('No trained tracker found.');
      end
      if isempty(totrackinfo) || totrackinfo.isempty(),
        error('Nothing to track. Should probably catch this earlier.');
      end

      % Make sure the deep learning parameters have not changed since last training
      % bout
      labeler = obj.lObj ;
      sPrmFromLabeler = labeler.trackGetTrainingParams();
      sPrmSet = obj.massageParamsIfNec(sPrmFromLabeler);
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged] = ...
          obj.didParamsChange_(sPrmSet);
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged
        warningNoTrace('Deep Learning parameters have changed since your last training bout.');
      end

      % Set the post-processing parameters
      obj.setPostProcParams(sPrmSet);
      % Specifically allow/support case where tfPostProcChanged is true
      % to enable turning off/on postproc or trying diff pp algos with a 
      % given trained tracker   
      
      % If training is running, do some stuff before proceeding
      if obj.bgTrnIsRunning,
        assert(backend.type~=DLBackEnd.AWS);
        obj.trnLastDMC.iterCurr = obj.backend.getMostRecentModel(obj.trnLastDMC) ;
        iterCurr = obj.trnLastDMC.iterCurr;
        iterCurr(isnan(iterCurr)) = 0;
        if min(iterCurr) == 0,
          % AL updated msg to be palatable for both single and multi-views
          % (in the latter case you may have a tracker for one view but not
          % another)
          error('Training in progress, and in-progress tracker(s) has not been saved yet. Please wait to track.') ;
        end
        question = sprintf(horzcat('Training in progress. Tracking will use in-progress tracker, which has been trained for %s iterations. ', ...
                                   'When training completes, these frames will need to be retracked. Continue?'),...
                           DeepTracker.printIter(iterCurr,obj.trnLastDMC.iterFinal)) ;
        res = questdlg(question,'Use in-progress tracker?','Track','Cancel','Track');
        if strcmpi(res,'Cancel'),
          error('APT:cancelled', 'Tracking cancelled') ;  % This error message will not normally be shown
        end
      end

      % Make sure the model chain is ready to track
      dmc = obj.trnLastDMC ;
      canTrackFromModelIndex = dmc.canTrack() ;
      if isempty(canTrackFromModelIndex) 
        error('DeepTracker:noTrainedTrackers', 'There are no trained trackers.') ;
      end
      untrainedTrackerCount = sum(~canTrackFromModelIndex) ;
      if untrainedTrackerCount > 0 ,
        trackerCount = numel(canTrackFromModelIndex) ;
        error('DeepTracker:thereAreUntrainedTrackers', 'There are %d trackers, but %d of them are untrained.', trackerCount, untrainedTrackerCount) ;
      end

      % Update code on remote filesystem, if needed
      backend.updateRepo() ;

      % Upload model to remote filesystem, if needed
      backend.uploadProjectCacheIfNeeded(obj.lObj.DLCacheDir) ;

      % Upload the movies to the backend
      % localPathFromMovieIndex = obj.lObj.movieFilesAll ;      
      nativePathFromMovieIndex = obj.lObj.movieFilesAllFullGTaware ;
      backend.uploadMovies(nativePathFromMovieIndex) ;

      % % Update the tracker info based on the trained model
      % obj.syncInfoFromDMC_() ;
    end  % function
    
    function track(obj,varargin)
      [totrackinfo,track_type,isexternal,backend,do_call_apt_interface_dot_py,projTempDir] = ...
        myparse(varargin, ...
                'totrackinfo',[], ...
                'track_type','track', ...
                'isexternal',false, ...
                'backend',obj.lObj.trackDLBackEnd, ...
                'do_call_apt_interface_dot_py', true, ...
                'projTempDir',[]) ;

      % Verify that everything is in order for tracking
      obj.validateAndSetupForTracking_(totrackinfo, backend) ;
      
      % figure out if we will need to retrack any frames that were tracked
      % with an old tracker, or if any frames are already tracked
      willLoad = any(obj.lObj.getMovIdxMovieFilesAllFull(totrackinfo.getMovfiles));
      obj.trnLastDMC.iterCurr = obj.backend.getMostRecentModel(obj.trnLastDMC) ;  % make sure up-to-date
      isCurr = obj.checkTrackingResultsCurrent_();
      if willLoad && ~isCurr,
        if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
          res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?', ...
                         'Previous tracking results exist', ...
                         'Delete','Retrack','Cancel','Delete');
          if strcmpi(res,'Cancel'),
            return;
          end
          if strcmpi(res,'Retrack'),
            tblMFTRetrack = obj.getTrackingResultsTable([],'ftonly',true);
            totrackinfo.addTblMFT(tblMFTRetrack);
          end
        end
        obj.cleanOutOfDateTrackingResults_();
      end
      if ~isexternal && isCurr, % saving somewhere
        % remove frames that are already tracked
        tblMFTTracked = obj.getTrackingResultsTable([],'ftonly',true,'aliveonly',true);
        if ~isempty(tblMFTTracked),
          if obj.lObj.maIsMA,
            if totrackinfo.tblMFTIsSet,
              assert(all(MFTable.isTgtUnset(totrackinfo.tblMFT)));
            end
            tblMFTTracked = MFTable.unsetTgt(tblMFTTracked);
          end
          totrackinfo.removeTblMFT(tblMFTTracked);
        end
      end

      % nothing to track?
      if totrackinfo.isempty(),
        error('All requested frames have been tracked already.');
      end
      
      % check if we will overwrite any existing trkfiles, prompt user about
      % deleting
      % trkfiles could be empty if not set yet
      trkfiles = totrackinfo.getTrkFiles();
      trkfilesexist = cellfun(@exist,trkfiles);
      if any(trkfilesexist(:)),
        trkfilesdelete = trkfiles(trkfilesexist>0);
        trkfilesdelete = trkfilesdelete(:);
        ndel = numel(trkfilesdelete);
        MAXTRKFILESDEL = 8;
        if ndel <= MAXTRKFILESDEL
          qstr = [{'The following output trk files already exist. Delete them?'};trkfilesdelete];
        else
          qstr = sprintf('The following output trk files (%d total) already exist. Delete them?',ndel);
          qstr = [{qstr}; trkfilesdelete(1:MAXTRKFILESDEL); {'...<snip>...'}];
        end
        res = questdlg(qstr,'Delete existing trk files?','Delete','Cancel','Cancel');
        if strcmpi(res,'Delete'),
          for i = 1:numel(trkfilesdelete),
            delete(trkfilesdelete{i});
          end
        else
          return
        end
      end

      obj.bgTrkReset_();

      % Spawn the tracking job
      obj.trkSpawn_(totrackinfo, backend, ...
                    'track_type',track_type, ...
                    'do_call_apt_interface_dot_py',do_call_apt_interface_dot_py,...
                    'projTempDir',projTempDir) ;
    end  % function track()

    function trackList(obj, varargin)
      [totrackinfo, backend, argsrest] = ...
        myparse_nocheck(varargin,'totrackinfo',[],'backend',obj.lObj.trackDLBackEnd);
      obj.validateAndSetupForTracking_(totrackinfo, backend);

      % nothing to track?
      if totrackinfo.isempty(),
        fprintf('All requested frames have been tracked already.\n');
        return
      end

      obj.bgTrkReset_();
      obj.trkSpawnList_(totrackinfo,backend,argsrest{:});
    end  % function trackList()

    function gtComplete(obj)      
      t0 = tic;
      while true
        gtmatfiles = obj.trkSysInfo.getListOutfiles;
        gtmovs = obj.lObj.movieFilesAllGTFull;
        tblGT = obj.trackGTgtmat2tbl(gtmatfiles,gtmovs);
        if ~isempty(tblGT),
          break;
        end
        if toc(t0) > 5,
          break;
        end
      end
      obj.trkGTtrkTbl = tblGT;
      obj.lObj.showGTResults('gtResultTbl',tblGT);
    end
        
    function tblGT = trackGTgtmat2tbl(obj,gtmatfiles,gtmovs,varargin)
      
      GTMATLOCFLD = 'locs';
      GTMATOCCFLD = 'occ';
      
      t0 = tic;
      while true,
        if toc(t0) > 5,
          break;
        end
        if all(cellfun(@(x) exist(x,'file'),gtmatfiles)),
          break;
        end
        pause(1);
      end

        
      gtmats = cellfun(@(x)load(x,'-mat'),gtmatfiles); %#ok<LOAD>
      cellfun(@(x)fprintf(1,'Loaded gt output mat-file %s.\n',x),gtmatfiles);
      
      assert(numel(gtmats)==obj.nview);
      if numel(gtmats)>1
        assert(isequal(gtmats.list)); % all mft/metadata tables should match
      end


      mft = gtmats(1).list; % should already be one-based from deepnet
      assert(size(mft,2)==3);
      smovs = native_path_from_wsl(gtmats(1).movieFiles) ;
      gtmovs =gtmovs(:,1);
      [~,gt_mov_match] = ismember(smovs,gtmovs);
      new_mov_ndx = gt_mov_match(mft(:,1));
      mIdx = MovieIndex(-new_mov_ndx'); 

      preds = gtmats(1).pred_locs.(GTMATLOCFLD);
      ndim_locs = ndims(preds);
      %isma = ndim_locs==4;
      pts_dim=ndim_locs-1;
      % labeled/pred_locs are [nfrmtrk x nphyspt x 2] for single animal.
      % [nfrmtrk x nanimals x npyspt x 2] for ma
      out_sz = size(preds);
      out_sz = num2cell(out_sz(1:ndim_locs-2));
      out_sz{end+1} = [];
      gt_pred = [gtmats.pred_locs];
      ptrk = cat(pts_dim,gt_pred.(GTMATLOCFLD));
      %nfrmtrk = size(ptrk,1);
      ptrk = reshape(ptrk,out_sz{:});
      
      tbltrkMFT = table(mIdx(:),uint32(mft(:,2)),uint32(mft(:,3)),...
                        'VariableNames',{'mov' 'frm' 'iTgt'});
      
      sz_occ = size(ptrk);
      sz_occ(end) = sz_occ(end)/2;
      if isfield(gt_pred,GTMATOCCFLD)
        ptrkocc = cat(pts_dim,gt_pred.(GTMATOCCFLD));
        assert(isequal(size(ptrkocc),sz_occ));
      else
        ptrkocc = nan(sz_occ);
      end
      
      tablevars = {ptrk,ptrkocc};
      tablevarnames = {'pTrk' 'pTrkocc'};      
      tblGT = [tbltrkMFT table(tablevars{:},'VariableNames',tablevarnames)];

    end
        
    function [tfCanTrack,reason] = canTrack(obj)
      tfCanTrack = false;
      reason = '';
      
      if obj.bgTrkIsRunning
        reason = 'Tracking is already in progress.';
        return
      end
      
      % For now we do this check here even though the actual parfeval() 
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn tracking monitor.';
        return
      end

      % check trained tracker
      if isempty(obj.trnName)
        reason = 'No trained tracker found.';
        return
      end
      
      if isempty(obj.sPrmAll),
        reason = 'Training parameters not set.';
        return
      end

      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'Cache directory not set.';
        return
      end
      
      backend = obj.lObj.trackDLBackEnd; %#ok<PROP> 
      [isBackendRunning,reasonBackendIsNotRunning] = backend.ensureIsRunning(); %#ok<PROP> 
      if ~isBackendRunning
        reason = reasonBackendIsNotRunning;
        return
      end
            
      dmc = obj.trnLastDMC;
      if ~strcmp(dmc.rootDir,cacheDir)
        reason = 'Cache directory has changed since training.';
        return
      end
      
      % dmcLcl = dmc.copy();
      % % shouldn't be necessary, given previous line checking that these
      % % things are the same??
      % dmcLcl.rootDir = cacheDir ;  % Ensure that dmcLcl is using the *local* version of the cache
      dmcTrainConfig = DeepModelChainOnDisk.getCheckSingle(dmc.trainConfigLnx);
      if ~exist(dmcTrainConfig, 'file') ,
        reason = sprintf('Cannot find training file: %s\n',dmcTrainConfig);
        return
      end
      
      tfCanTrack = true;      
    end  % function
    
    function trkSpawn_(obj,totrackinfo,backend,varargin)
      % Spawn tracking job(s).  Throws if something goes wrong.

      [track_type,do_call_apt_interface_dot_py,projTempDir] = ...
        myparse(varargin,'track_type','track','do_call_apt_interface_dot_py',true,'projTempDir',[]);

      % split up movies, views into jobs
      [jobs,gpuids] = obj.SplitTrackIntoJobs(backend,totrackinfo);
      njobs = numel(jobs);
      if njobs > numel(gpuids) ,
        warning('Not enough GPUs with enough available memory for the tracking jobs.') ;
        return 
      end

      backend.updateRepo() ;
      nowstr = datestr(now(),'yyyymmddTHHMMSS');

      totrackinfojobs = [];

      totrackinfo.setTrainDMC(obj.trnLastDMC);
      totrackinfo.setTrackid(nowstr);
      totrackinfo.setDefaultFiles();

      backend.killAndClearRegisteredJobs('track') ;
      for ijob = 1:numel(jobs),
        [imovjob,ivwjob] = ind2sub(size(jobs),ijob);
        id = sprintf('mov%d_vw%d',imovjob,ivwjob);
        totrackinfojob = totrackinfo.selectSubset(jobs{ijob}{:});
        dmcjob = obj.trnLastDMC.selectSubset('view',totrackinfojob.views-1);
        totrackinfojob.setTrainDMC(dmcjob);
        totrackinfojob.setJobid(id);
        totrackinfojob.setDefaultFiles();

        backend.registerTrackingJob(totrackinfojob, obj, gpuids(ijob), track_type) ;
        backend.prepareFilesForTracking(totrackinfojob);
        obj.trkCreateConfig(totrackinfojob.trackconfigfile);

        if ijob == 1,
          totrackinfojobs = totrackinfojob;
        else
          totrackinfojobs(imovjob,ivwjob) = totrackinfojob; %#ok<AGROW> 
        end
      end

      obj.trkSpawnCore_(totrackinfojobs,totrackinfo,backend,...
                        'do_call_apt_interface_dot_py',do_call_apt_interface_dot_py,...
                        'projTempDir',projTempDir);
    end

    function trkSpawnCore_(obj,totrackinfojobs,totrackinfo,backend,varargin)
      % Spawn tracking job(s), now that the preliminaries are out of the way.
      % Throws if something goes wrong.
      [track_type,do_call_apt_interface_dot_py,projTempDir] = ...
        myparse(varargin,...
                'track_type','movie',...
                'do_call_apt_interface_dot_py',true,...
                'projTempDir',[]);

      if obj.dryRunOnly
        fprintf('Dry run, not tracking.\n');
        %fprintf('%s\n',syscmds{:});
        return
      end

      % start track monitor
      assert(isempty(obj.bgTrkMonitor));
      assert(isempty(obj.bgTrackPoller));

      %bgTrkWorkerObj = DeepTracker.createBgTrkWorkerObj(obj.lObj.nview, obj.trnLastDMC, backend, track_type);
      obj.trkSysInfo = ToTrackInfoSet(totrackinfojobs);
      %bgTrkWorkerObj.initFiles(obj.trkSysInfo);
      poller = BgTrackPoller(track_type, obj.trnLastDMC, backend, obj.trkSysInfo) ;

      % KB 20190115: adding trkviz
      nFramesToTrack = totrackinfo.getNFramesTrack(obj.lObj);  
        % When doing normal tracking (not GT), the length of nFramesToTrack is equal to the
        % number of movies.
      nFramesToTrackSum = sum(nFramesToTrack);
      fprintf('Tracking %d frames.\n',nFramesToTrackSum);

      % Create the TrackMonitorViz, and the BgMonitor, and set them up for
      % monitoring.
      obj.bgTrackPoller = poller;
      %trkVizObj = TrackMonitorViz(totrackinfo.nviews, obj, bgTrkWorkerObj, backend.type, nFramesTrack) ;
      obj.nFramesToTrack_ = nFramesToTrack ;  % stash it so it's available for TrackMonitorViz() in controller
      obj.lObj.needRefreshTrackMonitorViz() ;

      bgTrkMonitorObj = ...
        BgMonitor(obj, 'track', poller, 'projTempDir', projTempDir) ;
      %obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);
      if ~isempty(obj.bgTrkMonitor)
        error('Tracking monitor exists. Call .bgTrkReset first to stop/remove existing monitor.');
      end
      obj.bgTrkMonitor = bgTrkMonitorObj;
      % bgTrkMonitorObj.start();

      % spawn the jobs
      backend.spawnRegisteredJobs('track', ...
                                  'jobdesc','tracking job', ...
                                  'do_call_apt_interface_dot_py',do_call_apt_interface_dot_py);

      % Actually start the background tracking monitor.  We start this *after*
      % spawning the jobs so that when we need to debug the background process by
      % running runPollingLoop() synchronously, the tracking job(s) will already
      % have started.
      bgTrkMonitorObj.start() ;
    end  % function setupBGTrack()

    function trkSpawnList_(obj,totrackinfo,backend,varargin)
      % Spawn a job to track a list of frames.  (This is used for GT tracking, maybe
      % for other things also.)  Throws if something goes wrong.
      [isgt] = myparse(varargin,'isgt',false);
      %tfSuccess = false;

      backend.updateRepo() ;

      nowstr = datestr(now(),'yyyymmddTHHMMSS');

      totrackinfo.setTrainDMC(obj.trnLastDMC);
      totrackinfo.setTrackid(nowstr);
      if isgt
        totrackinfo.setJobid('gt');
      else
        totrackinfo.setJobid('list');
      end        
      totrackinfo.setDefaultFiles();

      totrackinfo.makeListFile(isgt, backend);
      gpuids = backend.getFreeGPUs(1) ;

      backend.killAndClearRegisteredJobs('track') ;
      backend.registerTrackingJob(totrackinfo, obj, gpuids, 'track') ;      
      backend.prepareFilesForTracking(totrackinfo);
      obj.trkCreateConfig(totrackinfo.trackconfigfile);

      obj.trkSpawnCore_(totrackinfo,totrackinfo,backend,'track_type','list');
    end

    function nframes = getNFramesTrack(obj,totrackinfo) %#ok<INUSL>
      % This returns a [nmovsettrk] array, the number of frames to be
      % tracked in each movieset.
      %
      % Note that trksysinfo may either be an [nmovssettrk nviewjobs] 
      % TrackJobs array with one row per movieset to be tracked; or it may 
      % be a scalar TrackJobs object with with tfserialmov=true which
      % represents [nmovsettrk] movies in a single object.

      % could be a single regular TrackJob, or a single TrakcJob with
      % tfserialmov=true
      nframes = totrackinfo.getNFramesTrack();
    end

    function trkPrintTrkOutDir(obj)
      if ~obj.bgTrkIsRunning
        fprintf('Tracking is not in progress; log is for most recent tracking session.\n');
      end
      bgObj = obj.bgTrackPoller; % For AWS this can cause trouble because the AWSEC2 instance is 
        % detached
      bgObj.dispTrkOutDir();
    end
    
    function trkCreateConfig(obj,configFilePathNative,varargin)
      % trkCreateConfig(obj,'sPrmAll',[])
      % 
      [sPrmAll] = myparse(varargin,'sPrmAll',[]);
      
      s = struct();
      s.projectFile = wsl_path_from_native(obj.lObj.projectfile) ;
      s.projname = obj.lObj.projname;
      %s.cfg = obj.lObj.getCurrentConfig();
      tdata = obj.getTrackSaveToken();
      s.trackerData = ...
        DeepTracker.massageTrackerData(tdata,...
                                       obj.lObj,...
                                       'sPrmAll',sPrmAll,...
                                       'fortracking',true);
      slbl = Lbl.compressStrippedLbl(s);
      [jse] = Lbl.jsonifyStrippedLbl(slbl);
      jsen = sprintf('%s\n', jse) ;
      obj.backend.writeStringToFile(configFilePathNative, jsen) ;  % throws if unable to write file
    end  % function
    
  end  % methods

  methods
    function bgTrkReset_(obj)
      obj.trkSysInfo = [];
      if ~isempty(obj.bgTrkMonitor)
        delete(obj.bgTrkMonitor);
      end
      obj.bgTrkMonitor = [];
      if ~isempty(obj.bgTrackPoller)
        delete(obj.bgTrackPoller);
      end
      obj.bgTrackPoller = [];
    end
    
    function createTrkfilesFromListout(obj)
      njobs = obj.trkSysInfo.n;
      for i = 1:njobs
        curj = obj.trkSysInfo.ttis(i);
        for view = curj.views(:)'
          outfile = curj.listoutfiles{view};
          S = load(outfile);
          movies = curj.getMovfiles('view',view);
          trkfiles = curj.getTrkFiles('view',view,'stage',curj.stages(end));
          nMovies = numel(movies);
          for midx = 1:nMovies
            K = TrkFile;
            K.movfile = movies{midx};
            K.initFromTableFull(S,view,midx,outfile);  % outfile only passed for debugging purposes
            K.save(trkfiles{midx});
          end          
        end
      end
    end

    function didCompleteTrainingOrTrackingRetrograde(obj, train_or_track, pollingResult)
      % Called by the child BgMonitor when the latest poll result indicates that
      % training/tracking is complete.
      obj.lObj.pushBusyStatusRetrograde(sprintf('Wrapping up seemingly-successful %sing bout...', train_or_track)) ;
      oc = onCleanup(@()(obj.lObj.popBusyStatusRetrograde())) ;
      if strcmp(train_or_track, 'track') ,
        obj.didCompleteTracking_(pollingResult) ;
      elseif strcmp(train_or_track, 'train') ,
        obj.didCompleteTraining_(pollingResult) ;
      else
        error('Internal error: %s should be ''train'' or ''track''', train_or_track) ;
      end      
    end  % function

    function didCompleteTraining_(obj, pollingResult)
      obj.bgTrnMonitor.stop() ;  % stop monitoring
      obj.waitForJobsToExit('train') ;
        % Right now, tfComplete is true as soon as the output files *exist*.
        % This can lead to issues if they're not done being written to, so we wait for
        % the job(s) to exit before proceeding.
      obj.killJobsAndPerformPostTrainingCleanup_(EndCause.complete) ;
      obj.lObj.trainingEndedRetrograde(EndCause.complete, pollingResult) ;
    end

    function didCompleteTracking_(obj, pollingResult)
      obj.bgTrkMonitor.stop() ;  % stop monitoring
      obj.waitForJobsToExit('track') ;
        % Right now, pollingResult.tfComplete is true as soon as the output files *exist*.
        % This can lead to issues if they're not done being written to, so we wait for
        % the job(s) to exit before proceeding.

      try
        % Put things into some local vars
        backend  = obj.backend ;
        nativeProjectCachePath = obj.lObj.DLCacheDir ;  % native path

        % Ask the backend to do the heavy lifting
        movfiles = obj.trkSysInfo.getMovfiles() ;        
        backend.downloadTrackingFilesIfNecessary(pollingResult, nativeProjectCachePath, movfiles) ;

        % Don't need this anymore since the paths in obj.trkSysInfo are kept local in
        % all cases now.
        % % For remote file systems, relocate the tracking info, so that paths are right
        % obj.trkSysInfo.changePathsToLocalFromRemote(localCacheRoot, backend) ;

        %[nMovies,nViews,nStgs] = size(res);
        nMovies = obj.trkSysInfo.nmovies;
        stages = obj.trkSysInfo.stages;
        views = obj.trkSysInfo.views;
        islistjob = obj.trkSysInfo.islistjob;

        if islistjob
          obj.createTrkfilesFromListout();
          stages = stages(end);
        end

        for movi = 1:nMovies,
          movfiles = obj.trkSysInfo.getMovfiles('movie',movi,'stage',stages(end));
          % seems to only be using the last stage of tracking
          trkfiles = obj.trkSysInfo.getTrkFiles('movie',movi,'stage',stages(end));
          croproi = obj.trkSysInfo.getCroprois('movie',movi);
          calibrationfile = obj.trkSysInfo.getCalibrationfiles('movie',movi);
          if ~isempty(calibrationfile),
            calibrationfile = calibrationfile{1};
          end
          caldata = obj.trkSysInfo.getCalibrationdata('movie',movi);
          obj.trkPostProcIfNec(movfiles,trkfiles,'caldata',caldata,'calibrationfile',...
                               calibrationfile,'cropROIs',cat(1,croproi{:}));
          moviestr = String.cellstr2DelimList(movfiles,', ');

          fprintf('Tracking complete for %s, results saved to:\n',moviestr);
          for vwi = views,
            for stgi = stages,
              track_file_name = ...
                DeepModelChainOnDisk.getCheckSingle(obj.trkSysInfo.getTrkFiles('movie',movi,'view',vwi,'stage',stgi)) ;
              fprintf('  View %d, stage %d: %s\n',vwi,stgi,track_file_name);
            end
          end
          [tffound,mIdx] = obj.lObj.getMovIdxMovieFilesAllFull(movfiles);
          if tffound,
            obj.trackResAddTrkfile(mIdx,trkfiles);
            if mIdx==obj.lObj.currMovIdx,
              obj.trackCurrResUpdate(); % calls vizInit(false)
              if obj.lObj.maIsMA
                obj.jumpToNearestTracking();
                % Jumping to the firstframe was super annoying!!
                % changing so that we don't MK 20220729
              end
              obj.newLabelerFrame();
            end
          else
            for i = 1 : numel(movfiles) ,
              movfile = movfiles{i} ;
              fprintf('Warning: Unable to find movie %s, which allegedly contains tracked frames\n', movfile) ;
            end
          end
        end      
      catch me 
        warning('Error gathering tracking results:\n%s', getReport(me)) ;
        obj.killJobsAndPerformPostTrackingCleanup_(EndCause.error) ;
        obj.lObj.trackingEndedRetrograde(EndCause.error, pollingResult) ;
        return
      end
      
      % Is this is GT tracking, take steps appropraite to that.
      if obj.trkSysInfo.ttis(1).isgtjob
        obj.gtComplete();
      end      

      % If get here, declare victory.
      obj.killJobsAndPerformPostTrackingCleanup_(EndCause.complete) ;
      obj.lObj.trackingEndedRetrograde(EndCause.complete, pollingResult) ;      
    end  % function

    function jumpToNearestTracking(obj)
      % Jump to the startframe of the first tracklet and select it. This enables the
      % Tracklet HUD and timeline.
      %
      % bit of a hack here as special-casing and end-running
      % TrackingVisualizerBase api.
      if ~obj.lObj.maIsMA,
        return;
      end
      tv = obj.trkVizer;
      if isempty(tv) || isempty(tv.ptrx)
        return;
      end
      curfr = obj.lObj.currFrame;
      ss = [tv.ptrx(:).firstframe];
      ee = [tv.ptrx(:).endframe];
      active = find((ss<=curfr)&(ee>=curfr),1);
      if isempty(active)
        % closest tracklet
        [min_ss,sel_ss] = min(abs(curfr-ss));
        [min_ee,sel_ee] = min(abs(curfr-ee));
        if min_ss < min_ee,
          sel = sel_ss;
        else
          sel = sel_ee;
        end
        f0 = tv.ptrx(sel).firstframe;
        if f0~=obj.lObj.currFrame
          obj.lObj.setFrameGUI(f0); % this should result in call to .newLabelerFrame();
        end
      else
        obj.newLabelerFrame(); % not sure what this does... 
        %obj.lObj.setFrameGUI(curfr); % this should result in call to .newLabelerFrame();
        % sel = tv.iTrx2iTrxViz(active);
        sel = active ;  % active is already an index into tv.ptrx
      end

      % tv.trxSelected(sel,true); % the first tv.tvtrx trx should map to ptrx(1)
      tv.trxSelectedTrxID(sel, true) ;  
        % Think we want to call tv.trxSelectedTrxID() here, not tv.trxSelected().
        % sel is an index into tv.pTrx, not an index into tv.tvtrx.  If sel was an
        % index into tv.tvtrx, tv.trxSelected() would be the one to call.  -- ALT,
        % 2025-05-22
    end  % function

    function trkPostProcIfNec(obj,movfiles,trkfiles,varargin) % obj const
      % When appropriate, perform postprocessing and re-save trkfiles in
      % place.
            
      [pp3dtype,calibrationfile,rois,vcd] = myparse(varargin,...
        'pp3dtype',obj.sPrmAll.ROOT.PostProcess.reconcile3dType, ...
        'calibrationfile','',...
        'cropROIs',[],...
        'caldata',[]...
        );

      do3dreconcile = ~strcmp(pp3dtype,'none');
      nvw = obj.lObj.nview;
      moviestr = String.cellstr2DelimList(movfiles,', ');
      %npts = obj.lObj.nPhysPoints;

      if do3dreconcile && nvw >= 2
        if isempty(vcd) || (iscell(vcd)&&isempty(vcd{1}))
          if ~isempty(calibrationfile),
            vcd = CalRig.loadCreateCalRigObjFromFile(calibrationfile);
          else
            warningNoTrace('Cannot perform 3D postprocessing; calibration data unset for %s.',moviestr);
            return;
          end
        end

        assert(numel(trkfiles)==nvw);
        [trks,tfsucc] = ...
          cellfun(@(x)DeepTracker.hlpLoadTrk(x,'rawload',true),trkfiles,'uni',0);
        tfsucc = cell2mat(tfsucc);
        if ~all(tfsucc)
          ivwFailed = find(~tfsucc);
          ivwFailedStr = num2str(ivwFailed(:)');
          warningNoTrace('Cannot perform 3D postprocessing of %s; could not load trkfiles for views: %s.',moviestr,ivwFailedStr);
          return;
        end

        try
          trksave = PostProcess.triangulate(trks,...
            rois,vcd,pp3dtype);
        catch ME
          warningNoTrace('3d postprocessing %s failed: %s',moviestr,ME.getReport());
          return;
        end

        for i = 1:numel(trksave),
          trksavecurr = trksave{i};
          save(trkfiles{i},'-append','-struct','trksavecurr');
          fprintf(1,'Saved/appended variables ''pTrkSingleView'', ''pTrk'', ''pTrk3d'' to trkfile %s.\n',...
            trkfiles{i});
        end
      end
    end

    function killJobsAndPerformPostTrainingCleanup_(obj, endCause)
      % Does what it says on the tin.

      % Check for programmer error
      if endCause == EndCause.undefined
        error(strcatg('Internal Error.  Please notify the APT developers that endCause was equal to EndCause.undefined on entry ', ...
                      'to DeepTracker.killJobsAndPerformPostTrainingCleanup().')) ;
      end

      % Set now to listeners can determine training bout outcome
      obj.lastTrainEndCause_ = endCause ;

      % % Someday, training splits will return!
      % trainSplits = obj.isTrainingSplits_ ;
      % if trainSplits
      %   % unchecked codepath 20210806
      %   assert(backEnd.type==DLBackEnd.Bsub);
      %   % obj.killJobsAndPerformPostCrossValidationCleanup_() ;
      %   return
      % end
      
      % Make sure all the spawned jobs are unalive
      backend = obj.backend ;
      backend.killAndClearRegisteredJobs('train') ;

      % What does this do, and why do we do it here?  -- ALT, 2025-04-22
      obj.trackCurrResUpdate();

      % What does this do, and why do we do it here?  -- ALT, 2025-04-22
      obj.newLabelerFrame();
      
      % Update the number of completed iterations
      obj.trnLastDMC.iterCurr = obj.backend.getMostRecentModel(obj.trnLastDMC) ;
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      isCurr = obj.checkTrackingResultsCurrent_() ;
      if ~isCurr
        obj.cleanOutOfDateTrackingResults_();
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
        % % MK 20230301 -- tried to make it work for single animal projects
        % % but couldn't create tinfo properly enough after a few feeble
        % % attempts. Abandoning it for someone more valorous.
        % if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
        %   res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Delete');
        %   if strcmpi(res,'Retrack'),
        %     tblMFTRetrack = obj.getTrackingResultsTable([],'ftonly',true);
        %     tinfo = ToTrackInfo('tblMFT',tblMFTRetrack,'trainDMC',obj.trnLastDMC,...
        %       'moviefiles',obj.lObj.movieFilesAll,'trxfiles',obj.lObj.trxF);
        %     obj.track('totrackinfo',tinfo);
        %   end
        % end
      end  % if
    end  % function
    
    function killJobsAndPerformPostTrackingCleanup_(obj, endCause)
      % Check for programmer error
      if endCause == EndCause.undefined
        error(strcatg('Internal Error.  Please notify the APT developers that endCause was equal to EndCause.undefined on entry ', ...
                      'to DeepTracker.killJobsAndPerformPostTrackingCleanup_().')) ;
      end

      % Set this now, so that listeners can know the tracking bout outcome
      obj.lastTrackEndCause_ = endCause ;
      
      % Make sure all the spawned jobs are unalive
      backend = obj.backend ;
      backend.killAndClearRegisteredJobs('track') ;
      
      % Do other stuff
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end  % function

    function args = trnType2ConstructorArgs(obj,trntypes,loc)
      % args = trnType2ConstructorArgs(obj,trntypes,loc)
      % Returns extra arguments necessary for instantiating this network based on trntypes. 
      % For DeepTracker, this is an empty cell. 
      args = {};
    end

    % function killJobsAndPerformPostCrossValidationCleanup_(obj,varargin)      
    %   % load xv res
    %   % KB TODO update this code once cross-val is debugged
    %   dmc = obj.trnSplitLastDMC;
    %   tfE = cellfun(@exist,dmc.valresultsLnx);
    %   if all(tfE)
    %     splitIdx = dmc.getSplits();
    %     nsplt = numel(unique(splitIdx));
    % 
    %     info = [];
    %     locs = [];
    %     preds = [];
    %     splt = [];
    %     %mdlfile = [];
    %     for isplt=1:nsplt,
    %       resfile = dmc.valresultsLnx('splitIdx',isplit);
    %       assert(numel(resfile)==1);
    %       resfile = resfile{1};
    %       % TODO make this work with multi-view, etc.
    %       res = load(resfile,'-mat');
    %       fprintf(1,'Loaded results file %s\n',resfile);
    % 
    %       predlocs = res.pred_locs.locs; % n x maxnanimals x npts x 2
    %       lbllocs = res.labeled_locs; % etc
    %       ni = numel(res.list);
    %       assert(isequal(ni,size(lbllocs,1),size(predlocs,1)));
    % 
    %       %errl2 = sqrt(sum((lbllocs-predlocs).^2,4)); % [n x maxnanimals x npts]
    %       info = cat(1,info,cat(1,res.list{:}));
    %       locs = cat(1,locs,lbllocs); %reshape(lbllocs,ni,[]));
    %       preds = cat(1,preds,predlocs); %reshape(predlocs,ni,[])); 
    %       %errs = cat(1,errs,errl2);
    %       splt = cat(1,splt,isplt*ones(ni,1));
    %       %mdlfile = cat(1,mdlfile,repmat({char(res.model_file)},ni,1));
    %     end
    % 
    %     info = cell2mat(info);
    %     LOCTHRESH = -1e3;
    %     tfLblExist = locs(:,:,1,1)>LOCTHRESH; % n x maxnanimals
    %     tfPrdExist = preds(:,:,1,1)>LOCTHRESH; % note: nan will not count as existing
    %     [~,~,npts,d] = size(locs);
    %     locs(repmat(~tfLblExist,1,1,npts,d)) = nan;
    %     preds(repmat(~tfPrdExist,1,1,npts,d)) = nan;
    %     [~,match,matchcosts,~,~,nFP,nFN,nMch,nLbl,nPrd] = ...
    %       MAGT.comparePredsLbls(locs,preds,tfLblExist,tfPrdExist);
    % 
    %     tblXVres = table(info(:,1),info(:,2),info(:,3),splt,...
    %       preds,locs,nFP,nFN,nMch,nLbl,nPrd,match,matchcosts,'VariableNames',...
    %       [MFTable.FLDSID {'fold' 'p' 'pLbl' 'numFP' 'numFN' 'numMatch' 'numLbl' 'numPred' 'matches' 'matchcosts'}]);
    %     obj.lObj.xvResults = tblXVres;
    %     obj.lObj.xvResultsTS = now;
    %     fprintf(1,'Set XV results on lObj.xvResults.*\n');
    % 
    %     obj.lObj.doNotify('trainEnd');
    % 
    %     splitProjDirs = fileparts(fileparts(valresfiles));
    %     imreadfn = @(x)MAGT.readCoco(x,splitProjDirs);
    %     MAGT.report(tblXVres,obj.lObj,imreadfn);
    %   end
    % end
    
    % function [trnstrs,modelFiles] = getTrainStrModelFiles(obj)
    %   obj.trnLastDMC.iterCurr = obj.backend.getMostRecentModel(obj.trnLastDMC) ;
    % 
    %   trnstrs = cell(1,obj.trnLastDMC.n);
    %   modelFiles = cell(1,obj.trnLastDMC.n);
    %   for i = 1:obj.trnLastDMC.n,
    %     assert(~isnan(obj.trnLastDMC.iterCurr(i)));
    %     trnstrs{i} = sprintf('trn%s_iter%d',obj.trnName,obj.trnLastDMC.iterCurr(i));
    %     modelFiles(i) = obj.trnLastDMC.trainCurrModelLnx(i);
    %     modelFiles{i} = regexprep(modelFiles{i},'\.index$','');
    %   end
    % end
    
  end  % methods

  methods (Static)  % train/track codegen
    function repoSScmd = repoSnapshotCmd(aptroot,aptrepo)
      repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
      repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,aptrepo);
    end

    function baseargs = trainTopDownBaseArgs(dmc)
      stages = unique(dmc.getStages());
      if numel(stages) > 1,
        stagearg = 0;
      else
        stagearg = stages;
      end
      baseargs = {...
        'maTopDown' true ... % missing: 'maTopDownStage'
        'maTopDownStage1NetType' dmc.getNetType('stage',1) ...
        'maTopDownStage1NetMode' dmc.getNetMode('stage',1) ...
        'maTopDownStage' stagearg ...
        };
    end

    function [m,tfsuccess,isold] = parseTrkFileName(trkfile)
      tfsuccess = false;
      isold = false;
      [p,n,e] = fileparts(trkfile);
      m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>\d{8}T\d{6})_(view)?(?<view>\d+)?_?(iter)?(?<iter>\d+)?_?(?<trk_ts>\d{8}T\d{6}).*$','names','once');
      if ~isempty(m),
        if ~isfield(m,'iter')
          fprintf('trkfile %s does not have iteration name in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
            m.iter = iter(1);
            isold = true;
          catch ME,
            warning('Could not parse iteration from trkInfo.model_file');
            disp(getReport(ME));
            return;
          end
        else
          m.iter = str2double(m.iter);
        end
        if ~isfield(m,'view'),
          fprintf('trkfile %s does not have view in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            view = DeepModelChainOnDisk.getModelFileView(char(tmp.trkInfo.model_file));
            m.view = view(1);
            isold = true;
          catch ME,
            warning('Could not parse view from trkInfo.model_file');
            disp(getReport(ME));
            return;
          end
        else
          m.view = str2double(m.view);
        end
          
      else
        try
          tmp = load(trkfile,'trkInfo','pTrkTS','-mat');
          m = struct;
          [~,m.base] = fileparts(tmp.trkInfo.mov_file);
          m.trn_ts = tmp.trkInfo.name;
          iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
          m.iter = iter(1);
          if iscell(tmp.pTrkTS),
            min_ts = min(cellfun(@(x) min([nan;x(x(:)>0)]),tmp.pTrkTS(:)));
          else
            min_ts = min(tmp.pTrkTS(:));
          end
          m.trk_ts = datestr(min_ts,'yyyymmddTHHMMSS');
          isold = true;
        catch ME,
          warning('Could not parse trk file info from trkInfo');
          disp(getReport(ME));
          return;
        end
      end
      m.path = p;
      m.ext = e;
      m.newName = fullfile(m.path,[m.base '_trn' m.trn_ts '_iter' num2str(m.iter) '_' m.trk_ts m.ext]);
      tfsuccess = true;
    end  % function
    
%     function [tfsucc,res] = waitForBsubComplete(jobid,cmd,nout,maxWaitTime,doKill)
%       starttime = tic;
%       res = cell(1,nout);
%       bjobscmd = sprintf('bjobs %d',jobid);
%       bjobscmd = wrapCommandSSH(bjobscmd,'host',DLBackEndClass.jrchost);
%       killcmd = sprintf('bkill %d',jobid);
%       killcmd = wrapCommandSSH(killcmd,'host',DLBackEndClass.jrchost);
%       runStatuses = {'PEND','RUN','PROV','WAIT'};
%       doneStatuses = {'DONE'};
%       tfJobRunning = false;
%       tfJobDone = false;
%       
%       while true,
%         if toc(starttime) > maxWaitTime,
%           break;
%         end
%         [tfsucc,res{:}] = cmd();
%         %[augims,tfsucc] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
%         if tfsucc,
%           break;
%         end
%         tfJobRunning = false;
%         [st2,res2] = system(bjobscmd);
%         if st2 == 0,
%           ss = strsplit(res2,'\n');
%           ism = ~cellfun(@isempty,regexp(ss,'^JOBID','once'));
%           i = find(ism,1);
%           if ~isempty(i) && i < numel(ss),
%             
%             % make sure outout is formatted as I think it should be
%             assert(~isempty(regexp(ss{i},'^\s*JOBID\s*USER\s*STAT','once')))
%             res3 = ss{i+1};
%             m = regexp(res3,'^(?<jobid>\d+)\s+(?<user>\w+)\s+(?<stat>\w+)','names','once');
%             assert(~isempty(m));
%             tfJobRunning = ismember(m.stat,runStatuses);
%             tfJobDone = ismember(m.stat,doneStatuses);
%             %fprintf('%fs: %s\n',toc(starttime),m.stat);
%             
%           end
%         end
%         if ~tfJobRunning && ~tfJobDone,
%           warning('Could not find results. Output of bjobs:\n%s\n',res2);
%           break;
%         end
%         drawnow;
%       end
%       if ~tfsucc && tfJobRunning && doKill,
%         [st4,res4] = system(killcmd);
%         if ~st4 == 0,
%           error('Error killing:\n%s',res4);
%         end
%       end
%       
%     end  % function
  end  % methods (Static)

  methods (Static) % train/track broker util
    function hdir = dlerrGetHomeDir
      m = getenvall;
      hdir = m('HOME');
    end
%     function errfile = dlGetTrackErrFile(trnID,hdir)
%       if exist('hdir','var')==0
%         hdir = DeepTracker.dlerrGetHomeDir;
%       end
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       errfileS = [trnID '_' nowstr '.err'];
%       errfile = fullfile(hdir,errfileS);
%     end
  end
  
  %% TrackRes = Tracking DB. all known tracking results on disk.  
  methods
    function trackResInit(obj)
      m = containers.Map('keytype','int32','valuetype','any');
      obj.movIdx2trkfile = m;
    end
    function trackResAddTrkfile(obj,mIdx,trkfiles)
      % Remember/add a set of [nview] trkfiles associated with mIdx
      
      assert(isscalar(mIdx));
      assert(iscellstr(trkfiles));  %#ok<ISCLSTR> 
            
      [v,id] = obj.trackResGetTrkfiles(mIdx);      
      v(end+1,:) = trkfiles(:)';
      obj.movIdx2trkfile(id) = v;
    end
    function [trkfiles,id] = trackResGetTrkfiles(obj,mIdx)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        trkfiles = m(id);
      else
        trkfiles = cell(0,obj.lObj.nview);
      end      
    end
    function trackResSetTrkfiles(obj,mIdx,trkfiles)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        obj.movIdx2trkfile(id) = trkfiles;
      else
        obj.trackResAddTrkfile(mIdx,trkfiles)
      end      
    end
    function removeMissingTrkFiles(obj,mIdx)
      [trkfiles,id] = obj.trackResGetTrkfiles(mIdx);
      tfexists = cellfun(@(x) exist(x,'file'),trkfiles)>0;
      if ~all(tfexists),
        obj.movIdx2trkfile(id) = trkfiles(tfexists);
      end
    end
    function [tfhasdata,xy,occ,sf,ef,aux,auxlbl] = ...
                            getTrackingResultsCurrMovieTgt(obj)
      lo = obj.lObj;
      if lo.maIsMA
        if ~isempty(obj.trkVizer)
          iTgt = obj.trkVizer.currTrklet;
        else
          iTgt = [];
        end
      else
        iTgt = lo.currTarget;
      end
      trk = obj.trkP;
      if ~isempty(iTgt) && ~isnan(iTgt) && ~isempty(trk)
        nt = obj.trnNetType;
        auxflds = nt.trkAuxFields;
        if isempty(auxflds)
          ispropcurr = [];
        else
        ispropcurr = cellfun(@(x) isprop(trk,x),auxflds);
        end
        auxlbl = nt.trkAuxLabels(:);
        auxflds = auxflds(ispropcurr);
        auxlbl = auxlbl(ispropcurr);
        [tfhasdata,xy,occ,sf,ef,aux] = trk.getPTrkTgt2(iTgt,'auxflds',auxflds);
      else
        tfhasdata = false;
        xy = [];
        occ = [];
        sf = nan;
        ef = nan;
        aux = [];
        auxlbl = cell(0,1);
      end      
    end
    function [trkfileObjs,tfHasRes] = getTrackingResults(obj,mIdx)
      % Get tracking results for MovieIndices mIdx
      %
      % mIdx: [nMov] vector of MovieIndices
      %
      % trkfiles: [nMovxnView] cell of TrkFile objects, or [] if tfHasRes(...) is false
      % tfHasRes: [nMov] logical. If true, corresponding movie(set) has 
      %   tracking nontrivial (nonempty) tracking results
      %
      % DeepTracker uses the filesys as the tracking result DB. This loads 
      % from known/expected trkfiles.
            
      assert(isa(mIdx,'MovieIndex'));
      nMov = numel(mIdx);
      nView = obj.nview;
      trkfileObjs = cell(nMov,nView);
      tfHasRes = false(nMov,1);
      lObj = obj.lObj;
      for i=1:nMov
        mIdxI = mIdx(i);
        trkfilesI = obj.trackResGetTrkfiles(mIdxI);
        movfile = lObj.getMovieFilesAllFullMovIdx(mIdxI);
        movnframes = lObj.getNFramesMovIdx(mIdxI);
        ntrk = size(trkfilesI,1);
        
        if ntrk==0
          % trkfileObjs, tfHasRes, trkfiles initted appropriately
          continue;
        end          
        if ntrk>1
          warningNoTrace('Merging tracking results from %d poseTF trkfiles.\n',ntrk);
        end        
        for ivw=1:nView
          [trkfilesIobj,tfsuccload] = ...
            cellfun(@(f) DeepTracker.hlpLoadTrk(f,'movfile',movfile{ivw},...
                                                  'movnframes',movnframes),...
            trkfilesI(:,ivw),'uni',0);
          tfsuccload = cell2mat(tfsuccload);
          trkfilesIobj = trkfilesIobj(tfsuccload);
          hasdata = cellfun(@(trk) trk.hasdata(),trkfilesIobj);
          trkfilesIobj = trkfilesIobj(hasdata);

          if isempty(trkfilesIobj)
            % if all loads failed
            % none; trkfiles, tfHasRes OK
          else
            tObj = trkfilesIobj{1};
            if numel(trkfilesIobj)>1
              tObj = tObj.merge(trkfilesIobj(2:end),'new_ids',lObj.maIsMA);
            end
            trkfileObjs{i,ivw} = tObj;
            tfHasRes(i) = true;
          end
        end
      end
    end

    function isCurr = checkTrackingResultsCurrent_(obj)
      % It seems that this function checks whether all the existing tracking results
      % come from the current trained tracker.  It returns true if they all do,
      % false if any do not.  It also seems to fix any issues that it uncovers where
      % the names of the tracking files reflect the wrong model name, or something.
      % But not 100% clear to me.  -- ALT, 2025-04-22

      isCurr = true;
      for moviei = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(moviei);
        % some trkfiles don't exist for some reason
        obj.removeMissingTrkFiles(mIdx);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if isempty(trkfiles),
          continue
        end        
        isFixed = false;
        newtrkfiles = trkfiles;
        for i = 1:size(trkfiles,1),
          for ivw = 1:size(trkfiles,2),
            [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfiles{i,ivw},ivw);
            assert(tfSuccess);
            if isOldFileName,
              isFixed = true;
              [tfSucc,msg] = copyfile(trkfiles{i,ivw},trkInfo.newName);
              if ~tfSucc,
                warning('Could not rename %s to %s: %s',trkfiles{i,ivw},newtrkfiles{i,ivw},msg);
              else
                newtrkfiles{i,ivw} = trkInfo.newName;
              end
            end
            if ~isCurr,
              %fprintf('Trkfile %s out of date, removing all tracking for movie %d\n',trkfiles{i},moviei);
              break
            end
          end
        end
        if isFixed,
          obj.trackResSetTrkfiles(mIdx,newtrkfiles);
        end
        if ~isCurr,
          break
        end
      end  % for moviei      
    end  % function
        
    function cleanOutOfDateTrackingResults_(obj)
      obj.trackResInit();
      obj.trackCurrResInit();
      % deleting old tracking results, so can switch to new tracker info
      obj.vizInit();
      % obj.syncInfoFromDMC_();      
    end
    
    function [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfile,ivw)
      isCurr = true;
      [trkInfo,tfSuccess,isOldFileName] = DeepTracker.parseTrkFileName(trkfile);
      if ~tfSuccess,
        return;
      end
      curIter = obj.trnLastDMC.getIterCurr('view',ivw-1);
      if numel(curIter)>1
        % for 2 stage
        curIter = curIter(2);
      end
      isCurr = strcmp(DeepModelChainOnDisk.getCheckSingle(obj.trnLastDMC.getModelChainID('view',ivw-1)),trkInfo.trn_ts) && ...
        (DeepModelChainOnDisk.getCheckSingle(curIter)==trkInfo.iter);
    end
    
    function tf = isTrkFiles(obj)
    
      tf = false;
      for i = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(i);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if ~isempty(trkfiles),
          tf = true;
          return;
        end
      end
      
    end
    
  end
  methods (Static)
    
    function [trkfileObj,tfsuccload] = hlpLoadTrk(tfile,varargin)
      % why in the world is this here and not TrkFile? MK 20230509
      [rawload,movfile,movnframes] = myparse(varargin,...
        'rawload',false,...
        'movfile','',...
        'movnframes',[] ...
        );
            
      try
        if rawload
          trkfileObj = load(tfile,'-mat');
        else
          trkfileObj = TrkFile.load(tfile,'issilent',true,'movfile',movfile,...
                                    'movnframes',movnframes);
        end
        tfsuccload = true;
      catch ME
        warningNoTrace('Failed to load trkfile: ''%s''. Error: %s',...
          tfile,ME.message);
        trkfileObj = [];
        tfsuccload  = false;
      end
    end    
    
    function [tfsucc,augims] = loadAugmentedData(outfile,nview)

      tfsucc = false;
      augims = struct;
      for i = 1:nview,
        outfile_curr = sprintf('%s_%d.mat',outfile,i-1);
        if ~exist(outfile_curr,'file'),
          return;
        end
        da = load(outfile_curr);
        augims.ims{i} = permute(da.ims,[2,3,4,1]);
        augims.locs{i} = da.locs;
      end
      tfsucc = true;
    end
    
    function s = printIter(iterCurr,iterFinal)

      s = '';
      assert(numel(iterCurr)==numel(iterFinal));
      for i = 1:numel(iterCurr),
        s = [s,sprintf('%d/%d, ',iterCurr(i),iterFinal(i))]; %#ok<AGROW> 
      end
      if ~isempty(s),
        s = s(1:end-2);
      end

    end  % function

  end
  methods
    
    function tblTrkRes = getTrackingResultsTable(obj,mIdxs,varargin) % obj const
      % Get all current tracking results in a table
      %
      % mIdxs: [nmovrequested] vector of MovieIndices. Pass [] to get all
      %   results/movies.
      % 
      % tblTrkRes: [NTrk x ncol] table of tracking results
      %            .pTrk; ABSOLUTE coords
      % pTrkiPt: [npttrk] indices into 1:obj.npts, tracked points. 
      %          size(tblTrkRes.pTrk,2)==npttrk*d
  
      [ftonly,aliveonly] = myparse(varargin,...
        'ftonly',false,...
        'aliveonly',false...
        );
      
%       isMA = obj.lObj.maIsMA;
%       if isMA
%         assert(ftonly);
%       end
        
      m = obj.movIdx2trkfile;
      
      if m.isempty
        tblTrkRes = [];
        %pTrkiPt = [];
        return;
      end
      
      if nargin < 2 || isequal(mIdxs,[])
        mIdxs = m.keys;
        mIdxs = cell2mat(mIdxs(:));
      end
      if ~isa(mIdxs,'MovieIndex'),
        mIdxs = MovieIndex(mIdxs);
      end
      [trk,tfhasres] = obj.getTrackingResults(mIdxs);

      tblTrkRes = [];
      %pTrkiPt = -1;
      for i=1:numel(mIdxs)

        if tfhasres(i)
          tbls = cellfun(@(x)x.tableform('ftonly',ftonly,'aliveonly',aliveonly),trk(i,:),'uni',0);
          tblI = TrkFile.mergetablesMultiview(tbls{:});         
%           if isMA
%             tbl = TrxUtil.tableFT(trk{i,1});
%             tbl.iTgt = repmat(1,height(tbl),1);
%           else
%             if isfield(trk{i,1},'pTrkiPt')
%               if isequal(pTrkiPt,-1)
%                 pTrkiPt = trk{i,1}.pTrkiPt;
%               end
%               if ~isequal(pTrkiPt,trk{i,1}.pTrkiPt)
%                 error('Trkfiles differ in tracked points .pTrkiPt.');
%               end
%               tbl = trk{i,1}.tableform;
%             else
%               tbl = TrxUtil.tableFT(trk{i,1});
%               tbl.iTgt = repmat(1,height(tbl),1);
%               % MK 20210415: TODO update this for trx based tracklets
%               % format trk file.
%             end
%           end
          tblmov = table(repmat(mIdxs(i),height(tblI),1),'VariableNames',{'mov'});
          tblI = [tblmov tblI]; %#ok<AGROW>
          tblTrkRes = [tblTrkRes; tblI]; %#ok<AGROW>
        end         
      end
    end
    function clearTrackingResults(obj)
      % FUTURE TODO: For now we do not actually delete the previous trkfiles.
      obj.trackResInit();
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  
  %% TrackCurrRes = tracked state for current movie. Loaded into .trkP*
  methods
    function trackCurrResInit(obj)
      % Assumes that .trnNetType is set
      obj.trkP = [];
      % all calls to trackCurrResInit should be followed by calls to
      % vizInit() to destroy trkVizer.
    end
    function trackCurrResUpdate(obj)
      % update trackCurrRes (.trkP*) from trackRes (tracking DB)
      labeler = obj.lObj ;
      if ~isvalid(labeler) ,
          return
      end
      mIdx = labeler.currMovIdx;
      if isempty(mIdx) || mIdx==0 || obj.lObj.isinit
        % proj load etc
        return;
      end
      [trks,tfHasRes] = obj.getTrackingResults(mIdx);
      if tfHasRes
        %obj.trackCurrResLoadFromTrks(trks);
        trks{1}.mergeMultiView(trks{2:end});
        trk1 = trks{1};
        trk1.initFrm2Tlt(obj.lObj.nframes);
        obj.trkP = trk1;
        obj.vizInit(false);
      else
        obj.trackCurrResInit();
        obj.vizInit();
      end
      %obj.lObj.doNotify('newTrackingResults');
      obj.lObj.setCurPropTypePredictionDefault();
    end
    
    function [tfhaspred,xy,tfocc] = getTrackingResultsCurrFrm(obj)
      % See TrkFile/getPTrkFrame
      
      frm = obj.lObj.currFrame;
      xyPCM = obj.trkP;
      
      if isempty(xyPCM)
        npts = obj.nPts;
        nTgt = obj.lObj.nTargets;
        tfhaspred = false(nTgt,1);
        xy = nan(npts,2,nTgt);
        tfocc = false(npts,nTgt);        
      else
        % AL20160502: When changing movies, order of updates to 
        % lObj.currMovie and lObj.currFrame is unspecified. currMovie can
        % be updated first, resulting in an OOB currFrame; protect against
        % this.
        
        %frm = min(frm,size(xyPCM,3));
        %xy = squeeze(xyPCM(:,:,frm,:)); % [npt x d x ntgt]
        [tfhaspred,xy,tfocc] = xyPCM.getPTrkFrame(frm,'collapse',true);
        
%         if nargout>1
%           fprintf(2,'TODOXXX');
%           %tfscrocc = strcmp(obj.trkAuxLbl,'scr_occ');
%           switch nnz(tfscrocc)
%             case 0
%               scrocc = nan(obj.nPts,obj.lObj.nTargets);
%             case 1
%               %scrocc = squeeze(obj.trkAux(:,frm,:,tfscrocc));
%             otherwise
%               assert(false,'Multiple fields matching ''scr_occ''.');              
%           end
%           tfocc = scrocc > DeepTracker.MDN_OCCLUDED_THRESH;              
%         end
      end
    end
  end
    
  %% Viz
  methods
    function vizInit(obj,existingTVvizInit)
      % - if .trkP is empty, deletes .trkVizer and returns.
      % - if .trkVizer is empty:
      %     - creates one
      %     - calls trkVizer.vizInit
      % - if .trkVizer existed, call vizInit() if existingTVvizInit==true.
      % - call trkVizer.trkInit() on current .trkP.
      
      if isempty(obj.trkP)
        delete(obj.trkVizer);
        obj.trkVizer = [];
        return;
      end
      
      if nargin < 2
        existingTVvizInit = true;
      end
      
      lObj = obj.lObj;
      tv = obj.trkVizer;
      if isempty(tv)
        tvtagpfix = sprintf('dt_%s',obj.algorithmName);
        tv = lObj.createTrackingVisualizer('predPointsPlotInfo',tvtagpfix);        
        obj.trkVizer = tv;
        tfnewTV = true;
      else
        tfnewTV = false;
      end
      
      if tfnewTV || existingTVvizInit
        % might need to re-vizInit an existing trkVizer eg if number of trx 
        % has changed, maxNanimals has changed, etc.      
        if ~isempty(lObj.trackParams)
          maxNanimals = lObj.trackParams.ROOT.MultiAnimal.Track.max_n_animals;
          maxNanimals = max(ceil(maxNanimals*1.5),10);
        else
          maxNanimals = 20;
        end
        % ntgtmax spec only used by tracklets currently
        tv.vizInit('ntgtmax',maxNanimals);
        tv.setHideViz(obj.hideViz);
      end      
      % eg don't call tv.vizInit() if i) it already existed ii) we are just
      % updating the .trkP.
      
      tv.trkInit(obj.trkP);
    end
    function setHideViz(obj,tf)
      if ~isempty(obj.trkVizer)
        obj.trkVizer.setHideViz(tf);
      end
      obj.hideViz = tf;
    end
    function setShowPredsCurrTargetOnly(obj,tf)
      if ~isempty(obj.trkVizer)
        obj.trkVizer.setShowOnlyPrimary(tf);
      end
      obj.showPredsCurrTargetOnly = tf;
    end
    function updateLandmarkColors(obj)
      ptsClrs = obj.lObj.predPointsPlotInfo.Colors;
      ptsClrs = obj.lObj.Set2PointColors(ptsClrs);
      if ~isempty(obj.trkVizer)
        obj.trkVizer.updateLandmarkColors(ptsClrs);      
      end
    end
    % For updating other cosmetics, go ahead and call obj.trkVizer methods
    % directly
  end

  %% Labeler nav
  methods
    function newLabelerFrame(obj)
      lObj = obj.lObj;
      tv = obj.trkVizer;
      if lObj.isinit || ~lObj.hasMovie || isempty(tv)
        return
      end
      tv.newFrame(lObj.currFrame);
    end
    function newLabelerTarget(obj)
      if ~obj.lObj.maIsMA && ~isempty(obj.trkVizer)
        iTgt = obj.lObj.currTarget;
        obj.trkVizer.updatePrimary(iTgt);
      end
    end
    function newLabelerMovie(obj)
%       if ~obj.lObj.maIsMA && obj.lObj.hasTrx
%         % in this case, the number of targets (trx) can vary by movie and
%         % currently .trkVizer (TrackingVisualizerMT) needs to be updated
%         % for the number of targets
%         obj.vizInit(); 
%       end
      if obj.lObj.hasMovie
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end
      obj.vizInit();
    end
  end
  
  %% Labeler listeners
  methods
    function labelerMovieRemoved(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      tfLabeledTrainingRowRemoved = ~isempty(edata.mIdxRmedHadLbls) && ...
                                    edata.mIdxRmedHadLbls>0; % negative indices indicate GT movie(s)
      if tfLabeledTrainingRowRemoved
        warningNoTrace('Labeled row(s) removed from project. Clearing trained tracker and tracking results.');
        obj.initHook();
      else
        % relabel movie indices
        obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
        
        % skip this stuff; current movie can never be removed so preds for
        % current movie should not change
        %obj.trackCurrResUpdate();
        %obj.newLabelerFrame();
      end  
      
      [tf,tpdir] = obj.trainPackExists();
      if tf
        warningNoTrace('Clearing training package image cache.');
        TrnPack.clearims(tpdir);
      end
    end
    
    function labelerMoviesReordered(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
      
      % Assume trackCurrRes does not need update
      
      [tf,tpdir] = obj.trainPackExists();
      if tf
        warningNoTrace('Clearning training package image cache.');
        TrnPack.clearims(tpdir);
      end
    end

    function modelFilesDst = copyModelFiles(obj,newRootDir,debug)
      % Copy the DeepModelChainOnDisk files to newRootDir.  Part of DeepTracker b/c
      % it's the backend that knows how to get the maxIters for all the models, and
      % DeepTracker has easy access to both the DeepModelChainOnDisk and the
      % backend.  -- ALT, 2025-01-07
      if nargin < 3,
        debug = false;
      end
      dmc = obj.trnLastDMC;
      modelFiles = dmc.findModelGlobsLocal();
      modelFiles = cat(1,modelFiles{:});
      modelFiles = unique(modelFiles);
      modelFilesDst = strrep(modelFiles,dmc.rootDir,newRootDir);
      % nothing to do
      if isequal(dmc.rootDir,newRootDir), 
        return
      end
      backend = obj.backend ;
      if backend.isProjectCacheRemote ,
        warningNoTrace('Remote model detected. This will not be migrated.');
        return
      end
      dmc.iterCurr = obj.backend.getMostRecentModel(dmc) ;
      tfsucc = (dmc.iterCurr >= 0) ;
      if ~all(tfsucc),
        for i = find(~tfsucc(:)'),
          warningNoTrace('Failed to update model iteration count for for net type %s.',...
            char(dmc.netType{i}));
        end
      end
      for mndx = 1:numel(modelFiles)
        copyfileensuredir(modelFiles{mndx},modelFilesDst{mndx}); % throws
        if debug,
          fprintf(1,'%s -> %s\n',modelFiles{mndx},modelFilesDst{mndx});
        end
      end
    end  % function
    
    function statusStringFromJobIndex = queryAllJobsStatus(obj, train_or_track)
      % Returns a cell array of status strings, one for each spawned job.
      % Each line is of the form 'Job 12345 is alive' or 'Job 12345 is dead'.
      backend = obj.backend ;
      statusStringFromJobIndex = backend.queryAllJobsStatus(train_or_track) ;
    end  % function    

    function statusStringFromJobIndex = detailedStatusStringFromRegisteredJobIndex(obj, train_or_track)
      % Returns a cell array of *detailed* status strings, one for each spawned job.
      % E.g. in the case of the bsub backend, these are the full output of 'bjobs
      % <jobid>'.
      backend = obj.backend ;
      statusStringFromJobIndex = backend.detailedStatusStringFromRegisteredJobIndex(train_or_track) ;
    end  % function    
    
    function result = getTrackingLogFilesSummary(obj)  % const method
      % Returns a (long) string with a summary of the content of the log files for
      % all the running jobs.
      logFiles = obj.trkSysInfo.getLogFiles() ;
      backend = obj.backend ;
      logFileContents = cellfun(@(fileName)(backend.fileContents(fileName)),logFiles,'uni',0) ;  % cell array of strings
      result = apt.summarizePerViewFiles(logFiles, logFileContents) ;
    end  % function
    
    function result = getTrackingErrorFilesSummary(obj)  % const method
      errFiles = obj.trkSysInfo.getErrFiles();
      backend = obj.backend ;
      errFileContents = cellfun(@(fileName)(backend.fileContents(fileName)),errFiles,'uni',0);
      result = apt.summarizePerViewFiles(errFiles, errFileContents) ;
    end  % function
    
    function result = isAliveFromRegisteredJobIndex(obj, train_or_track)
      backend = obj.backend ;
      result = backend.isAliveFromRegisteredJobIndex(train_or_track) ;
    end  % function
    
    function result = getTrainingLogFilesSummary(obj)  % const method
      % Returns a (long) string with a summary of the content of the log files for
      % all the running jobs.
      logFiles = unique(obj.trnLastDMC.trainLogLnx)' ;
      backend = obj.backend ;
      logFileContents = cellfun(@(fileName)(backend.fileContents(fileName)),logFiles,'uni',0) ;  % cell array of strings
      result = apt.summarizePerViewFiles(logFiles, logFileContents) ;
    end  % function
    
    function result = getTrainingErrorFilesSummary(obj)  % const method
      errFiles = unique(obj.trnLastDMC.errfileLnx)' ;
      backend = obj.backend ;
      errFileContents = cellfun(@(fileName)(backend.fileContents(fileName)),errFiles,'uni',0);
      result = apt.summarizePerViewFiles(errFiles, errFileContents) ;
    end  % function
    
    function trnImgInfo = loadTrainingImages(obj)
      dmcs = obj.trnLastDMC ;
      trnImgInfo = cell(1,dmcs.n);
      necfields = {'idx','ims','locs'};
      warned = false;
      for i=1:dmcs.n,
        f = dmcs.trainImagesNameLnx(i);
        f = f{1};
        if obj.backend.fileExists(f) ,
          infocurr = load(f,'-mat');  % ALTTODO: Make this work for AWS backend
          if ~all(isfield(infocurr,necfields)),
            warningNoTrace('Training image file ''%s'' exists, but not all fields (yet) saved in it.',f);
            continue
          end
          trnImgInfo{i} = infocurr;          
          trnImgInfo{i}.name = dmcs.getNetDescriptor(i);
          trnImgInfo{i}.name = trnImgInfo{i}.name{1};
        else
          ss = sprintf('Training image file ''%s'' does not exist yet.',f);
          warningNoTrace(ss);
          if ~warned
            warndlg(ss);
            warned = true;
          end
        end
      end
    end  % function
    
    function didReceivePollResultsRetrograde(obj, track_or_train)
      obj.lObj.didReceivePollResultsRetrograde(track_or_train) ;
    end

    % function didReceiveTrackingPollResults_(obj)
    %   obj.lObj.didReceiveTrackingPollResults_() ;
    % end
    % 
    % function didReceiveTrainingPollResults_(obj)
    %   obj.lObj.didReceiveTrainingPollResults_() ;
    % end
    
    function result = get.isTrainingSplits(obj)
      result = obj.isTrainingSplits_ ;
    end
    
    function killAndClearRegisteredJobs(obj, train_or_track)
      obj.backend.killAndClearRegisteredJobs(train_or_track) ;
    end    

    function didErrorDuringTrainingOrTrackingRetrograde(obj, train_or_track, pollingResult)
      obj.lObj.pushBusyStatusRetrograde(sprintf('Wrapping up errored %sing bout...', train_or_track)) ;
      oc = onCleanup(@()(obj.lObj.popBusyStatusRetrograde())) ;      
      if strcmp(train_or_track, 'track') ,
        obj.bgTrkMonitor.stop();
        obj.killJobsAndPerformPostTrackingCleanup_(EndCause.error) ;
        obj.lObj.trackingEndedRetrograde(EndCause.error, pollingResult) ;        
      elseif strcmp(train_or_track, 'train') ,
        obj.bgTrnMonitor.stop();
        obj.killJobsAndPerformPostTrainingCleanup_(EndCause.error) ;
        obj.lObj.trainingEndedRetrograde(EndCause.error, pollingResult) ;
      else
        error('Internal error: %s should be ''train'' or ''track''', train_or_track) ;
      end
    end  % function

    function abortTraining(obj)
      obj.bgTrnMonitor.stop() ;
      obj.killJobsAndPerformPostTrainingCleanup_(EndCause.abort) ;
      obj.lObj.trainingEndedRetrograde(EndCause.abort, []) ;
    end  % function

    function abortTracking(obj)
      obj.bgTrkMonitor.stop() ;
      obj.killJobsAndPerformPostTrackingCleanup_(EndCause.abort) ;
      obj.lObj.trackingEndedRetrograde(EndCause.abort, []) ;
    end  % function

    function result = get.lastTrainEndCause(obj)
      result = obj.lastTrainEndCause_ ;
    end

    function result = get.lastTrackEndCause(obj)
      result = obj.lastTrackEndCause_ ;
    end

    function result = get.nFramesToTrack(obj)
      result = obj.nFramesToTrack_ ;
    end
  end  % methods    

  methods
    function updateTrainingMonitorRetrograde(obj)
      % Called by children to generate a notification
      obj.lObj.updateTrainingMonitorRetrograde() ;
    end  % function

    function updateTrackingMonitorRetrograde(obj)
      % Called by children to generate a notification
      obj.lObj.updateTrackingMonitorRetrograde() ;
    end  % function
  end  % methods
  
end  % classdef
