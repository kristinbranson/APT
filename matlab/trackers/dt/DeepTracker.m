classdef DeepTracker < LabelTracker
  
  properties (Dependent)
    algorithmName
    algorithmNamePretty
    sPrm % new-style DT params
  end
  properties (Constant,Hidden)
    SAVEPROPS = {'sPrmAll' 'containerBindPaths' ...
      'trnNetType' 'trnNetMode' 'trnLastDMC' 'movIdx2trkfile' 'hideViz' ...
      'jrcgpuqueue' 'jrcnslots' 'jrcnslotstrack'}; 
    
    pretrained_weights_urls = {...
      'http://download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC.tar.gz'
      'http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz'...
      };
    pretrained_weights_files_pat_lnx = {...
      '%s/pretrained/resnet_v2_fp32_savedmodel_NHWC/1538687283/variables/variables.index'... % fill in deepnetroot
      '%s/pretrained/resnet_v1_50.ckpt'... 
      };
    pretrained_download_script_py = '%s/download_pretrained.py'; % fill in deepnetroot
    
    default_jrcgpuqueue = 'gpu_rtx8000';
    default_jrcnslots_train = 1;
    default_jrcnslots_track = 1;
    
    MDN_OCCLUDED_THRESH = 0.5;
  end
  properties (GetAccess=public,SetAccess=protected) % MOVE THIS TO BE
    jrcgpuqueue = '';
    jrcnslots = 4;
    jrcnslotstrack = 4; % transient
  end
  properties
    dryRunOnly % transient, scalar logical. If true, config files, cmds 
      % are generated for DL, but actual DL train/track are not spawned
    skip_dlgs % MK: Skip save/delete dialogs for testing.
  end
  properties
    containerBindPaths % cellstr of bind paths for sing/docker
      % Will be used if it is nonempty; otherwise an attempt will be made 
      % to autogenerate the required bind/mount paths.
  end
  properties (Dependent)
    condaEnv; % = 'APT'; % name of conda environment
    configFileExt;
    backend
  end
      
    %% train
    
    % - The trained model lives in the fileSys in <cacheDir>/<proj>view%d/trnName.
    % - Right now you can only have one train running at a time.
    
    % chars, currently autogenerated.
    % - When you retrain, you make a new trnName, every time.
    % - In the cacheDir, a subfolder is created .../<trnName>. This
    % subfolder holds the entire state for your trained model.
    % - Within the subfolder, multiple config files may exist:
    %   .../<trnName>/<trnNameJson1>, .../<trnName>/<trnNameJson2>, ...
    %   representing restarts-with-data-augmentation. The current config
    %   file (ie typically the one used in the most recent train) is
    %   identified by .trnNameLbl.
    % - As far as DeepTracker.m is concerned, the only output/artifacts 
    % generated by training are these two identifiers.
    % FUTURE TODO: what happens when user alters cacheDir?
      
  properties % (SetAccess=private)
    trnNetType = DLNetType.mdn; % scalar DLNetType
    trnNetMode = DLNetMode.singleAnimal;
  end
  properties (Dependent)
    trnName
    trnNameLbl
    filesep
  end
  properties
    % Notes on trnLastDMC.
    %
    % This prop represents the "most recently trained model" for this
    % tracker obj. In many/most workflows the APT UI and backend share a
    % local filesystem and this most recent model lives on this local 
    % filesystem.
    %
    % In some cases, training and tracking occurs remotely relative to the 
    % APT frontend. In this case, there are two relevant filesystems: the 
    % local one available to APT, and the remote one available to the 
    % backend. At various points in a training/tracking workflow, trained 
    % models will exist on BOTH filesystems:
    %
    % * At project load, an existing model might be untarred locally, or 
    % there might be no existing model for a new project.
    % * At train time, a new model model is generated remotely.
    % * At retrain-, augmentedtrain-, or track-time, the local model will 
    % first be uploaded to the remote filesys if necessary.
    % * At project save time, remote models will be downloaded locally
    % before tarring into the project.
    %
    % With regards to this issue, our invariant for .trnLastDMC is that 
    %
    %   .trnLastDMC contains the most recently updated model for the 
    %   tracker, with the .reader property correctly indicating the 
    %   filesystem location of that model. This model is the one that
    %   should be used for inference, saved to projects, etc. Let's call it
    %   the "latest model" (for this tracker).
    %
    % * At project load, all .trnLastDMCs will point to the local
    % filesystem/cache.
    % * When a remote fresh train is spawned, .trnLastDMC is immediately 
    % set to the remote location. Even if the train fails or is killed
    % early, whatever is there remotely is still the latest model.
    % * If a remote track is spawned and the latest model is local, it is
    % uploaded first so the track can occur. The moment this upload 
    % completes, the latest model is moved/set to the remote location.
    % * For now we punt on retrains/augmentedtrains. These pose an issue in
    % that depending on the result of the remote train, the latest model
    % may remain local (eg if the remote train fails, maybe). Maybe the 
    % rule is as simple as "the remote model becomes the latest model if 
    % training completes successfully" but I am not sure. Skip it for now.
    % * At project save-time, the latest model (whereever it may be) is
    % tarred into the project. If the latest model is remote, then it is
    % downloaded first. This download does not update the latest model
    % pointer as the user may continue using the remote/latest model for 
    % tracking.
    %
    % So for now, for the AWS backend, the latest model may start locally, 
    % but once a train or track operation occurs, it will be remote from
    % that point onwards. Conceptually a user could switch backends to
    % local and that would allow the movie to "move back down" but we're
    % not going to worry about that for now.
    trnLastDMC % Last DeepModelChainOnDisk, set during training
    trnTblP % transient, unmanaged. Training rows for last retrain
    
    trnSplitLastDMC % [nsplit] Last DMCs, one per split; transient/unmanaged
    
    bgTrnMonitor % BgTrainMonitor obj
    bgTrnMonBGWorkerObj % bgTrainWorkerObj for last/current train
    bgTrnMonitorVizClass % class of trainMonitorViz object to use to monitor training
        
    %% track

    % - Right now you can only have one track running at a time.
    
    trkDockerCPU = false; % transient, scalar logical. If true and using Docker backend, use CPU for tracking
    
    trkGenHeatMaps % transient, scalar logical. If true, include --hmaps opt
      % to generate heatmaps on disk
      
    trkGTtrkTbl % transient, table of gt results
   
    trkSysInfo % [nview] transient, unmanaged. struct array of info used 
    % for current or most recent tracking codegen/system call. currently 
    % only used for debugging, printing logfiles etc.
    
    bgTrkMonitor % BgTrackMonitor obj
    bgTrkMonBGWorkerObj % bgTrackWorkerObj for last/current rack
    bgTrkMonitorVizClass % class of trackMonitorViz object to use to monitor tracking
    
    % trackres: tracking results DB is in filesys
    movIdx2trkfile % map from MovieIndex.id to [ntrkxnview] cellstrs of trkfile fullpaths
  end
  
  properties (SetObservable)
    
    trackerInfo = [];% information about the current tracker being used for tracking
    
  end
  properties (Dependent)
    bgTrnIsRunning
    bgTrkIsRunning 
  end

  properties
    
    % track curr res -- in-mem tracking results for current mov    
    %
    % The raw tracking DB are trkfiles on disk. Trkfiles are single-view,
    % and there may be arbitrarily many trkfiles for a single (mov,view)
    % since users may repeatedly track segments.
    %
    % trkP merges all results for a given movieset into a single TrkFile.
    % TrkFile is prob better named 'Trk'. The design of 'Trk' between
    % serializtaion and runtime is a little unclear. At runtime it may make
    % sense to store tracking results in custom/redundant data structures
    % for performance reasons. TrkFile has some relevant machinery (eg
    % conversion between full/tracklet can be added) and maybe it ends up
    % covering all bases. A separate class may end up making sense. For now
    % we use a TrkFile and see.
    trkP   % scalar TrkFile obj. tracking results for current mov, views merged
    
    %trkPTS % [npt x nfrm x ntgt] timestamp for trkP*    
    %trkAux % [npt x nfrm x ntgt x naux] auxiliary per-pt results eg confidences
    %trkAuxLbl % [naux] labels for 4th dim of trxAux
              % naux given in DLNetType
  end
  properties (Dependent)
    nPts % number of label points     
    nview 
  end
  
  properties
    trkVizer % scalar TrackingVisualizer
    
    % *Tracking results and viz*
    % For optimization, trkVizer is not created until/when there are
    % tracking results (trkP) to display. Various states:
    % - trkP=[], trkVizer=[].
    % - trkP nonempty, trkVizer=[] if DeepTracker is deactivated.
    % - trkP nonempty, trkVizer nonempty.
    % 
    % vizInit() create/initializes trkVizer (or deletes an existing 
    % trkVizer) based on trkP.    
  end
  
  events
    % Thrown when new tracking results are loaded for the current lObj
    % movie
    newTrackingResults 
    
    trainStart
    trainEnd
    trackStart
    trackEnd    
  end
  
  methods
    function v = get.algorithmName(obj)
      v = getAlgorithmNameHook(obj);
    end
    function v = getAlgorithmNameHook(obj)
      v = char(obj.trnNetType);
    end
    function v = get.algorithmNamePretty(obj)
      v = obj.getAlgorithmNamePrettyHook();
    end
    function v = getAlgorithmNamePrettyHook(obj)
      v = ['Deep Convolutional Network - ' obj.trnNetType.displayString];
    end
    function v = getNumStages(obj)  %#ok<MANU> 
      v = 1;
    end
    function v = getNetsUsed(obj)
      v = cellstr(obj.trnNetType);
    end
    function v = get.condaEnv(obj)
      v = obj.lObj.trackDLBackEnd.condaEnv;
    end
    function result = get.backend(obj)
      labeler = obj.lObj ; 
      if ~isempty(labeler) && isa(labeler, 'handle') && isvalid(labeler) ,
        result = labeler.trackDLBackEnd ;
      else
        result = [] ;
      end
    end
    function v = get.configFileExt(obj) %#ok<MANU> 
      v = DeepModelChainOnDisk.configFileExt;
    end
    function v = get.trnName(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = DeepModelChainOnDisk.getCheckSingle(dmc.getModelChainID());
      end
    end
    function v = get.trnNameLbl(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = DeepModelChainOnDisk.getCheckSingle(dmc.getTrainID());
      end
    end
    function v = get.filesep(obj)
      v = obj.lObj.trackDLBackEnd.filesep;
    end
    function v = get.nPts(obj)
      v = obj.lObj.nLabelPoints;
    end
    function v = get.nview(obj)
      v = obj.lObj.nview;
    end
    function v = get.bgTrnIsRunning(obj)
      btm = obj.bgTrnMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
    function v = get.bgTrkIsRunning(obj)
      btm = obj.bgTrkMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
    function setJrcgpuqueue(obj,v)
      obj.jrcgpuqueue = v;
    end
    function setJrcnslots(obj,v)
      obj.jrcnslots = v;
    end
    function setJrcnslotstrack(obj,v)
      obj.jrcnslotstrack = v;
    end
  end
  
  methods
    function obj = DeepTracker(lObj,varargin)
      obj@LabelTracker(lObj);
      obj.setJrcgpuqueue(DeepTracker.default_jrcgpuqueue);
      
      for i=1:2:numel(varargin)
        prop = varargin{i};
        val = varargin{i+1};
        obj.(prop) = val;
      end
      
      % Init .trnNetMode here for SA projs. Maybe a little strange 
      if lObj.projectHasTrx
        % Has to be SA
        obj.trnNetMode = DLNetMode.multiAnimalTDPoseTrx;
      end
        
              
      obj.bgTrnMonitor = [];
      obj.bgTrnMonitorVizClass = 'TrainMonitorViz';
      obj.bgTrkMonitor = [];
      obj.bgTrkMonitorVizClass = 'TrackMonitorViz';

      obj.trkVizer = []; 
      obj.skip_dlgs = false;
    end
    function delete(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function initHook(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      obj.trackResInit();
      obj.trackCurrResInit();
      obj.vizInit();
      obj.updateTrackerInfo();
    end
    function deactivate(obj)
      deactivate@LabelTracker(obj);
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function activate(obj)
      activate@LabelTracker(obj);
      obj.vizInit(false);
    end
  end
  
  %% Params
  methods (Static)
    
    function sPrmAll = massageParamsIfNecStc(net, ~, sPrmAll, varargin)
      % net-specific parameter treatments
      %
      % net: DLNetType
      %
      % Openpose currently requires particular constraints between
      % parameters that are not required for other DL trackers. Current
      % treatment is
      % - lObj.trackParams continues to be "anything", ie user continues
      % to specify whatever they like in Tracking Parameters. (More
      % precisely, there may be constraints amongst parameters at this
      % level, but these constraints are common to all DL trackers.)
      % - When the universal params are to be set on a specific DL
      % tracker, we may mutate them to meet any DLnet-specific
      % constraints.
      % - So in normal "steady" usage, specific DeepTrackers may have
      % parameters that differ (typically v slightly) from the "main"
      % params. This may be noted in the trackerInfoString.
      
      [throwwarnings] = myparse(varargin,...
        'throwwarnings',true...
        );
      
      switch net
        case {DLNetType.openpose}
          dl_steps = sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps;
          save_step = sPrmAll.ROOT.DeepTrack.Saving.save_step;
          display_step = sPrmAll.ROOT.DeepTrack.Saving.display_step;
          
          if dl_steps < display_step
            dl_steps = display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be greater than or equal to the display step. Updating to %d DL steps.',...
                net.displayString,dl_steps);
            end
          end
          
          if mod(dl_steps,display_step)~=0
            dl_steps = ceil(dl_steps/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be an even multiple of the display step. Increasing DL steps to %d.',...
                net.displayString,dl_steps);
            end
          end
          
          if save_step < display_step
            save_step = display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be greater than or equal to display step. Updating the DL save step to %d.',...
                net.displayString,save_step);
            end
          end
          
          if mod(save_step,display_step)~=0
            save_step = ceil(save_step/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be an even multiple of the display step. Increasing the DL save step to %d.',...
                net.displayString,save_step);
            end
          end
          
          sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps = dl_steps;
          sPrmAll.ROOT.DeepTrack.Saving.save_step = save_step;
      
        otherwise
          % none
      end
      
%       sPrmAll.ROOT.MultiAnimal.TargetCrop.AlignUsingTrxTheta = ...
%         netmode.isHeadTail || netmode==DLNetMode.multiAnimalTDPoseTrx;      
    end
    
  end
  methods
    
    % AL 20190415. Note on DeepTrack.Saving.CacheDir
    % Currently nothing never refers to
    % DeepTrackerObj.sPrmAll.Saving.CacheDir. Instead, only lObj.DLCacheDir
    % and DeepTrackerObj.trnLastDMC.rootDir are used. 
    %
    % - (re)train time: DeepTrackerObj uses lObj.DLCacheDir and sets 
    % .trnLastDMC.rootDir to this location.
    % - track time: currently we assert that lObj.DLCacheDir matches the
    % .rootDir of any local DMCs to be used
    
    function [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        didParamsChange(obj,sPrmAll) % obj const
      
      tfDiffEmptiness = xor(isempty(obj.sPrmAll),isempty(sPrmAll));
      tfCommonChanged = tfDiffEmptiness || ~APTParameters.isEqualTrackDLParams(obj.sPrmAll,sPrmAll);
      tfPreProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPreProcParams(obj.sPrmAll,sPrmAll);
      tfPostProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      
      sOldSpecific = obj.sPrm;
      prmField = APTParameters.getParamField(obj.trnNetType);
      sNewSpecific = sPrmAll.ROOT.DeepTrack.(prmField);
      tfSpecificChanged = ~isequaln(sOldSpecific,sNewSpecific);
    end
      
    function sPrmAll = massageParamsIfNec(obj,sPrmAll,varargin) % obj const
      net = obj.trnNetType;
      netmode = obj.trnNetMode;
      sPrmAll = DeepTracker.massageParamsIfNecStc(net,netmode,...
        sPrmAll,varargin{:});
    end
      
    function setAllParams(obj,sPrmAll)
      sPrmAll = obj.massageParamsIfNec(sPrmAll);
      
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        obj.didParamsChange(sPrmAll);
      
      obj.sPrmAll = sPrmAll;
      
      if tfCommonChanged || tfSpecificChanged
        obj.initHook();
      elseif tfPreProcChanged
        % This is likeyly if the tragetcrop size changes in which case 
        % we should only reset the second stage but for now resetting the
        % both the stages -- MK 20220520
        if (obj.lObj.maIsMA && (obj.getNumStages > 1)) ||...
            ~obj.lObj.maIsMA
          obj.initHook();
        end
      end
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        obj.updateTrackerInfo(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
    function sPrmAll = getAllParams(obj)
      sPrmAll = obj.sPrmAll;     
    end
    function tfPostProcChanged = setPostProcParams(obj,sPrmAll)
      tfPostProcChanged = ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      obj.sPrmAll.ROOT.PostProcess = sPrmAll.ROOT.PostProcess;
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        obj.updateTrackerInfo(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
      
    function v = get.sPrm(obj)
      if isempty(obj.sPrmAll),
        v = [];
      else
        prmField = APTParameters.getParamField(obj.trnNetType);
        v = obj.sPrmAll.ROOT.DeepTrack.(prmField);
      end
    end
    function sPrm = getParams(obj)
      sPrm = obj.sPrm;
    end    
    function tc = getTrackerClassAugmented(obj)
      tc = {class(obj) 'trnNetType' obj.trnNetType};
    end
    function s = getSaveToken(obj)
      s = struct();
      props = obj.SAVEPROPS;
      for p=props(:)',p=p{1}; %#ok<FXSET>
        s.(p) = obj.(p);
      end
      if ~isempty(obj.trnLastDMC)
        obj.trnLastDMC = obj.trnLastDMC.copyAndDetach();
      end
    end
    function s = getTrackSaveToken(obj)
      s = obj.getSaveToken();
      s.sPrmAll = APTParameters.all2TrackParams(s.sPrmAll,false);
    end
    function loadSaveToken(obj,s)
      s = DeepTracker.modernizeSaveToken(s);
      
      obj.initHook(); % maybe handled upstream
      flds = fieldnames(s);
      flds = setdiff(flds,'hideViz');
      for f=flds(:)',f=f{1}; %#ok<FXSET>
        obj.(f) = s.(f);
      end
      
      obj.dryRunOnly = false;
      
%      obj.setHideViz(s.hideViz);
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
    function updateDLCache(obj,dlcachedir)
      dmc = obj.trnLastDMC;
      if ~isempty(dmc),
        if ~dmc.isRemote
          dmc.setRootDir(dlcachedir);
        else
          warningNoTrace('Unexpected remote DMC detected for net %s.',...
            obj.trnNetType.displayString);
        end
      end
      % At save-time we should be updating DMCs to local

      % Don't update dmc(ivw).rootDir in this case

      % Nonfatal dont return
    end

  end
  methods (Static)
    function s = modernizeSaveToken(s)
      % 20181215
      if isfield(s,'awsEc2')
        s = rmfield(s,'awsEc2');
      end
      if isfield(s,'backendType')
        s = rmfield(s,'backendType');
      end
      % 20181218
      if ~isfield(s,'containerBindPaths')
        s.containerBindPaths = cell(0,1);
      end 
      
      % 20190214
      % (Comment is basically C+P from CPRLabelTracker)
      % IMPORTANT philisophical note. We update/modernize .sPrmAll here,
      % but any changes should not invalidate previous trained trackers.
      % Parameters may be renamed, new parameters added, etc; but eg any 
      % new parameters added should be added with default values that 
      % effectively would have been previously used.

      assert(isfield(s,'sPrmAll') && ~isfield(s,'sPrm')); % taken care of in Labeler/lblModernize
            
      if ~isempty(s.sPrmAll)
        s.sPrmAll = APTParameters.modernize(s.sPrmAll);
      else
        % AL 20190713 leave s.sPrmAll empty for untrained trackers
        tfTrained = isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC);
        if tfTrained,
          warning('Apparent trained tracker with no parameters, setting trnLastDMC = []');
          s.trnLastDMC = [];
        end
        % assert(~tfTrained,'Apparent trained tracker with no parameters.');
        % s.sPrmAll = sPrmDflt;
        % Let's leave s.sPrmAll empty for now
      end
      
      % 20190405 
      % .trnName, .trnNameLbl removed as they dup .trnLastDMC
      if isfield(s,'trnName')
        s = rmfield(s,'trnName');
      end
      if isfield(s,'trnNameLbl')
        s = rmfield(s,'trnNameLbl');
      end

      % update trnLastDMC
      if isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC),
        % KB 20220804
        s.trnLastDMC = DeepModelChainOnDisk.modernize(s.trnLastDMC);
        % Add .reader to any .trnLastDMCs; assume local filesys
        if isempty(s.trnLastDMC.reader),
          s.trnLastDMC.reader = DeepModelChainReaderLocal();
        end
      end

      % 20190415
      % remove .movIdx2trkfile for now, with bundle-save we don't save
      % DeepTracker-stored tracking results
      if isfield(s,'movIdx2trkfile')
        s = rmfield(s,'movIdx2trkfile');
      end
      
      % 20190520: filesep needed for local windows
      if isfield(s,'trnLastDMC'),
        % I don't see how this could happen -- filesep is by default '/'
        if ~isempty(s.trnLastDMC),
          s.trnLastDMC.checkFileSep();
        end
      end
      
      if ~isfield(s,'jrcgpuqueue') || strcmp(s.jrcgpuqueue,'gpu_any') || strcmp(s.jrcgpuqueue,'gpu_tesla')
        s.jrcgpuqueue = DeepTracker.default_jrcgpuqueue;
        warningNoTrace('Updating JRC GPU cluster queue to ''%s''.',...
          s.jrcgpuqueue);
      end
    end
  end
  
  
  %% Train
  methods
    
    function train(obj)  %#ok<MANU> 
      error('Incremental training is currently unsupported for Deep Learning.');
    end
    
    % Training timeline
    %
    % - Call to retrain. this creates a new jobname every time.
    % - config file written to <cacheDir>/<trnID>.json
    % - bg trn monitor started
    % - training spawned
    % - as log/intermediate results are written, loss viz in plot.
    % - you can start tracking at any time with the latest model by calling
    % track().
    % - FUTURE TODO you can't forcibly stop training for now.
    % - FUTURE TODO you can't choose to use a trained model before the last/final
    % - FUTURE TODO clean up old/unwanted trained models.
    % one if say it looked less overtrained or better.
    % - trained models will sit on disk; config file at 
    % <cache>/<trnName>.json, and models at <cache>/.../<trnName>
    
    % For Training, there are two processes
    % 1. The backend train itself. After this is spawned, this currently 
    % cannot be managed/killed from this class. If there is an issue the
    % actual compute needs to be manually killed.
    % 2. Background monitoring of the train. This can be reset with
    % bgTrnReset().
    
    function trnResInit(obj)
      obj.trnLastDMC = [];
      obj.bgTrnReset();
    end

    function bgTrnStart(obj,backEnd,dmc,varargin)
      % fresh start new training monitor 
            
      [trnStartCbk,trnCompleteCbk,trainSplits,trnVizArgs] = myparse(varargin,...
        'trnStartCbk',[],... % function handle with sig cbk(src,evt)
        'trnCompleteCbk',[],... % etc
        'trainSplits',false, ...  % true for splits/xv
        'trnVizArgs',{} ...
        );
      
      if ~isempty(obj.bgTrnMonitor)
        error('Training monitor exists. Call .bgTrnReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrnMonBGWorkerObj));

      if ~isempty(trnStartCbk)
        % none
      else
        trnStartCbk = @(s,e)obj.notify('trainStart');
      end
      nmodels = dmc.n;
      if ~isempty(trnCompleteCbk)
      elseif trainSplits
        % unchecked codepath 20210806
        assert(backEnd.type==DLBackEnd.Bsub);
        trnCompleteCbk = @(s,e) obj.xvStoppedCbk(s,e);
      else
        trnCompleteCbk = @(s,e) obj.trainStoppedCbk(s,e);
      end
      netmode = obj.trnNetMode;
      tf2stg = netmode.isTwoStage;
      if dmc.nstages > 1,
        assert(tf2stg);        
      end
      
      trnMonObj = BgTrainMonitor;
      addlistener(trnMonObj,'bgStart',trnStartCbk);
      addlistener(trnMonObj,'bgEnd',trnCompleteCbk);

      % 20210806 At this point, the first arg to train worker obj (ndmcs)
      % must match numel(dmcs)...
      switch backEnd.type
        case DLBackEnd.Bsub
          if trainSplits
            trnWrkObj = BgTrainSplitWorkerObjBsub(dmc);            
          else
            trnWrkObj = BgTrainWorkerObjBsub(dmc);
          end
        case DLBackEnd.Conda
          trnWrkObj = BgTrainWorkerObjConda(dmc);
        case DLBackEnd.Docker
          trnWrkObj = BgTrainWorkerObjDocker(dmc,backEnd);
        case DLBackEnd.AWS
          trnWrkObj = BgTrainWorkerObjAWS(dmc,backEnd.awsec2);
        otherwise
          assert(false);
      end

      trnVizObj = feval(obj.bgTrnMonitorVizClass,dmc,obj,trnWrkObj,...
        backEnd.type,'trainSplits',trainSplits,trnVizArgs{:});
                
      trnMonObj.prepare(trnVizObj,trnWrkObj);
      trnMonObj.start();
      obj.bgTrnMonitor = trnMonObj;
      obj.bgTrnMonBGWorkerObj = trnWrkObj;
    end
    
    % not called by anything, commenting out
%     function bgTrnRestart(obj,bgTrnMonitorObj)
%       % Mostly for debugging hanging monitors. "Kills" current bg training
%       % monitor and restarts.
%       
%       fprintf(2,'Needs cleanup\n');
%       
%       if isempty(obj.bgTrnMonitor) || isempty(obj.bgTrnMonBGWorkerObj)
%         error('Training monitor does not exist.');
%       end
%       
%       workerObj = obj.bgTrnMonBGWorkerObj;
%       fprintf(1,'Restarting bg train monitor. Monitor cls: %s. Worker cls: %s\n',...
%         class(bgTrnMonitorObj),class(workerObj));
% 
%       workerObj.reset();
%       delete(obj.bgTrnMonitor);
%       obj.bgTrnMonitor = [];
%       obj.bgTrnMonBGWorkerObj = [];
%       
%       obj.bgTrnStart(bgTrnMonitorObj,workerObj); % xxx TODO
%     end

    function bgTrnReset(obj)
      % stop the training monitor
      if ~isempty(obj.bgTrnMonitor)
        delete(obj.bgTrnMonitor);
      end
      obj.bgTrnMonitor = [];      
      if ~isempty(obj.bgTrnMonBGWorkerObj)
        delete(obj.bgTrnMonBGWorkerObj);
      end
      obj.bgTrnMonBGWorkerObj = [];
    end    
    
    function tf = getHasTrained(obj)
      tf = ~isempty(obj.trnLastDMC);
    end
    
    function [tfCanTrain,reason] = canTrain(obj)
      
      tfCanTrain = false;
      reason = '';
      if obj.bgTrnIsRunning
        reason = 'Training is already in progress.';
        return;
      end
      if obj.bgTrkIsRunning,
        reason = 'Tracking is in progress.';
        return;
      end
      
      % For now we do this check here even though the actual parfeval()
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn training monitor.';
        return;
      end

      % AL 20190321 parameters now set at start of retrain
%       if isempty(obj.sPrmAll)
%         reason = 'No tracking parameters have been set.';
%         return;
%       end
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'No cache directory has been set.';
        return;
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        reason = 'Please give your project a name. The project name will be used to identify your trained models on disk.';
        return;
      end
      
      backend = lblObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
      
      if isempty(obj.trnNetType)
        reason = 'Deep net type is empty.';
        return;
      end
      
      % check batch size
      nLbledRows = sum(lblObj.movieFilesAllHaveLbls);
      fprintf(1,'Your project has %d labeled rows.\n',nLbledRows);
      bsizeFcn = @(fld,val)strcmp(fld,'batch_size') && val>nLbledRows;
      % Note: at this time, project-level params are set but NOT
      % tracker-level params
      sPrmLblObj = lblObj.trackGetParams();
      res = structapply(sPrmLblObj.ROOT,bsizeFcn);
      tfbsize = cell2mat(res.values);
      if any(tfbsize)
        reason = sprintf('Your project has fewer labeled targets (%d) than a specified training batch size.',...
          nLbledRows);
        return;
      end
      
      if (obj.trnNetType==DLNetType.openpose || obj.trnNetType==DLNetType.multi_openpose) ...
          && isempty(lblObj.skeletonEdges)
        reason = 'Please define a skeleton to track with OpenPose.';
        return;
      end
      
      tfCanTrain = true;      
    end
    
    % there seems to be overlap between canTrain and pretrain -- why? 
    function preretrain(obj)      
      if obj.bgTrnIsRunning
        error('Training is already in progress.');
      end
      
      if obj.bgTrkIsRunning
        error('Tracking is in progress.');
      end
      
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        error('Please give your project a name. The project name will be used to identify your trained models on disk.');
      end      
      
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n'); 
    end
    
    function retrain(obj,varargin)
      % retrain(obj,...)
      % Main training function
      % Called by Labeler.trackRetrain
      % Checks whether tracking results already exist, and what to do about
      % them. 
      % Sets parameters. 
      % Checks whether to start from previously trained models. 
      % calls trnSpawn to actually do anything.
      % also can call trnSpawnAWS but this is obsolete
      
      [wbObj,dlTrnType,oldVizObj,augOnly] = myparse(varargin,...
        'wbObj',[],...
        'dlTrnType',DLTrainType.New, ...
        'oldVizObj',[], ...
        'augOnly',false ...
        );
     
      obj.preretrain();
      lblObj = obj.lObj;
      trnBackEnd = lblObj.trackDLBackEnd;
      
      if obj.isTrkFiles(),
        if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
          res = questdlg('Tracking results exist for previous deep trackers. When training stops, these will be deleted. Continue training?','Continue training?','Yes','No','Cancel','Yes');
          if ~strcmpi(res,'Yes'),
            return;
          end
        end        
      end
      
      obj.setAllParams(lblObj.trackGetParams());
      if isempty(obj.sPrmAll)
        error('No tracking parameters have been set.');
      end
      
      obj.bgTrnReset();
      if ~isempty(oldVizObj),
        delete(oldVizObj);
      end
      
      modelChain0 = obj.trnName;
      prev_models = [];
      switch dlTrnType
        case DLTrainType.New
          modelChain = datestr(now,'yyyymmddTHHMMSS');
          if ~isempty(modelChain0) && ~augOnly
            assert(~strcmp(modelChain,modelChain0));
            fprintf('Training new model %s.\n',modelChain);
            defaultans = 'Yes';
            if isempty(obj.skip_dlgs) || ~obj.skip_dlgs,
              res = questdlg('Previously trained models exist for current tracking algorithm. Do you want to use the previous model for initialization?','Training Initialization','Yes','No','Cancel',defaultans);
            else
              res = defaultans;
            end
            if strcmp(res,'No')
              prev_models = [];
            elseif strcmp(res,'Yes')
              prev_models = obj.trnLastDMC.trainFinalModelLnx;
            else
              return;
            end
          end
        case {DLTrainType.Restart DLTrainType.RestartAug}
          if isempty(modelChain0)
            error('Model has not been trained.');
          end
          modelChain = modelChain0;
          fprintf('Restarting train on model %s.\n',modelChain);
        otherwise
          assert(false);
      end
      
                  
      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
          obj.trnSpawn(trnBackEnd,dlTrnType,modelChain,...
            'wbObj',wbObj,'prev_models',prev_models,'augOnly',augOnly);
        case DLBackEnd.AWS
          error('Not implemented');
          obj.trnSpawnAWS(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj,'prev_models',prev_models);          
        otherwise
          assert(false);
      end
      
      % Nothing should occur here as failed trnSpawn* will early return      
    end
    
    function trnPrintLogs(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.printLogfiles();      
    end
    
    function trnPrintModelChainDir(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      if ~isempty(trnBgWorkerObj)
        trnBgWorkerObj.dispModelChainDir();
      end
    end
    
    function trnPrintProjDir(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; information is for most recent training session.\n');
      end
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      if ~isempty(trnBgWorkerObj)
        trnBgWorkerObj.dispProjDir();
      end
    end
    
    function trnKill(obj)
      if ~obj.bgTrnIsRunning
        error('Training is not in progress.');
      end
      
      obj.bgTrnMonBGWorkerObj.killProcess();      
    end
    
    % update trackerInfo from trnLastDMC
    function updateTrackerInfo(obj)
      
      % info about algorithm and training
      info = DeepModelChainOnDisk.TrackerInfo(obj.trnLastDMC);
      info.algorithm = obj.algorithmNamePretty;
      info.isTraining = obj.bgTrnIsRunning;      
      obj.trackerInfo = info;
    end
    
    % set select properties of trackerInfo 
    function setTrackerInfo(obj,varargin)
      
      [iterCurr] = myparse(varargin,'iterCurr',[]);
      ischange = false;
      
      trackerInfo = obj.trackerInfo; %#ok<PROPLC>
      if ~isempty(iterCurr),
        ischange = ischange || ~isequaln(iterCurr,trackerInfo.iterCurr); %#ok<PROPLC>
        trackerInfo.iterCurr = iterCurr; %#ok<PROPLC>
      end
      if ischange,
        obj.trackerInfo = trackerInfo; %#ok<PROPLC>
      end
      
    end
    
    % return a cell array of strings with information about current tracker
    function [infos] = getTrackerInfoString(obj,doupdate)
      % For OpenPose, consider adding blurb about massaged params
      
      if nargin < 2,
        doupdate = false;
      end
      if doupdate,
        obj.updateTrackerInfo();
      end
      infos = {};
      infos{end+1} = obj.trackerInfo.algorithm;
      if obj.trackerInfo.isTrainStarted,
        isNewLabels = any(obj.trackerInfo.trainStartTS < obj.lObj.lastLabelChangeTS);

        s = '';
        for i = 1:numel(obj.trackerInfo.trainStartTS),
          s = [s,datestr(obj.trackerInfo.trainStartTS(i)),', ']; %#ok<AGROW> 
        end
        if ~isempty(s), s = s(1:end-2); end
        infos{end+1} = sprintf('Train start: %s',s);
        s = DeepTracker.printIter(obj.trackerInfo.iterCurr,obj.trackerInfo.iterFinal);
        infos{end+1} = sprintf('N. iterations: %s',s);
        if isempty(obj.trackerInfo.nLabels),
          nlabelstr = '?';
        elseif numel(obj.trackerInfo.nLabels) == 1,
          nlabelstr = num2str(obj.trackerInfo.nLabels);
        else
          nlabelstr = mat2str(obj.trackerInfo.nLabels);
        end          
        infos{end+1} = sprintf('N. labels: %s',nlabelstr);
        if isNewLabels,
          s = 'Yes';
        else
          s = 'No';
        end
        infos{end+1} = sprintf('New labels since training: %s',s);
        
        sPrmAllLabeler = obj.lObj.trackGetParams();
        sPrmAllAsSet = obj.massageParamsIfNec(sPrmAllLabeler,'throwwarnings',false);
        args = {'netsUsed',obj.getNetsUsed(),'hasTrx',obj.lObj.hasTrx,'trackerIsDL',true};
        
        if isempty(obj.sPrmAll),
          isParamChange = true;
          isParamChangeLbler = true;
        else
          isParamChange = ~APTParameters.isEqualFilteredStructProperties(...
            obj.sPrmAll,sPrmAllAsSet,args{:});
          isParamChangeLbler = ~APTParameters.isEqualFilteredStructProperties(...
            obj.sPrmAll,sPrmAllLabeler,args{:});
        end
        if isParamChange,
          s = 'Yes';
        else
          s = 'No';
        end
        infos{end+1} = sprintf('Parameters changed since training: %s',s);
        
        if isParamChangeLbler
%           if ~isParamChange
%             assert(obj.trnNetType==DLNetType.openpose || obj.trnNetType==DLNetType.leap);
%           end
          infos{end+1} = sprintf('Parameter adjustment: %s',obj.trnNetType.displayString);
        end        
      else
        infos{end+1} = 'No tracker trained.';
      end
      
    end
    
    function props = propList(obj)
      props = obj.trnNetType.timelinePropList;
    end
    
    % I believe this is not working right now/obsolete
%     function [augims,dataAugDir] = dataAug(obj,ppdata,varargin)
%       
%       [sPrmAll,dataAugDir] = myparse(varargin,...
%         'sPrmAll',[],'dataAugDir','' ...
%         );
%       
%       if isempty(sPrmAll),
%         sPrmAll = obj.sPrmAll;
%       end
%       if isempty(sPrmAll)
%         error('Tracking parameters not set.');
%       end
%       sPrmAll = obj.lObj.addExtraParams(sPrmAll,obj.trnNetMode);
%       
%       cacheDir = obj.lObj.DLCacheDir;
%       if isempty(cacheDir)
%         error('No cache directory has been set.');
%       end
%       
%       lblObj = obj.lObj;
% %       projname = lblObj.projname;
% %       if isempty(projname)
% %         error('Please give your project a name. The project name will be used to identify your trained models on disk.');
% %       end
%             
%       trnBackEnd = lblObj.trackDLBackEnd;
%       fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
%       fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
%       fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
%       fprintf(1,'\n');      
% 
%       switch trnBackEnd.type
%         case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
%           [augims,dataAugDir] = obj.dataAugBsubDocker(ppdata,sPrmAll,...
%             trnBackEnd,'dataAugDir',dataAugDir);
%         case DLBackEnd.AWS
%           error('not implemented');
%           %obj.trnSpawnAWS(trnBackEnd,modelChain,'wbObj',wbObj);    
%         otherwise
%           assert(false);
%       end
%     end
    
    % obsolete, not called by anything
%     function dmc = restoreFromCacheDir(obj,cachedir)
%       % EXPERIMENTAL/DEV use at own risk
%       % uses stripped lbl files, which we are disabling 
%       
%       warningNoTrace('Development/experimental codepath!');
%       if ~DeepModelChainOnDisk.gen_strippedlblfile,
%         warningNoTrace('Stripped lbl file is not being generated! This might break');
%       end
%       fprintf(1,'Setting current tracking parameters; these are assumed to be the same as used to train.\n');
%       obj.setAllParams(obj.lObj.trackGetParams());
%       
%       assert(~obj.lObj.isMultiView,'Currently unsupported for multiview projects.');
%       
%       % Stuff from here on might be a DMC mirror meth
%       
%       dmc = DeepModelChainOnDisk(...
%         'rootDir',cachedir,...
%         'projID',obj.lObj.projname,...
%         'netType',char(obj.trnNetType),...
%         'netMode',obj.trnNetMode,...
%         'view',0,...
%         'modelChainID','',...  % tbd
%         'trainID','',... % tbd
%         'trainType',DLTrainType.New,...
%         'iterFinal','',... %tbd
%         'isMultiView',false,...
%         'reader',DeepModelChainReader.createFromBackEnd(obj.lObj.trackDLBackEnd),...
%         'filesep',obj.filesep...
%         );
%       
%       dd = dir(dmc.dirViewLnx);
%       dd = dd(3:end);
%       assert(isscalar(dd),'Multiple model chain IDs found in %s. Cannot restore.',dmc.dirModelChainLnx);
%       dmc.modelChainID = dd.name;
%       
%       dd = dir(fullfile(dmc.dirModelChainLnx,'deepnet-*.index'));
%       tfsucc = dmc.updateCurrInfo();
%       if tfsucc
%         fprintf(1,'Found latest trained model with iteration %d.\n',dmc.iterCurr);
%       else
%         error('Error finding trained model.');
%       end
%       
%       dd = dir(fullfile(dmc.dirProjLnx,'*.lbl'));
%       assert(isscalar(dd),'Could not find a unique stripped lblfile in %s',dmc.rootDir);
%       toks = regexp(dd.name,'(?<mcID>[0-9T]+)_(?<trnID>[0-9T]+).lbl','names');
%       if isempty(toks)
%         error('Could not find a unique stripped lblfile in %s',dmc.rootDir);
%       end
%       if ~strcmp(toks.mcID,dmc.modelChainID)
%         error('ModelChainID mismatch: %s vs %s.',toks.mcID,dmc.modelChainID);
%       end
%       
%       dmc.trainID = toks.trnID;
%       
%       fprintf('Loading stripped lbl %s...\n',dmc.lblStrippedLnx);
%       s = load(dmc.lblStrippedLnx,'-mat');
%       dmc.nLabels = s.nLabels;
%       fprintf('... success, %d labels.\n',s.nLabels);
%       
%       % ok we made it this far; copy the model into the current
%       % DLCacheDir, otherwise APT acts funny, prob due to save machinery
%       % expecting models to live under current cache etc.
%       dmc2 = dmc.copy();
%       dmc2.rootDir = obj.lObj.DLCacheDir;
%       assert(exist(dmc2.dirModelChainLnx,'dir')==0,'Dir %s already exists.',dmc2.dirModelChainLnx);
%       cmd = sprintf('mkdir -p %s',dmc2.dirModelChainLnx);
%       tfsucc = DeepTracker.syscmd(cmd,'dispcmd',true);
%       if ~tfsucc
%         error('Failed to create dir %s.',dmc2.dirModelChainLnx);
%       end
%       fprintf(1,'Copying trained model into current cache...\n');
%       [tfsucc,msg] = copyfile(dmc.dirModelChainLnx,dmc2.dirModelChainLnx);
%       if ~tfsucc
%         error('Failed to copy model: %s.',msg);
%       end
%       [tfsucc,msg] = copyfile(dmc.lblStrippedLnx,dmc2.lblStrippedLnx);
%       if ~tfsucc
%         error('Failed to copy model: %s.',msg);
%       end
%       
%       obj.trnLastDMC = dmc2;
%       obj.trainCleanup();
%     end
    
    function dmcs = trnGetDMCs(obj)
      % Return all DeepModelChainOnDisks for this obj
      % Overloadable meth
      
      dmcs = obj.trnLastDMC;
    end
    
  end
  methods
    %% BSub Trainer
      
    function ntgtstot = genTrnPack(obj,dmc)
      % Generate/write a trnpack; can be used for both stages.
      %
      
      dlConfigLclDir = dmc.dirProjLnx;
      if exist(dlConfigLclDir,'dir')==0
        fprintf('Creating dir: %s\n',dlConfigLclDir);
        [succ,msg] = mkdir(dlConfigLclDir);
        if ~succ
          error('Failed to create dir %s: %s',dlConfigLclDir,msg);
        end
      end
      [~,~,~,ntgtstot] = TrnPack.genWriteTrnPack(obj.lObj,dmc);
    end

    function [jobs,gpuids] = SplitTrackIntoJobs(obj,backEnd,totrackinfo) %#ok<INUSL> 

      [movidx] = totrackinfo.getIntervals();

      nmovies = numel(movidx);
      nviews = numel(totrackinfo.views);
      % default: one movie & view per job
      jobs = cell(nmovies,nviews);
      gpuids = nan(nmovies,nviews);
      for i = 1:nmovies,
        for j = totrackinfo.views,
          jobs{i,j} = {'movie',movidx(i),'view',totrackinfo.views(j)};
        end
      end

      if backEnd.isLocal(),
        % how many gpus do we have available?
        nmax = nmovies*nviews;
        gpuids = backEnd.getFreeGPUs(nmax);
        if numel(gpuids) < 1,
          warning('No GPUs with sufficient RAM available locally');
        elseif numel(gpuids) >= nmax,
          % use default, one movie/view per gpu
        elseif numel(gpuids) >= nmovies,
          gpuids = reshape(gpuids(1:nmovies),[nmovies,1]);
          jobs = cell(nmovies,1);
          for i = 1:nmovies,
            jobs{i} = {'movie',i,'view',totrackinfo.views};
          end
        else % ngpus < nmovies
          ngpus = numel(gpuids);
          movieidx0 = round(linspace(1,nmovies+1,ngpus+1));
          jobs = cell(ngpus,1);
          for i = 1:ngpus,
            jobs{i,1} = {'movie',movieidx0(i):movieidx0(i+1)-1,...
              'view',totrackinfo.views};
          end
          gpuids = reshape(gpuids,[ngpus,1]);
        end
      end


    end

    function [jobidx,view,stage,gpuids] = SplitTrainIntoJobs(obj,backEnd)
      nview = obj.nview; %#ok<PROPLC> 
      nstage = obj.getNumStages();
      [view,stage] = ndgrid(1:nview,1:nstage); %#ok<PROPLC> 
      view = view(:)';
      stage = stage(:)';
      nmodel = nview*nstage; %#ok<PROPLC> 
      if backEnd.isLocal(),
        % how many gpus do we have available?
        gpuids = backEnd.getFreeGPUs(nmodel);
        if numel(gpuids) < nmodel,
          if numel(gpuids)<1,
            gpuids = nan;
            warning('No GPUs with sufficient RAM available locally');
          else
            gpuids = gpuids(1);
            jobidx = ones([1,nmodel]);
          end
        else
          jobidx = 1:nmodel;
        end
      else
        jobidx = 1:nmodel;
        gpuids = nan(1,nmodel);
      end
    end

    function netType = getNetType(obj)
      netType = obj.trnNetType;
    end
    function netMode = getNetMode(obj)
      netMode = obj.trnNetMode;
    end
    function iterFinal = getIterFinal(obj)
      iterFinal = obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps;
    end
    function trainID = configFile2TrainID(obj,dlConfigLcl) %#ok<INUSL> 
      % dlConfigLcl should look like <modelChainID>_<trainID>.<configExt>
      % FIX THIS - this looks like the trainID is parsed out of the
      % config file name...
      [tpdir,dllblf,~] = fileparts(dlConfigLcl); %#ok<ASGLU> 
      pat = sprintf('%s_(?<trainID>[0-9T]+)$',modelChainID);
      toks = regexp(dllblf,pat,'names');
      trainID = toks.trainID;
    end
    function trainID = getTrainID(obj,varargin)
      [existingTrnPackSLbl,tfGenNewConfigFile] = ...
        myparse(varargin,'existingTrnPackSLbl',[],...
        'tfGenNewConfigFile',true);

      if ~isempty(existingTrnPackSLbl)
        trainID = obj.configFile2TrainID(existingTrnPackSLbl);
      elseif tfGenNewConfigFile,
        trainID = datestr(now,'yyyymmddTHHMMSS');
      else
        trainID = obj.trnNameLbl;
      end
    end
    function aptroot = setupBackEndTrain(obj,backEnd,cacheDir)
      switch backEnd.type
        case DLBackEnd.Bsub
          aptroot = backEnd.bsubSetRootUpdateRepo(cacheDir);
        case {DLBackEnd.Conda,DLBackEnd.Docker},
          aptroot = APT.Root;
          obj.downloadPretrainedWeights('aptroot',aptroot);
        case DLBackEnd.AWS,
          aptroot = APT.Root;
          if isempty(backEnd.awsec2)
            error('AWSec2 object not set.');
          end
          backEnd.awsec2.checkInstanceRunning(); % harderrs if instance isn't running
          backEnd.awsUpdateRepo();
      end
    end

    function tfSucc = trnSpawn(obj,backEnd,trnType,modelChainID,varargin)
      %
      % backEnd: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set
      %
      % TODO break up bsub/docker sep meths

      [wbObj,existingTrnPackSLbl,trnStartCbk,trnCompleteCbk,prev_models,...
        augOnly] = ...
        myparse(varargin,...
        'wbObj',[],... 
        'existingTrnPackSLbl',[], ...  % for eg topdown tracking where a trnpack/slbl is pre-generated (and applies to both stages)
        'trnStartCbk',[], ...        
        'trnCompleteCbk',[], ...
        'prev_models',[], ...
        'augOnly',false ...
        );
      
      % (aws check instance running)
      
      cacheDir = obj.lObj.DLCacheDir;
      
      % create/ensure config file; set trainID
      tfGenNewConfigFile = trnType==DLTrainType.New || ...
                            trnType==DLTrainType.RestartAug;

      [jobidx,view,stage,gpuids] = obj.SplitTrainIntoJobs(backEnd);
      netType = obj.getNetType(); % will have one value for each stage
      netMode = obj.getNetMode();
      iterFinal = obj.getIterFinal();
      nmodel = numel(jobidx);

      % determine trainID
      trainID = obj.getTrainID('existingTrnPackSLbl',existingTrnPackSLbl,...
        'tfGenNewConfigFile',tfGenNewConfigFile);

      % Create DMC
      dmc = DeepModelChainOnDisk(...   
        'rootDir',cacheDir,...
        'projID',obj.lObj.projname,...
        'netType',netType(stage),...
        'netMode',netMode(stage),...
        'jobidx',jobidx,...
        'view',view-1,... 
        'stage',stage,...
        'splitIdx',zeros(1,nmodel),...
        'modelChainID',modelChainID,... % will get copied for all models
        'trainID',trainID,... % will get copied for all models
        'trainType',trnType,... % will get copied for all models
        'iterFinal',iterFinal(stage),...
        'reader',DeepModelChainReader.createFromBackEnd(backEnd),...
        'filesep',obj.filesep,...
        'prev_models',prev_models...
        );
      %dmc.resetFollowsObjDet();
      % TODO figure out how to know which jobs prev_models corresponds to
      % for now, assuming they are in the same order

      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      aptroot = obj.setupBackEndTrain(backEnd,cacheDir);
            
%       trnCmdType = trnType;
      
      if ~isempty(existingTrnPackSLbl),
        assert(strcmp(dmc.trainConfigLnx,existingTrnPackSLbl));
        dmc.readNLabels();
        
      elseif tfGenNewConfigFile
        
        ntgtstot = obj.genTrnPack(dmc);
        dmc.setNLabels(ntgtstot);
        
      else % Restart
        % TODO: implement this. We should be using trnpacks now for
        % everything
        error('TODO Restarts not implemented.');
%         assert(all(cellfun(@(x) exist(x,'file')>0,dmc.trainConfigLnx)));
%         
%         dmc.setRestartTS(datestr(now,'yyyymmddTHHMMSS'));
%         % read nLabels from stripped lbl file
%         dmc.readNLabels();
%          
%         % if no training has actually happened, do not restart, just start
%         % anew
%         obj.updateLastDMCsCurrInfo();
%         isPartiallyTrained = obj.trnLastDMC.isPartiallyTrained();
%         if any(~isPartiallyTrained),
%           dmc.setTrnType(DLTrainType.New,find(~isPartiallyTrained));
%         end
        
      end

      % At this point
      % We have (modelChainID,trainID) config file on disk. 

      unique_jobs = unique(jobidx);
      njobs = numel(unique_jobs);
      syscmds = cell(njobs,1);
      cmdfiles = cell(njobs,1);
      logcmds = {};
      % looks like logging may be disabled for docker + win? figure out what
      % should happen here
      if backEnd.type == DLBackEnd.Docker,
        logcmds = cell(njobs,1);
      end

      for ijob = 1:njobs,
        assert(ijob==unique_jobs(ijob));
        dmcjob = dmc.selectSubset('jobidx',ijob);

        basecmd = APTInterf.trainCodeGenBase(dmcjob,'ignore_local',backEnd.ignore_local,'aptroot',aptroot);
        backendArgs = obj.getBackEndArgs(backEnd,gpuids(ijob),dmcjob,aptroot,'train');
        syscmds{ijob} = backEnd.wrapBaseCommand(basecmd,backendArgs{:});
        cmdfiles{ijob} = DeepModelChainOnDisk.getCheckSingle(dmcjob.trainCmdfileLnx());

        if backEnd.type == DLBackEnd.Docker,
          containerName = DeepModelChainOnDisk.getCheckSingle(dmcjob.trainContainerName);
          logfile = DeepModelChainOnDisk.getCheckSingle(dmcjob.trainLogLnx);
          logcmds{ijob} = backEnd.logCommand(containerName,logfile); %#ok<AGROW> 
        end
      end
      
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backEnd,dmc,'trnStartCbk',trnStartCbk,...
          'trnCompleteCbk',trnCompleteCbk);

        % spawn training
        [tfSucc,jobID] = backEnd.run(syscmds,...
          'logcmds',logcmds,...
          'cmdfiles',cmdfiles,...
          'jobdesc','training job');

        if backEnd.type == DLBackEnd.Bsub,
          jobID = cell2mat(jobID);
        end
        obj.bgTrnMonBGWorkerObj.jobID = jobID;
      end
      obj.trnLastDMC = dmc;
    end
    
    % not called by anything
%     function trnImgMatfiles = trainImageParseCmds(obj,syscmds)
%       trnImgMatfiles = cell(0,1);
%       for i=1:numel(syscmds)
%         c = string(syscmds{i});
%         toks = c.split(' ');
%         iAugOut = find(strcmp(toks,'-aug_out'));
%         if isempty(iAugOut)
%           warningNoTrace('View/stage %d: no -aug_out flag',i);
%           continue;
%         end
%         augOut = strip(toks{iAugOut+1},'''');
%         pat = [augOut '*.mat'];
%         dd = dir(pat);
%         if isempty(dd)
%           warningNoTrace('View/stage %d: no matches for training image file pattern: %s',...
%             i,pat);
%         else
%           for j=1:numel(dd)
%             matfile = fullfile(dd(j).folder,dd(j).name);
%             trnImgMatfiles{end+1,1} = matfile; %#ok<AGROW>
%           end
%         end
%       end
%     end
    
    function hfigs = trainImageMontage(obj,trnImgMats,varargin)
      % trnImgMats: cellstr, or could be loaded mats
      
      pppi = obj.lObj.labelPointsPlotInfo;
      mrkrProps = struct2paramscell(pppi.MarkerProps);
      margs0 = {'nr',3,'nc',3,'maskalpha',0.3,...
        'framelblscolor',[1 1 0],...
        'pplotargs',mrkrProps};

      hfigs = myparse(varargin,'hfigs',[]);

      if isempty(hfigs),
        hfigs = nan(1,numel(trnImgMats));
      end

      for i=1:numel(trnImgMats)
        ti = trnImgMats{i};
        if isempty(ti)
          continue;
        end
        
        dam = DataAugMontage();
        dam.init(ti);
        npts = size(dam.locs,2);
        colors = pppi.Colors(1:npts,:); % for eg H/T which has only two pts
        margs = [margs0 {'colors' colors}];
        if numel(hfigs) >= i && hfigs(i) > 0 && ishandle(hfigs(i)) && ~any(hfigs(1:i-1)==hfigs(i)),
          hfig = hfigs(i);
        else
          hfig = [];
        end
        hfigs(i) = dam.show(margs,'hfig',hfig);
      end
    end

    function [tf,tpdir] = trainPackExists(obj)
      dm = obj.trnLastDMC;      
      if ~isempty(dm) 
        [tf,tpdir] = dm(1).trnPackExists();
      else
        tf = false;
        tpdir = [];
      end
    end
    
    function trainPackMontage(obj,varargin)
      
      [maxnpages,plotnr,plotnc,tpdir] = myparse(varargin,...
        'maxnpages',6,...
        'plotnr',3,...
        'plotnc',4, ...
        'tpdir',[] ...
        );
      
      if ~isempty(tpdir)
        tfTrnPackExists = exist(tpdir,'dir')>0;
      else
        [tfTrnPackExists,tpdir] = obj.trainPackExists();     
      end
      
      tfsucc = false;
      if tfTrnPackExists
        try
          [~,~,~,locg] = TrnPack.loadPack(tpdir);
          tfsucc = true; 
        catch ME %#ok<NASGU>
          emsg = 'Could not load training package.';
        end                
      else
        emsg = 'Training package does not exist.';
      end
      
      if ~tfsucc
        errordlg(emsg,'Training package missing');
        return;
      end
      
      nplotpage = plotnr*plotnc;
      nplotmax = maxnpages*nplotpage;      
      ldata = locg.locdata;
      if numel(ldata)>nplotmax
        warningNoTrace('Only showing %d/%d frames available in training package.',...
          nplotmax,numel(ldata));
        ldata = ldata(1:nplotmax);
      end
      
      I = arrayfun(@(x)imread(fullfile(tpdir,x.img{1})),ldata,'uni',0);
      I = cellfun(@DataAugMontage.convertIm2Double,I,'uni',0);
      N = numel(ldata);
      D = size(ldata(1).pabs,1);
      ntgtmax = max([ldata.ntgt]);
      p = nan(N,D,ntgtmax);
      rois = cell(N,1);
      for i=1:N
        ntgt = ldata(i).ntgt;
        p(i,:,1:ntgt) = ldata(i).pabs;
        roi = ldata(i).extra_roi.'; % nroi x 8
        if ~isempty(roi)
          roi = roi(:,[2 3 5 6]); % xlo xhi ylo yhi
          rois{i} = roi;
        else
          rois{i} = nan(0,4);
        end
      end
      lbls = arrayfun(@(x)sprintf('%d.%d',x.imov,x.frm),ldata,'uni',0);
      if mean(I{1}(:))>0.5
        lblscolor = [0 0 0];
      else
        lblscolor = [1 1 1];
      end
      
      pppi = obj.lObj.labelPointsPlotInfo;
      mrkrProps = struct2paramscell(pppi.MarkerProps);
      margs0 = { ... %'framelblscolor',[1 1 0],...
        'pplotargs',mrkrProps,...
        'colors',pppi.Colors};
      roiRectArgs = {'EdgeColor' [0 0 1] 'LineWidth' 2};
    
      tstr = sprintf('Training Data (%d images)',N);
      args = {...
        'rois',rois,'titlestr',tstr,...
        'framelbls',lbls, ...
        'framelblscolor',lblscolor, ...
        'framelblsbgcolor','none',...
        'framelblsIsFullSize',true,...
        'roisRectangleArgs',roiRectArgs};
      args = [args margs0];
      h = Shape.montageTabbed(I,p,plotnr,plotnc,args{:});
      set(h,'Name',tstr);      
    end
       
    % not maintained/obsolete
%     function [augims,dataAugDir] = dataAugBsubDocker(obj,ppdata,...
%         sPrmAll,backEnd,varargin)
%       
%       error('This code is obsolete. Maybe reimplement it some day');
% 
%       [dataAugDir] = myparse(varargin,'dataAugDir','');
%       
%       cacheDir = obj.lObj.DLCacheDir;
% 
%       tfLblFileExists = false;
%       if ~isempty(dataAugDir) && exist(dataAugDir,'dir'),
%         dlLblFileLcl = fullfile(dataAugDir,'dataaug.lbl');
%         if exist(dlLblFileLcl,'file'),
%           tfLblFileExists = true;
%         end
%         [~,ID] = fileparts(dataAugDir);
%       end
%             
%       if tfLblFileExists,
%         s = load(dlLblFileLcl,'-mat','trackParams','trackerData');
%         s.trackParams = sPrmAll;
%         ITRKER_SLBL = 2;
%         s.trackerData{ITRKER_SLBL}.sPrmAll = sPrmAll;
%         fprintf(2,'Using .trackerData{2} for dataaug\n');
%         save(dlLblFileLcl,'-struct','s','-append');
%         fprintf('Reusing cached lbl file %s\n',dlLblFileLcl);
%       else
%         s = obj.trnCreateStrippedLbl('ppdata',ppdata,'sPrmAll',sPrmAll);
%         ID = datestr(now,'yyyymmddTHHMMSS');
%         dataAugDir = fullfile(cacheDir,'DataAug',ID);
%         if ~exist(dataAugDir,'dir'),
%           [succ,emsg] = mkdir(dataAugDir);
%           if ~succ
%             error('Failed to create dir %s: %s',dataAugDir,emsg);
%           end
%         end
%         % Write stripped lblfile to local cache
%         dlLblFileLcl = fullfile(dataAugDir,'dataaug.lbl');
%         save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
%       end
%       
%       errfile = fullfile(dataAugDir,'dataaug.err');
%       outfile = fullfile(dataAugDir,'dataaug');
%       
%       switch backEnd.type
%         case DLBackEnd.Bsub
%           aptroot = backEnd.bsubSetRootUpdateRepo(cacheDir,'copyptw',false);          
%         case DLBackEnd.Docker
%         case DLBackEnd.Conda
%       end
%       
%       switch backEnd.type
%         case {DLBackEnd.Bsub DLBackEnd.Docker}
%           mntPaths = obj.genContainerMountPathBsubDocker(backEnd);
%         case DLBackEnd.Conda
%       end
%       
%       switch backEnd.type
%         case DLBackEnd.Bsub
%           singArgs = {'bindpath',mntPaths};
%           syscmd = DeepTracker.dataAugCodeGenSSHBsubSing(...
%             ID,dlLblFileLcl,cacheDir,errfile,obj.trnNetType,obj.trnNetMode,...
%             outfile,'singArgs',singArgs);
%         case DLBackEnd.Docker
%           dockerargs = {'detach',false};
%           [syscmd] = ...
%             DeepTracker.dataAugCodeGenDocker(backEnd,...
%             ID,dlLblFileLcl,cacheDir,errfile,obj.trnNetType,outfile,...
%             'mntPaths',mntPaths,'dockerargs',dockerargs);
%         case DLBackEnd.Conda
%           error('Not implemented'); % TODO
%         otherwise
%           assert(false);
%       end
%       
%       if backEnd.type==DLBackEnd.Docker,
%         
%         fprintf(1,'%s\n',syscmd);
%         [st,res] = system(syscmd);
%         
%         tfsucc = (st == 0) && ~isempty(regexp(res,'Augmented data saved to','once'));
%         if tfsucc,
%           [tfsucc,augims] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
%           if ~tfsucc,
%             error('Error loading augmented data');
%           end
%         else
%           error('Error creating sample augmented images:\n%s',res);
%         end
%         
%       else
%         
%         fprintf(1,'%s\n',syscmd);
%         [st,res] = system(syscmd);
%         if st==0,
%           PAT = 'Job <(?<jobid>[0-9]+)>';
%           stoks = regexp(res,PAT,'names');
%           if ~isempty(stoks),
%             jobid = str2double(stoks.jobid);
%             
%             cmd =  @() DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
%             nout = 1;
%             maxWaitTime = 60; % seconds
%             [tfsucc,augims] = DeepTracker.waitForBsubComplete(jobid,cmd,nout,maxWaitTime,true);
%             if ~tfsucc,
%               error('Data augmentation did not complete within %d seconds',maxWaitTime);
%             end
%             augims = augims{1};
%           else
%             error('Failed to ascertain jobID.');
%           end
%         else
%           error('Error creating sample augmented images:\n%s',res);
%         end
%       end
%       
%     end
    
    function paths = genContainerMountPathBsubDocker(obj,backend,cmdtype,jobinfo,varargin)
      
      [aptroot,extradirs] = myparse(varargin,...
        'aptroot',[],'extra',{});
      
      assert(backend.type==DLBackEnd.Bsub || backend.type==DLBackEnd.Docker);
      
      if isempty(aptroot)
        switch backend.type
          case DLBackEnd.Bsub
            aptroot = backend.bsubaptroot;
          case DLBackEnd.Docker
            % could add prop to backend for this but 99% of the time for 
            % docker the backend should run the same code as frontend
            aptroot = APT.Root; 
        end
      end
      
      if ~isempty(obj.containerBindPaths)
        assert(iscellstr(obj.containerBindPaths),'containerBindPaths must be a cellstr.');
        fprintf('Using user-specified container bind-paths:\n');
        paths = obj.containerBindPaths;
      elseif backend.jrcsimplebindpaths && backend.type==DLBackEnd.Bsub
        fprintf('Using JRC container bind-paths:\n');
        paths = {'/groups';'/nrs'};
      else
        lObj = obj.lObj;
        
        %macroCell = struct2cell(lObj.projMacrosGetWithAuto());
        %cacheDir = obj.lObj.DLCacheDir;
        cacheDir = APT.getdlcacheroot;
        assert(~isempty(cacheDir));
        
        if isequal(cmdtype,'train'),
          projbps = lObj.movieFilesAllFull(:);
          %mfafgt = lObj.movieFilesAllGTFull;
          if lObj.hasTrx,
            projbps = [projbps;lObj.trxFilesAllFull(:)];
            %tfafgt = lObj.trxFilesAllGTFull;
          end
        else
          projbps = jobinfo.getMovfiles();
          projbps = projbps(:);
          if lObj.hasTrx,
            trxfiles = jobinfo.getTrxfiles();
            trxfiles = trxfiles(~cellfun(@isempty,trxfiles));
            if ~isempty(trxfiles),
              projbps = [projbps;trxfiles(:)];
            end
          end
        end
        
        [projbps2,ischange] = GetLinkSources(projbps);
        projbps(end+1:end+nnz(ischange)) = projbps2(ischange);

      	if backend.type==DLBackEnd.Docker
          % docker writes to ~/.cache. So we need home directory. MK
          % 20220922
          % add in home directory and their ancestors
          homedir = getuserdir;
          homeancestors = [{homedir},getpathancestors(homedir)];
          if isunix
            homeancestors = setdiff(homeancestors,{'/'});
          end
        else
          homeancestors = {};
        end

        fprintf('Using auto-generated container bind-paths:\n');
        %dlroot = [aptroot '/deepnet'];
        % AL 202108: include all of <APT> due to git describe cmd which
        % looks in <APT>/.git
        paths = [cacheDir;aptroot;projbps(:);extradirs(:);homeancestors(:)];
        paths = FSPath.commonbase(paths,1);
        %paths = unique(paths);
      end
      
      cellfun(@(x)fprintf('  %s\n',x),paths);
    end  

    function backEndArgs = getBackEndArgs(obj,backEnd,gpuid,jobinfo,aptroot,cmdtype)

      if isequal(cmdtype,'train'),
        dmc = jobinfo;
        containerName = DeepModelChainOnDisk.getCheckSingle(dmc.trainContainerName);
      else
        dmc = jobinfo.trainDMC;
        containerName = jobinfo.containerName;
      end

      switch backEnd.type
        case DLBackEnd.Bsub
          mntPaths = obj.genContainerMountPathBsubDocker(backEnd,cmdtype,jobinfo);
          if isequal(cmdtype,'train'),
            logfile = DeepModelChainOnDisk.getCheckSingle(dmc.trainLogLnx);
            nslots = obj.jrcnslots;
          else % track
            logfile = jobinfo.logfile;
            nslots = obj.jrcnslotstrack;
          end

          % for printing git status? not sure why this is only in bsub and
          % not others. 
          aptrepo = DeepModelChainOnDisk.getCheckSingle(dmc.aptRepoSnapshotLnx);
          extraprefix = DeepTracker.repoSnapshotCmd(aptroot,aptrepo);
          singimg = obj.singularityImgPath();

          additionalBsubArgs = backEnd.jrcAdditionalBsubArgs ;
          backEndArgs = {...
            'singargs',{'bindpath',mntPaths,'singimg',singimg},...
            'bsubargs',{'gpuqueue' obj.jrcgpuqueue 'nslots' nslots,'logfile',logfile,'jobname',containerName, ...
                        'additionalArgs', additionalBsubArgs},...
            'sshargs',{'extraprefix',extraprefix}...
            };
%           singArgs = {'bindpath',mntPaths};
%           syscmds{ijob} = DeepTracker.trainCodeGenSSHBsubSingDMC(...
%             aptroot,dmcjob,...
%             'singArgs',singArgs,'trnCmdType',trnCmdType,...
%             'bsubargs',{'gpuqueue' obj.jrcgpuqueue 'nslots' obj.jrcnslots},...
%             'isTopDown',nstages>1);
        case DLBackEnd.Docker
          mntPaths = obj.genContainerMountPathBsubDocker(backEnd,cmdtype,jobinfo);
          dockerimg = dmc.dockerImgPath(backEnd);
          isgpu = ~isempty(gpuid) && ~isnan(gpuid);
          % tfRequiresTrnPack is always true;
          shmsize = 8;
          backEndArgs = {...
            'containerName',containerName,...
            'bindpath',mntPaths,...
            'dockerimg',dockerimg,...
            'isgpu',isgpu,...
            'gpuid',gpuid,...
            'shmsize',shmsize...
            };
%           
%           % gpuid = gpuids(ijob);
%             [syscmds{ijob},containerNames{ijob}] = ...
%               DeepTracker.trainCodeGenDockerDMC(dmcjob,backEnd,mntPaths,gpuid,...
%               'isMultiView',DeepModelChainOnDisk.getCheckSingle(dmcjob.getIsMultiView),'trnCmdType',trnCmdType,...
%               'augOnly',augOnly,'augOut',augOut,'isTopDown',nstages>1);
%             logfile = DeepModelChainOnDisk.getCheckSingle(dmcjob.trainLogLnx);
%             logcmds{ijob} = sprintf('%s logs -f %s &> "%s" &',...
%               backEnd.dockercmd,containerNames{ijob},logfile);
          case DLBackEnd.Conda
            backEndArgs = {...
              'condaEnv',obj.condaEnv,...
              'gpuid',gpuid...
              };
%             gpuid = gpuids(ijob);
%             syscmds{ijob} = ...
%               DeepTracker.trainCodeGenCondaDMC(dmcjob,gpuid,...
%               'isMultiView',dmcjob.getIsMultiView(1),'trnCmdType',trnCmdType,...
%               'condaargs',condaargs);
      end

    end
    
    function updateLastDMCsCurrInfo(obj)
      obj.trnLastDMC.updateCurrInfo();
    end
    
  end
  methods (Static)
    function basepaths = hlpAugBasePathsWithWarn(basepaths,newpaths,descstr)
      bps = FSPath.commonbase(newpaths);
      if isempty(bps)
        % no nonempty common base found, ie common base is '/'
        warningNoTrace('No common base path found for %s.',descstr);
      else
        fprintf(1,'Found base path ''%s'' for %s.\n',bps,descstr);
        basepaths{end+1,1} = bps;
      end
    end    
  end
  %% AWS Trainer    
  methods
      
    % not maintained/obsolete
    function trnSpawnAWS(obj,backend,trnType,modelChainID,varargin)
      %
      % backend: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set

      error('TODO: update AWS code');

      [wbObj,prev_models] = myparse(varargin,...
        'wbObj',[],'prev_models',[] ... 
        );
            
      aws = backend.awsec2;
      if isempty(aws)
        error('AWSec2 object not set.');
      end
      aws.checkInstanceRunning(); % harderrs if instance isn't running
      
      backend.awsUpdateRepo();
      
      nvw = obj.lObj.nview;

      % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...        
        'rootDir',backend.RemoteAWSCacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'netMode',obj.trnNetMode,...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',nvw>1,... % currently all multiview projs train serially
        'reader',DeepModelChainReader.createFromBackEnd(backend),...
        'filesep',obj.filesep,...
        'prev_models',prev_models...
        );
      dmcLcl = dmc.copy();
      dmcLcl.rootDir = obj.lObj.DLCacheDir;
      
      warning('Stripped lbl files still used in AWS. Todo: fix this!');

      % create/ensure stripped lbl, local and remote
      tfGenNewStrippedLbl = trnType==DLTrainType.New || ...
                            trnType==DLTrainType.RestartAug;
                          
      if tfGenNewStrippedLbl        
        s = obj.trnCreateStrippedLbl('awsRemote',true,'wbObj',wbObj); 
        % store nLabels in DMC
        dmc.nLabels = s.nLabels;
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        
        % MK 2019018. Creating the cache dir in case it does not exist
        % realized later that cache dir should exist by default.
        % so commenting it out for now, but might be useful.
%         dlCacheDir = fileparts(dlLblFileLclDir);
%         if exist(dlCacheDir,'dir')==0
%           fprintf('Creating local dir: %s\n',dlCacheDir);
%           [succ,msg] = mkdir(dlCacheDir);
%           if ~succ
%             error('Failed to create local dir %s: %s',dlCacheDir,msg);
%           end
%         end
        
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating local dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create local dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file locally: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;

        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing local stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find local stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
        dmcLcl.restartTS = dmc.restartTS;
        % read nLabels from stripped lbl file
        dmcLcl.readNLabels();
        dmc.nLabels = dmcLcl.nLabels;
      end
      dlLblFileRemote = dmc.lblStrippedLnx;
      aws.scpUploadOrVerifyEnsureDir(dlLblFileLcl,dlLblFileRemote,'training file');
      
      % At this point
      % We have (modelChainID,trainID), dlLblFileRemote. remote is ready to 
      % train
      
      % gen DMCs
      for ivw=1:nvw
        if ivw>1
          dmc(ivw) = dmc(1).copy();
        end
        dmc(ivw).view = ivw-1; % 0-based
      end

      % codegen
      % Multiview train is currently serial (no -view flag spec'd)
      % - single logfile
      % - single errfile
      codestr = obj.trainCodeGenAWS(dmc(1)); % all dmcs identical save for view flag
      logfileRemote = dmc(1).trainLogLnx;
      syscmds = { aws.sshCmdGeneralLogged(codestr,logfileRemote) };
            
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backend,dmc);

        % spawn training
        syscmdrun = syscmds{1};
        fprintf(1,'%s\n',syscmdrun);
        system(syscmdrun);
        fprintf('Training job spawned.\n\n');

        % record local cmdfile
        cmdfile = dmcLcl.cmdfileLnx; % currently writes "...viewNan..." since view is not set; this is benign
        %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
        [fh,msg] = fopen(cmdfile,'w');
        if isequal(fh,-1)
          warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
        else
          fprintf(fh,'%s\n',syscmdrun);
          fclose(fh);
          fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
        end
        
        pause(3.0); % Hack try to more reliably get PID -- still not 100% AL 20190130
        aws.getRemotePythonPID(); % Conceptually, bgTrnWorkerObj should
            % remember. Right now there is only one PID per aws so it's ok
        
        obj.trnLastDMC = dmc;
      end
    end
        
    function ppdata = fetchPreProcData(obj,tblP,prmsTgtCrop)
      % Fetch preprocessed data per this tracker. Don't update any cache
      % b/c the preproc params supplied may be "trial"/random.
      % 
      % tblP: MFTable
      % ppPrms: scalar struct, preproc params only.
      % 
      % ppdata: CPRData
            
      %ppdb = obj.lObj.ppdb;
      ppdb = PreProcDB();
      ppdb.init();
      [~,ppdata] = ppdb.add(tblP,obj.lObj,'prmsTgtCrop',prmsTgtCrop,...
        'computeOnly',true);
    end
        
    % we should no longer be making stripped lbl files
    function s = trnCreateStrippedLbl(obj,varargin)
      % 
      % - Mutates .trnTblP
      % - can update .lObj.ppdb
      % - Uploads trxs via AWS (maybe obsolete now)
      % - Can throw
      % This does not actually create a stripped label file, just
      % compresses the info we need for training.
      % TODO We should rename this.
      
      [awsRemote,wbObj,ppdata,sPrmAll] = myparse(varargin,...
        'awsRemote',false,...
        'wbObj',[],...
        'ppdata',[],...
        'sPrmAll',[]...
        );
      
      [tfsucc,tblPTrn,s] = obj.lObj.trackCreateDeepTrackerStrippedLbl(...
         'wbObj',wbObj,'ppdata',ppdata,'sPrmAll',sPrmAll);
      if ~tfsucc
        error('Failed to create DL stripped lbl file.');
      end
      if isempty(ppdata),
        obj.trnTblP = tblPTrn;
      end
      
%       ITRKER_SLBL = 2;
%       assert(s.trackerData{ITRKER_SLBL}.trnNetType==obj.trnNetType);
      
      % for images, deepnet will use preProcData; trx files however need
      % to be uploaded
            
%       if awsRemote 
%         % 1. The moviefiles in s should be not be used; deepnet should be
%         % reading images directly from .preProcData_I. Fill s.movieFilesAll
%         % with jibber as an assert.
%         % 2. The trxfiles in s refer to local files; for AWS training we
%         % will need them to refer to remote locs.
%         %   a. For each trxfile that appears in the training data, we
%         %      upload it and replace all appropriate rows of s.trxFilesAll.
%         %   b. For all other rows of s.trxFilesAll, we replace with jibber
%         %      as an assert.
% 
%         % Originally we uploaded trxfiles but this is no longer nec since
%         % training relies on the cache which is now pre-rotated etc etc
%         
%         s.movieFilesAll(:) = {'__UNUSED__'};
%         if obj.lObj.hasTrx
%           s.trxFilesAll(:) = {'__UNUSED__'};
%         end
%       end
    end
    
%     function trnCompleteCbkAWS(obj,res)      
%       bgWorker = obj.bgTrnMonBGWorkerObj;
%       % use the aws from here, guess .lObj.trackDLBackEnd could have changed? Hmmmmm
%       aws = bgWorker.awsEc2; 
%       
%       obj.updateLastDMCsCurrInfo();
%       
%       dmc = obj.trnLastDMC;
%        
%         % download trkfiles 
%         sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
%         for ivw=1:numel(res)
%           trkLcl = trkfilesLocal{ivw};
%           trkRmt = res(ivw).trkfile;
%           aws.scpDownload(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs);
%         end
%     end
    
  end
  
  %% Splits
  methods (Static)
    function j = tblSplt2Json(tblSplit,isplit)
      % tblSplit: [nlbledrows x 4] table. cols are MFT and 'split'.
      %  tblSplit.split should be a 1-based (positive) int
      
      tfTst = tblSplit.split == isplit;
      tblTrn = tblSplit(~tfTst,MFTable.FLDSID);
      tblTst = tblSplit(tfTst,MFTable.FLDSID);
      j = jsonencode({tblTrn{:,:} tblTst{:,:}});
    end
  end
  methods 
    function trainsplit(obj,tblSplit,varargin)
      % tblSplit: 
      %   SA: [nlbledrows x 4] table. cols are MFT and .split
      %   MA: [nlbledrows x 3] table. cols are MF and .split
      %   In either case, .split should be a 1-based (positive) int
      %  
      % Any labeled rows not in tblSplit get added to tstfold 1 I guess.
      %
      % In future, can support more general splits as the splits need not
      % perfectly partition tLbl.

      error('TODO: fix trainsplit code');

      [wbObj] = myparse(varargin,...
        'wbObj',[] ...
        );
                 
      lblObj = obj.lObj;
      assert(obj.lObj.nview==1,'Currently only supported for single-view.');

      if obj.lObj.gtIsGTMode
        error('Unsupported in GT mode.');
      end

      obj.preretrain();
      
      obj.setAllParams(lblObj.trackGetParams());
      
      if isempty(obj.sPrmAll)
        error('No tracking parameters have been set.');
      end      
           
      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      
      trnType = DLTrainType.New;
      netObj = obj.trnNetType;
      netMode = obj.trnNetMode;
      
      % TODO: prev models
      cacheDir = lblObj.DLCacheDir;
      projname = lblObj.projname;
      trnBackEnd = lblObj.trackDLBackEnd;

      % Base DMC, to be further copied/specified per-split
      dmc = DeepModelChainOnDisk(...
        'rootDir',cacheDir,...
        'projID',projname,...
        'netType',char(netObj),...
        'netMode',netMode,...
        'view',0,...  % 0b
        'modelChainID','',... % to be filled in
        'trainID','',... % to be filled in
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',false,...
        'reader',DeepModelChainReader.createFromBackEnd(trnBackEnd),...
        'filesep',obj.filesep,...
        'doSplit',true ...
        );

      nowstr = datestr(now,'yyyymmddTHHMMSS');
      dmc.modelChainID = DeepModelChainOnDisk.modelChainIDForSplit(nowstr,1);
      dmc.trainID = nowstr;      
      
      dlConfigLclDir = dmc.dirProjLnx;
      if exist(dlConfigLclDir,'dir')==0
        fprintf('Creating dir: %s\n',dlConfigLclDir);
        [succ,msg] = mkdir(dlConfigLclDir);
        if ~succ
          error('Failed to create dir %s: %s',dlConfigLclDir,msg);
        end
      end
      
      % write slbl/trnpack
      tfRequiresTrnPack = netObj.requiresTrnPack(netMode);
      assert(tfRequiresTrnPack); % 202111

      [slbl,tp,locg,ntgtstot] = TrnPack.genWriteTrnPack(obj.lObj,dmc,...
        'tblsplit',tblSplit ...
        );
      % TODO: SA tblSplit will have tgts
      dmc.nLabels = ntgtstot;
      
      
      %         tLbl = []; % XXX TODO
      %         % get labeled rows
      %         treatInfPosAsOcc = obj.trnNetType.doesOccPred;
      %         tLbl = obj.lObj.preProcGetMFTableLbled( ...
      %           'treatInfPosAsOcc',treatInfPosAsOcc ...
      %           );
      %         tLbl = tLbl(:,1:3);
      
% %       else
% %         slbl = obj.trnCreateStrippedLbl('wbObj',wbObj);
% %         % store nLabels in dmc
% %         dmc.nLabels = s.nLabels;
% % 
% %         % Write stripped lblfile to local cache
% % 
% %         save(dlLblFileLcl,'-mat','-v7.3','-struct','slbl');
% %         fprintf('Saved stripped lbl file: %s\n',dlLblFileLcl);
% %         
% %         tLbl = table(slbl.preProcData_MD_mov,slbl.preProcData_MD_frm,...
% %               slbl.preProcData_MD_iTgt,'VariableNames',{'mov' 'frm' 'iTgt'});
% %       end

      
      obj.bgTrnReset();      

      % see trnSpawn
      
      nvw = obj.lObj.nview;
      isMultiViewTrain = false;
      nTrainJobs = nvw;
%       if backEnd.type == DLBackEnd.Docker || backEnd.type == DLBackEnd.Conda,
%         % how many gpus do we have available?
%         gpuids = obj.getFreeGPUs(nvw);
%         if numel(gpuids) < nvw,
%           if nvw == 1 || numel(gpuids)<1,
%               error('No GPUs with sufficient RAM available locally');
%           else
%             gpuids = gpuids(1);
%             isMultiViewTrain = true;
%             nTrainJobs = 1;
%           end
%         end
%       end

      switch trnBackEnd.type
        case DLBackEnd.Bsub
          aptroot = trnBackEnd.bsubSetRootUpdateRepo(cacheDir);
        case {DLBackEnd.Conda,DLBackEnd.Docker},
          %assert(false);
          aptroot = APT.Root;
          %obj.downloadPretrainedWeights('aptroot',aptroot); 
      end
            
      trnCmdType = trnType;
 
      % LOOP STUFF

      %dmc.nLabels = slbl.nLabels;
            
      % At this point
      % We have (modelChainID,trainID). stripped lbl is on disk. 

      syscmds = cell(nvw,1);
      %switch trnBackEnd.type
      %  case DLBackEnd.Bsub
          
      %  case DLBackEnd.Docker 
      %    fprintf(2,'UNCMT JRC\n');
          %assert(false);
          %mntPaths = obj.genContainerMountPath();          
      %end
      
      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Docker}
          mntPaths = obj.genContainerMountPathBsubDocker(trnBackEnd);
          singArgs = {'bindpath',mntPaths};
          % splits verified in TrnPack.genWriteTrnPack
          nsplits = max(tblSplit.split);
          for isplit=1:nsplits
            if isplit>1
              dmc(isplit) = dmc(1).copy();
              dmc(isplit).modelChainID = ...
                DeepModelChainOnDisk.modelChainIDForSplit(nowstr,isplit); 
              dmc(isplit).trnConfigNameOverride = dmc(1).trnConfigName;
            end
            dmcI = dmc(isplit);
            dmcI.splitIdx = isplit;
            dmcI.nLabels = nnz(tblSplit.split~=isplit);
            
            % "Inner"/cmdfile codegen
            xvcode = dmcI.cmdfileLnx;
            xvres = dmcI.valresultsBaseLnx;
%             CONFPARAMSEXTRA = {'dl_steps' '500'};
%             fprintf(2,'Extra confparams\n');
            APTInterf.splitTrainValCodeGenCmdfile(xvcode,xvres,...
              dmcI.modelChainID,...
              dmcI.trnConfigLnx,dmcI.rootDir,dmcI.errfileLnx,...
              DLNetType.(dmcI.netType),dmcI.netMode,isplit,...
              ... %'confparamsextra',CONFPARAMSEXTRA,...
              'view',1,'trainType',DLTrainType.New,...
              'deepnetroot',[aptroot '/deepnet']);
            fprintf(1,'Split %d: wrote cmdfile %s.\n',isplit,xvcode);
            [succ,msg,id] = fileattrib(xvcode,'+x','a');
            if ~succ
              warningNoTrace('Failed to change file attributes for cmdfile %s: %s',...
                xvcode,msg);
            end

            % "Outer" codegen
            mntPaths = obj.genContainerMountPathBsubDocker(trnBackEnd);
            singimg = pick_singularity_image(trnBackEnd, netMode) ;
            singargs = {'bindpath',mntPaths, 'singimg', singimg};
            bsubargs = {'gpuqueue' obj.jrcgpuqueue 'nslots' obj.jrcnslots ...
              'outfile' dmcI.trainLogLnx, 'additionalargs', trnBackend.jrcAdditionalBsubArgs};
            sshargs = {};
            codeOuter = dmcI.cmdfileLnx;
            codeOuter = DeepTracker.codeGenSingGeneral(codeOuter,singargs{:});
            codeOuter = DeepTracker.codeGenBsubGeneral(codeOuter,bsubargs{:});
            codeOuter = DeepTracker.codeGenSSHGeneral(codeOuter,sshargs{:})
            syscmds{isplit} = codeOuter;            
          end
%         case DLBackEnd.Docker
%           containerNames = cell(nTrainJobs,1);
%           logcmds = cell(nTrainJobs,1);
%           syscmds = cell(nTrainJobs,1);
%           for ivw=1:nvw,
%             if ivw>1
%               dmc(ivw) = dmc(1).copy();
%             end
%             dmc(ivw).view = ivw-1; % 0-based
%             if ivw <= nTrainJobs,
%             gpuid = gpuids(ivw);
%             [syscmds{ivw},containerNames{ivw}] = ...
%                 DeepTracker.trainCodeGenDockerDMC(dmc(ivw),backEnd,mntPaths,gpuid,...
%                 'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType);
%             logcmds{ivw} = sprintf('%s logs -f %s &> "%s" &',...
%               obj.dockercmd,containerNames{ivw},dmc(ivw).trainLogLnx);
%             end
%           end
%         case DLBackEnd.Conda
%           condaargs = {'condaEnv',obj.condaEnv};
%           for ivw=1:nvw,
%             if ivw>1
%               dmc(ivw) = dmc(1).copy();
%             end
%             dmc(ivw).view = ivw-1; % 0-based
%             if ivw <= nTrainJobs,
%               gpuid = gpuids(ivw);
%               syscmds{ivw} = ...
%                 DeepTracker.trainCodeGenCondaDMC(dmc(ivw),gpuid,...
%                 'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType,...
%                 'condaargs',condaargs);
%             end
%           end
        otherwise
          assert(false);
      end
      
      %be = obj.lObj.trackDLBackEnd;
      
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(trnBackEnd,dmc,'trainSplits',true);
        
        bgTrnWorkerObj = obj.bgTrnMonBGWorkerObj;
        
        % spawn training
        if trnBackEnd.type==DLBackEnd.Docker
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [st,res] = system(syscmds{iview});
            if st==0
              bgTrnWorkerObj.parseJobID(res,iview);
              
              fprintf(1,'%s\n',logcmds{iview});
              [st2,res2] = system(logcmds{iview});
              if st2==0
              else
                fprintf(2,'Failed to spawn logging job for view %d: %s.\n\n',...
                  iview,res2);
              end
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        elseif trnBackEnd.type==DLBackEnd.Conda
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [job,st,res] = parfevalsystem(syscmds{iview});
            if ~st,
              bgTrnWorkerObj.parseJobID(job,iview);
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        else
          nTrainJobs = numel(dmc);
          bgTrnWorkerObj.jobID = nan(1,nTrainJobs);
          assert(nTrainJobs==numel(dmc));
          for iview=1:nTrainJobs
            syscmdrun = syscmds{iview};
            fprintf(1,'%s\n',syscmdrun);
            
%             cmdfile = dmc(iview).cmdfileLnx;
%             %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
%             [fh,msg] = fopen(cmdfile,'w');
%             if isequal(fh,-1)
%               warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
%             else
%               fprintf(fh,'%s\n',syscmdrun);
%               fclose(fh);
%               fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
%             end
            
            if exist(dmc(iview).dirTrkOutLnx,'dir')==0
              [succ,msg] = mkdir(dmc(iview).dirTrkOutLnx);
              if succ
                fprintf(1,'Made dir ''%s''.\n',dmc(iview).dirTrkOutLnx);
              else
                error('Failed to create dir ''%s'': %s',dmc(iview).dirTrkOutLnx,...
                  msg);
              end
            end                
            
            [st,res] = system(syscmdrun);
            if st==0
              PAT = 'Job <(?<jobid>[0-9]+)>';
              stoks = regexp(res,PAT,'names');
              if ~isempty(stoks)
                jobid = str2double(stoks.jobid);
              else
                jobid = nan;
                warningNoTrace('Failed to ascertain jobID.');
              end
              fprintf('Training job (view %d) spawned, jobid=%d.\n\n',...
                iview,jobid);
              % assigning to 'local' workerobj, not the one copied to workers
              bgTrnWorkerObj.jobID(iview) = jobid;
            else
              fprintf('Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end
          end
        end        
        obj.trnSplitLastDMC = dmc;
      end
      
      % Nothing should occur here as failed trnSpawn* will early return
      
    end
  end
  
  %% Track  
  methods (Static)
    function [gpuids,isMultiView,isSerialMultiMov] = ...
        trackGPUAllocate(nmovset,nview,gpuidsall)
      % Decide how to break up a batch tracking job across GPUs
      %
      % We take as given a (conceptual) [nmovset x nview] array of movies 
      % to be tracked. Meanwhile the GPUs available are provided in gpuids.
      %
      % gpuidsall should be ordered in reverse GPU desirability, ie earlier
      % GPUs are used first.
      %
      % gpuids: GPUs to use; shape determined by isMultiView/isSerialMultiMov.
      % isMultiView: true if tracking across views is done serially for each movset
      % isSerialMultiMov: true if tracking across movs is done serially
      %   (assumes nview==1 currently)

      % this can be made much better!

      if isempty(gpuidsall),
        gpuids = [];
        isMultiView = nview > 1;
        isSerialMultiMov = true;
        return;
      end
      nmovs = nmovset*nview;
      ngpuall = numel(gpuidsall);
      if ngpuall>=nmovs
        % track all movs in parallel
        gpuids = gpuidsall(1:nmovs);
        gpuids = reshape(gpuids,[nmovset nview]);
        isMultiView = false;
        isSerialMultiMov = false;
      elseif ngpuall>=nmovset 
        % each movset gets a GPU, serial tracking across views.
        % Note this is theoretical atm as callers probably have nmovset==1
        % when nview>1.
        gpuids = gpuidsall(1:nmovset);
        gpuids = gpuids(:);
        isMultiView = true;
        isSerialMultiMov = false;
      elseif nview==1     
        gpuids = gpuidsall(1);
        isMultiView = false;
        isSerialMultiMov = true;
      elseif ngpuall >= nview,
        % each view gets a gpu
        gpuids = gpuidsall(1:nview);
        isMultiView = false;
        isSerialMultiMov = true;
      else
        % put everything on one gpu
        gpuids = gpuidsall(1);
        isMultiView = true;
        isSerialMultiMov = true;
%         % Shouldn't come up yet 
%         assert(false,'Unsupported tracking modality');
      end
      
      fprintf(1,'Allocating %d*%d movs to track across %d available gpus:\n',...
        nmovset,nview,ngpuall);
      fprintf(1,'... using %d gpus, multiview=%d, serialmov=%d\n',...
        numel(gpuids),isMultiView,isSerialMultiMov);
    end
    
    function tdata = massageTrackerData(tdata,lObj,varargin)
      % massage of trackerData created with getSaveToken();
      % this was part of Labeler.trackCreateDeepTrackerStrippedLbl()
      % moved here so that it could be reused
      % KB 20220517
      
      [sPrmAll,fortracking] = myparse(varargin,'sPrmAll',[],'fortracking',false);
      
      tfTD = isfield(tdata,'stg2');      
      if tfTD
        tdata = [tdata.stg1; tdata.stg2];
      end
      if isfield(tdata,'trnNetMode'),
        netmodes = [tdata.trnNetMode];
        assert(all(tfTD==[netmodes.isTwoStage]));
      end
      
      for i=1:numel(tdata)
        if ~isempty(sPrmAll)
          tdata(i).sPrmAll = sPrmAll;
        end
        if ~fortracking,
          tdata(i).sPrmAll = lObj.addExtraParams(tdata(i).sPrmAll,...
            tdata(i).trnNetMode);
        end
        tdata(i).trnNetTypeString = char(tdata(i).trnNetType);
      end
      
      if tfTD
        tdata = num2cell(tdata(:)');
        
        % stage 1 trackData; move Detect.DeepTrack to top-level
        if isSubField(tdata{1}.sPrmAll,{'ROOT','MultiAnimal','Detect','DeepTrack'}),
          tdata{1}.sPrmAll.ROOT.DeepTrack = ...
            tdata{1}.sPrmAll.ROOT.MultiAnimal.Detect.DeepTrack;
          tdata{1}.sPrmAll.ROOT.MultiAnimal.Detect = rmfield(...
            tdata{1}.sPrmAll.ROOT.MultiAnimal.Detect,'DeepTrack');
        end
      else
       tdata = {[] tdata};
      end
      % remove detect/DeepTrack from stage2
      if isSubField(tdata{2}.sPrmAll,{'ROOT','MultiAnimal','Detect'}),
        tdata{2}.sPrmAll.ROOT.MultiAnimal.Detect = rmfield(...
          tdata{2}.sPrmAll.ROOT.MultiAnimal.Detect,'DeepTrack');
      end
      
    end
    
  end
  methods
    
    % Tracking timeline
    % - Call to track. We are talking a single movie right now.
    % - .trnLastDMC must be set. The current backend behavior is the most 
    % recent model in <cache>/.../trnName will be used
    % - BG track monitor started. This polls the filesys for the output
    % file.
    % - Spawn track shell call.
    % - When tracking is done for a view, movIdx2trkfile is updated.
    % - When tracking is done for all views, we stop the bgMonitor and we
    % are done.

    function checkSetupTrack(obj,totrackinfo,backend)

       if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      if obj.bgTrnIsRunning && obj.lObj.trackDLBackEnd.type==DLBackEnd.AWS
        % second clause is really, "only have 1 GPU avail"
        % AWS, currently we are testing with p2.xlarge and p3.2xlarge which
        % are single-GPU EC2 instances. multi-GPU instances are avail
        % however.
        error('Tracking while training is in progress is currently unsupported on AWS.');
      end
      % check trained tracker
      if isempty(obj.trnName)
        error('No trained tracker found.');
      end

      % nothing to track?
      assert(~isempty(totrackinfo));
      if totrackinfo.isempty(),
        warning('Nothing to track. Should probably catch this earlier.');
        return;
      end

      sPrmLabeler = obj.lObj.trackGetParams();
      sPrmSet = obj.massageParamsIfNec(sPrmLabeler);
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged] = ...
          obj.didParamsChange(sPrmSet);
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged
        warningNoTrace('Deep Learning parameters have changed since your last retrain.');
      end

      obj.setPostProcParams(sPrmSet);
      % Specifically allow/support case where tfPostProcChanged is true
      % to enable turning off/on postproc or trying diff pp algos with a 
      % given trained tracker   
      
      if obj.bgTrnIsRunning,
        assert(obj.lObj.trackDLBackEnd.type~=DLBackEnd.AWS);
        obj.updateLastDMCsCurrInfo();
        iterCurr = obj.trnLastDMC.iterCurr;
        iterCurr(isnan(iterCurr)) = 0;
        if min(iterCurr) == 0,
          % AL updated msg to be palatable for both single and multi-views
          % (in the latter case you may have a tracker for one view but not
          % another)
          warndlg('Training in progress, and in-progress tracker(s) has not been saved yet. Please wait to track.','Tracker not ready','modal'); 
          return;
        end
        res = questdlg(sprintf('Training in progress. Tracking will use in-progress tracker, which has been trained for %s iterations. When training completes, these frames will need to be retracked. Continue?',...
          DeepTracker.printIter(iterCurr,obj.trnLastDMC.iterFinal)),'Use in-progress tracker?','Track','Cancel','Track');
        if strcmpi(res,'Cancel'),
          return;
        end
      end

            % get info about current tracker
      dmc = obj.trnLastDMC;
%       backend = obj.lObj.trackDLBackEnd;
      if backend.type==DLBackEnd.AWS
        setStatusFcn = @(varargin)(obj.lObj.SetStatus(varargin{:}));
        backend.awsPretrack(dmc,setStatusFcn);
      end
      obj.updateTrackerInfo();
      if ~dmc.canTrack(),
        warndlg('Tracker is invalid.','Tracker invalid','modal');
        return;
      end

    end
    
    function track(obj,varargin)

      [totrackinfo,track_type,wbObj,isexternal,backend] = ...
        myparse(varargin,'totrackinfo',[],'track_type','track',...
        'wbObj',[],'isexternal',false,'backend',obj.lObj.trackDLBackEnd);

      obj.checkSetupTrack(totrackinfo,backend);
      
      % figure out if we will need to retrack any frames that were tracked
      % with an old tracker, or if any frames are already tracked
      willload = any(obj.lObj.getMovIdxMovieFilesAllFull(totrackinfo.getMovfiles));
      isCurr = obj.checkTrackingResultsCurrent();
      if willload && ~isCurr,

        if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
          res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Cancel','Delete');
          if strcmpi(res,'Cancel'),
            return;
          end
          if strcmpi(res,'Retrack'),
            tblMFTRetrack = obj.getTrackingResultsTable([],'ftonly',true);
            totrackinfo.addTblMFT(tblMFTRetrack);
          end
        end
        obj.cleanOutOfDateTrackingResults(isCurr);
      end
      if ~isexternal && isCurr, % saving somewhere

        % remove frames that are already tracked
        tblMFTTracked = obj.getTrackingResultsTable([],'ftonly',true,'aliveonly',true);
        if ~isempty(tblMFTTracked),
          if obj.lObj.maIsMA,
            if totrackinfo.tblMFTIsSet,
              assert(all(MFTable.isTgtUnset(totrackinfo.tblMFT)));
            end
            tblMFTTracked = MFTable.unsetTgt(tblMFTTracked);
          end
          totrackinfo.removeTblMFT(tblMFTTracked);
        end
      end

      % nothing to track?
      if totrackinfo.isempty(),
        fprintf('All requested frames have been tracked already.\n');
        return;
      end
      
      % check if we will overwrite any existing trkfiles, prompt user about
      % deleting
      % trkfiles could be empty if not set yet
      trkfiles = totrackinfo.getTrkfiles();
      trkfilesexist = cellfun(@exist,trkfiles);
      if any(trkfilesexist(:)),
        trkfilesdelete = trkfiles(trkfilesexist>0);
        trkfilesdelete = trkfilesdelete(:);
        ndel = numel(trkfilesdelete);
        MAXTRKFILESDEL = 8;
        if ndel <= MAXTRKFILESDEL
          qstr = [{'The following output trk files already exist. Delete them?'};trkfilesdelete];
        else
          qstr = sprintf('The following output trk files (%d total) already exist. Delete them?',ndel);
          qstr = [{qstr}; trkfilesdelete(1:MAXTRKFILESDEL); {'...<snip>...'}];
        end
        res = questdlg(qstr,'Delete existing trk files?','Delete','Cancel','Cancel');
        if strcmpi(res,'Delete'),
          for i = 1:numel(trkfilesdelete),
            delete(trkfilesdelete{i});
          end
        else
          return;
        end
      end

      obj.bgTrkReset();

      % not putting in heatmap arguments, I think they're obsolete
%       tfHeatMap = ~isempty(obj.trkGenHeatMaps) && obj.trkGenHeatMaps;
%       if tfHeatMap
%         hmapArgs = {'hmaps' true};
%       else
%         hmapArgs = {};
%       end
%       hmapArgs = [hmapArgs 'do_linking' do_linking];

      tfSuccess = obj.trkSpawn(totrackinfo,backend,'track_type',track_type);
      if ~tfSuccess
        obj.bgTrkReset();
        return;
      end

    end
    

    function tfSuccess = trackList(obj,varargin)
      [totrackinfo,backend] = ...
        myparse(varargin,'totrackinfo',[],'backend',obj.lObj.trackDLBackEnd);
      obj.checkSetupTrack(totrackinfo,backend);

      % nothing to track?
      if totrackinfo.isempty(),
        fprintf('All requested frames have been tracked already.\n');
        return;
      end

      obj.bgTrkReset();
      tfSuccess = obj.trkSpawnList(totrackinfo,backend);

      if ~tfSuccess
        obj.bgTrkReset();
        return;
      end

    end

    % AL20191220 GT classification
    % track2() is an alternate codepath that is refactored relative to 
    % track(). Over time we may be able to migrate track() over to 
    % track2(). Currently track2 handles trackListFile and trackGT.
    %
    % track2 operates in more stages to hopefully facilitate modularity and
    % extensibility:
    % 1. pre-track, error-checking and preliminaries
    %   1a. updating of remote repos, downloading PTWs, etc
    % 2. marshalling of base trksysinfo structure containing modelfiles,
    % logfiles, etc
    % 3. customization of trksysinfo depending on task
    % 4. task-specific code generation
    % 5. (optional) early-return, dry run
    % 6. backend-specific bg monitor launch
    % 7. backend-specific track process spawn
    
    function track2_pretrack(obj)
      
      %%% Prechecks %%%
      
      if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      
%      be = obj.lObj.trackDLBackEnd;
%       if be.type~=DLBackEnd.Bsub
%         % to be lifted later
%         error('Currently only supported for JRC Cluster backend.');
%       end
      
      if obj.bgTrnIsRunning
        % Could probably support, but training currently does a
        % "rolling-cleanout" and this track could take a while, plus, like
        % why.
        error('Unsupported while training is in progress.');
      end
      
      if isempty(obj.trnName)
        error('No trained tracker found.');
      end
      
      %%% Params %%%

      sPrmLabeler = obj.lObj.trackGetParams();
      sPrmSet = obj.massageParamsIfNec(sPrmLabeler);
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
          obj.didParamsChange(sPrmSet);
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged
        warningNoTrace('Deep Learning parameters have changed since your last retrain.');
        % Keep it simple for now. Note training might be in progress but
        % even if not etc.
      end
      
      obj.setPostProcParams(sPrmSet);
      % Specifically allow/support case where tfPostProcChanged is true
      % to enable turning off/on postproc or trying diff pp algos with a 
      % given trained tracker
      if obj.lObj.isMultiView && ~strcmp(obj.sPrmAll.ROOT.PostProcess.reconcile3dType,'none')
        % GT specific msg!
        msg = 'GT assessments are currently performed in each view independently. No 3D reconciliation will be done.';
        uiwait(msgbox(msg,'3D Reconciliation','modal'));
      end 
      
      be = obj.lObj.trackDLBackEnd;
      cchdir = obj.lObj.DLCacheDir;
      dmc = obj.trnLastDMC;
      setStatusFcn = @(str, is_busy)(obj.lObj.setStatus(str, is_busy)) ;
      be.pretrack(cchdir,dmc,setStatusFcn);

      % why not; done in track()
      obj.updateTrackerInfo();
    end
    
    function trkjobsGT = track2_genBaseTrkInfo(obj,taskKeywords,varargin)
      % taskKeyword: arbitrary string/keyword for log/errfiles etc
 
%       gtResaveStrippedLbl = myparse(varargin,...
%         'gtResaveStrippedLbl',false ... % if true, resave *GT props to stripped lbl
%         );

      nvw = obj.lObj.nview;
      assert(numel(taskKeywords)==nvw);
      warning('This code seems to be out of date, and uses lbl files. Tell Kristin if you get here!');

      %%% DMC %%% 
      
      % Calling this now as it is called later in getTrkFileTrnStr and we
      % are copying the dmcs here
      obj.updateLastDMCsCurrInfo();      
      dmc = obj.trnLastDMC;
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      dmc.setTrkTSstr(nowstr);
      for i=1:nvw,
        dmc.setTrkTaskKeyword(taskKeywords{i},'view',i-1);
      end
      
      lclCacheDir = obj.lObj.DLCacheDir;
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(lclCacheDir);
      dlLblFileLcl = DeepModelChainOnDisk.getCheckSingle(dmcLcl.lblStrippedLnx);
      assert(exist(dlLblFileLcl,'file')>0,...
        'Can''t find config file: %s\n',dlLblFileLcl);
      
      % generate config file for GT cache
      if obj.lObj.maIsMA
        
      else
        [tfsucc,~,slblgt] = obj.lObj.trackCreateDeepTrackerStrippedLbl(...
          'shuffleRows',false);
        if ~tfsucc
          error('Failed to create DL stripped lbl file.');
        end
        flds = fieldnames(slblgt);
        fldsPP = flds(startsWith(flds,'preProcData'));
        sgt = structrestrictflds(slblgt,fldsPP);

        lds = load(dlLblFileLcl,'-mat');
        gtchanged = ~isfield(lds,'gtcache') || ~isequaln(lds.gtcache,sgt);
        if gtchanged
          % Note simply re-creating the entire stripped lbl might alter
          % training data (movies labels etc) which would be highly
          % undesirable.

          fprintf('GT labels have changed since train...\n');

          % back up existing stripped lbl jic
          nowstr = datestr(now,'yyyymmddTHHMMSS');
          lblbak = sprintf('%s_%s.bak',dlLblFileLcl,nowstr);
          [succ,msg] = copyfile(dlLblFileLcl,lblbak);
          if ~succ
            error('Error resaving stripped lbl: %s',msg);
          end
          fprintf('Backed up stripped lbl: %s.\n',dlLblFileLcl);

          %% load and resave.
          lds.gtcache = sgt;
          save(dlLblFileLcl,'-mat','-v7.3','-struct','lds');
          fprintf('Resaved stripped lbl with updated GT state.\n');
        end
      end
%       if gtResaveStrippedLbl
%         % Modify&resave stripped lbl if nec, as GT movies labels etc
%         % may have changed since training. Currently we classify/track GT
%         % using APT_interf -classify_gt which reads GT rows from the
%         % stripped lbl. Alternatively we could just make a listfile etc and
%         % track the "normal" way which would prob be better.
% 
%         lds = load(dlLblFileLcl,'-mat');
%         snew = obj.lObj.projGetSaveStruct('macroreplace',true,...
%                                           'massageCropProps',true,...
%                                           'savepropsonly',true);
%         gtprops = obj.lObj.SAVEPROPS_GTCLASSIFY;
%         somethingGTchanged = ~isequaln(structrestrictflds(lds,gtprops),...
%                                        structrestrictflds(snew,gtprops));        
     
%       end

      %%% Code/PTW %%% 
      
      be = obj.lObj.trackDLBackEnd;
      
      % right now, always create a single TrackJobGT to run serially across
      % views. This is simpler as it works for all backends and the number
      % of GT rows should be manageable.
      trkjobsGT = TrackJobGT(be,dmcLcl,dmc,obj.trnNetType,obj.trnNetMode);

%       aptroot = be.bsubaptroot; % should be set previously during pretrack      
%       %%% Marshall base trksysinfo %%%      
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
%       trksysinfo = struct(...
%         'trkinfotimestamp',repmat({nowstr},size(trnstrs(:))),...
%         'aptroot',repmat({aptroot},size(trnstrs(:))),...
%         'dmcRootDir',{dmc.rootDir}',...
%         'lblStrippedLnx',{dmc.lblStrippedLnx}',...
%         'trkoutdir',{dmc.dirTrkOutLnx}',...
%         'trnstr',trnstrs(:),...
%         'modelfile',modelFiles(:),...
%         'logfile',[],...
%         'errfile',[],...
%         'snapshotfile',[],...
%         'codestr',[]);
%       
%       for ivw=1:nvw
%         trnstr = trksysinfo(ivw).trnstr;
%         trkoutdir = trksysinfo(ivw).trkoutdir;
%         
%         args = {taskKeywords{ivw},trnstr,ivw,nowstr};
%         logfile = fullfile(trkoutdir,sprintf('%s_%s_vw%d_%s.log',args{:}));
%         errfile = fullfile(trkoutdir,sprintf('%s_%s_vw%d_%s.err',args{:}));
%         ssfile  = fullfile(trkoutdir,sprintf('%s_%s_vw%d_%s.aptsnapshot',args{:}));    
%         trksysinfo(ivw).logfile = logfile;
%         trksysinfo(ivw).errfile = errfile;
%         trksysinfo(ivw).snapshotfile = ssfile;
%       end
    end
    
    function track2_codegen_gt(obj,tj)
      % gt-specific trksysinfo massage + codegen
      
      tj.codegen();
%       nvw = obj.lObj.nview;
%       modelChainID = obj.trnName;
%       
%       for ivw=1:nvw
%         
%         trkoutdir = tj(ivw).trkoutdir;
%         gtoutfileBase  = sprintf('gtcls_vw%d_%s',ivw,tj(ivw).trkinfotimestamp);
%         gtoutfile = [trkoutdir '/' [gtoutfileBase '.mat']];
%         partfile = [gtoutfile '.part'];
%         tj(ivw).outfile = gtoutfile;
%         tj(ivw).partfile = partfile;
%         tj(ivw).codestr = DeepTracker.trackCodeGenGTClassifySSHBsubSing(...
%           tj(ivw),modelChainID,obj.trnNetType,ivw,...          
%           'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
%           'sshargs',sshargsuse);
%       end
    end
        
    function trksysinfo = track2_codegen_listfile(obj,trksysinfo,listfiles,outfiles)
      % trackListFile-specific trksysinfo massage + codegen
      
      nvw = obj.lObj.nview;
      assert(isequal(nvw,numel(listfiles),numel(outfiles)));

      modelChainID = obj.trnName;
      
      for ivw=1:nvw
        trksysinfo(ivw).listfile = listfiles{ivw};
        trksysinfo(ivw).outfile = outfiles{ivw};
        trksysinfo(ivw).partfile = ''; % for now
        aptroot = trksysinfo(ivw).aptroot;
        logfile = trksysinfo(ivw).logfile;
        
        baseargs = {'deepnetroot' [aptroot '/deepnet']};
        baseargsaug = [baseargs {'model_file' trksysinfo(ivw).modelfile}];
        bsubargs = {'outfile' logfile};
        sshargs = {};
        listfileroot = fileparts(listfiles{ivw});        
        singBind = obj.genContainerMountPath('aptroot',aptroot,...
          'extra',{listfileroot}); % XXX ood api
        singargs = {'bindpath',singBind};
        repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
        repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,trksysinfo(ivw).snapshotfile);
        prefix = [DLBackEndClass.jrcprefix '; ' repoSScmd];
        sshargsuse = [sshargs {'prefix' prefix}];
        
        trksysinfo(ivw).codestr = DeepTracker.trackCodeGenListFileSSHBsubSing(...
          obj.backend, trksysinfo(ivw),modelChainID,obj.trnNetType,obj.trnNetMode,ivw,...          
          'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
          'sshargs',sshargsuse);
      end
    end
    
    function track2_bgStart(obj,trkjobs,cbkTrkComplete,nfrms2trk)
      % Start track monitor. This stuff mirrors what is done in (and 
      % downstream) of .track()
      
      % nfrms2trk: currently used just so viz knows when "done" is.
      % Something feels off here, bgStart doesn't need to know something
      % like nfrms2trk. This is a viz thing. So maybe bgStart accepts the
      % viz etc. Def not a big deal, so we are making the viz here too.

      assert(isempty(obj.bgTrkMonitor));
      
      sztj = size(trkjobs);
      logfiles = reshape({trkjobs.mntrLogfile},sztj);
      errfiles = reshape({trkjobs.mntrErrfile},sztj);
%       if isMultiView,
%         outfiles = reshape(cat(1,trksysinfo.trkfile),[nMovies,nView]);
%         partfiles = reshape(cat(1,trksysinfo.parttrkfile),[nMovies,nView]);        
%       else
      outfiles = reshape({trkjobs.mntrOutfile},sztj);
      partfiles = reshape({trkjobs.mntrPrtfile},sztj);
      
      nvw = obj.lObj.nview;
      dmc = obj.trnLastDMC; % tj.dmcsrem?
      be = obj.lObj.trackDLBackEnd;
      bgTrkWorkerObj = DeepTracker.createBgTrkWorkerObj(nvw,dmc,be);
            
      %mIdxDummy = MovieIndex(1); % not used for anything
      movsDummy = repmat({'__UNUSED__'},1,nvw);
      bgTrkWorkerObj.initFiles(movsDummy,...
        outfiles(:)',logfiles(:)',errfiles(:)',partfiles(:)',false);  
      % for now always true for track2* codepath
      %bgTrkWorkerObj.setPartfileIsTextStatus(true);

      tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
      if any(tfErrFileErr)
        error('There is an existing error in an error file: ''%s''.',...
          String.cellstr2CommaSepList(errfiles));
      end
      
      bgTrkMonitorObj = BgTrackMonitor;
      
      %nFramesTrack = obj.getNFramesTrack(tMFTConc,mIdx,frm0,frm1,trxids);
      %fprintf('Requested to track %d frames, through interface will track %d frames.\n',size(tMFTConc,1),nFramesTrack)
      
      %trkVizObj = feval(obj.bgTrkMonitorVizClass,nView,obj,bgTrkWorkerObj,backend.type,nFramesTrack);
      %trkVizObj = TrkTrnMonVizCmdline();
      trkVizObj = feval(obj.bgTrkMonitorVizClass,nvw,obj,bgTrkWorkerObj,be.type,nfrms2trk);
      bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,cbkTrkComplete);
      %bgTrkMonitorObj.prepare(bgTrkWorkerObj,@obj.trkCompleteCbk);
      
      addlistener(bgTrkMonitorObj,'bgStart',@(s,e)disp('bgStart') ); % @(s,e)obj.notify('trackStart'));
      addlistener(bgTrkMonitorObj,'bgEnd',@(s,e)disp('bgEnd')); % @(varargin) obj.trackStoppedCbk(varargin{:}));
      
      obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);        
    end
    
    function [tfSuccess,msg] = track2_spawn(obj,tjs)
      % spawns jobs per trksysinfo and sets obj.trksysinfo, unless
      % .dryRunOnly is true.
      
      tfSuccess = true;
      msg = '';
      
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.codestr),tjs);
      else
        % Actually do things
        
        ntj = numel(tjs);
        for itj=1:ntj
          % You might think this should be done in pretrack, but what is
          % done here is TrackJobGT-dependent as it depends on how the task
          % is broken up in to TrackJobGTs. So this location (or any place
          % post TJ-creation seems correct for now).
          tjs(itj).checkCreateDirs();
          

          fprintf(1,'%s\n',tjs(itj).codestr);
          [st,res] = system(tjs(itj).codestr);
          if st==0
            fprintf('Tracking job %d spawned:\n%s\n',itj,res);
          else
            tfSuccess = false;
            msg = sprintf('Failed to spawn tracking job for view %d: %s.\n\n',...
              itj,res);
            % remaining views not even attempted apparently; or, earlier
            % views already spawned but we early-return anyway
            return;
          end
          
          logcmd = tjs(itj).codestrlog;
          if ~isempty(logcmd)
            [st,res] = system(logcmd);
            if st~=0,
              fprintf(2,'Error logging docker job %s: %s\n',...
                tjs(itj).backend.dockerContainerName,res);
              tfSuccess = false;
              return;
            end
          end
        end
        obj.trkSysInfo = tjs;
      end
    end
    
    function [tfSuccess,msg,trksysinfo] = trackListFile(obj,listfiles,outfiles)
      assert(false,'Currently unsupported.');

      listfiles = cellstr(listfiles);
      outfiles = cellstr(outfiles);
      nvw = obj.lObj.nview;
      assert(isequal(nvw,numel(listfiles),numel(outfiles)));
      
      obj.track2_pretrack();
      
      [~,listfileKeywords,~] = cellfun(@myfileparts,listfiles,'uni',0);      
      trksysinfo = obj.track2_genBaseTrkInfo(listfileKeywords);
      
      trksysinfo = obj.track2_codegen_listfile(trksysinfo,listfiles,outfiles);
       
      [tfSuccess,msg] = obj.track2_spawn(trksysinfo);
    end
    
    function [tfSucc,msg,tj] = trackGT(obj)
      % Track all GT frames in proj.
      % Conceptually similar to trackListFile. Conceptually the list is 
      % comprised of all GT-labeled rows but in practice this is handled in
      % the py.

      tfSucc = false;
      msg = '';
      
      [tfCanTrack,msg] = obj.canTrack();
      if ~tfCanTrack
        return;
      end
      
      tblGT = obj.lObj.labelGetMFTableLabeled('useTrain',0);
      if isempty(tblGT)
        msg = 'Project has no GT frames labeled.';
        return;
      end      
        
      obj.bgTrkReset();

      obj.track2_pretrack();
      
      nvw = obj.lObj.nview;
      kw = repmat({'GT'},nvw,1);
      tj = obj.track2_genBaseTrkInfo(kw,'gtResaveStrippedLbl',true);
      
      obj.track2_codegen_gt(tj);
      
      nfrms2trk = height(tblGT); % a little fragile here
      obj.track2_bgStart(tj,@obj.cbkTrackGTComplete,nfrms2trk);
      
      [tfSucc,msg] = obj.track2_spawn(tj);
    end
    
    function gtComplete(obj)      
      gtmatfiles = obj.trkSysInfo.getListOutfiles;
      gtmovs = obj.lObj.movieFilesAllGTFull;
      tblGT = obj.trackGTgtmat2tbl(gtmatfiles,gtmovs);
      obj.trkGTtrkTbl = tblGT;
      obj.lObj.showGTResults('gtResultTbl',tblGT);
    end
        
    function tblGT = trackGTgtmat2tbl(obj,gtmatfiles,gtmovs,varargin)
      
      GTMATLOCFLD = 'locs';
      GTMATOCCFLD = 'occ';
      
      gtmats = cellfun(@(x)load(x,'-mat'),gtmatfiles); %#ok<LOAD>
      cellfun(@(x)fprintf(1,'Loaded gt output mat-file %s.\n',x),gtmatfiles);
      
      assert(numel(gtmats)==obj.nview);
      if numel(gtmats)>1
        assert(isequal(gtmats.list)); % all mft/metadata tables should match
      end


      mft = gtmats(1).list; % should already be 1based from deepnet
      assert(size(mft,2)==3);
      smovs = gtmats(1).movieFiles;
      gtmovs =gtmovs(:,1);
      [~,gt_mov_match] = ismember(smovs,gtmovs);
      new_mov_ndx = gt_mov_match(mft(:,1));
      mIdx = MovieIndex(-new_mov_ndx'); 

      preds = gtmats(1).pred_locs.(GTMATLOCFLD);
      ndim_locs = ndims(preds);
      isma = ndim_locs==4;
      pts_dim=ndim_locs-1;
      % labeled/pred_locs are [nfrmtrk x nphyspt x 2] for single animal.
      % [nfrmtrk x nanimals x npyspt x 2] for ma
      out_sz = size(preds);
      out_sz = num2cell(out_sz(1:ndim_locs-2));
      out_sz{end+1} = [];
      gt_pred = [gtmats.pred_locs];
      ptrk = cat(pts_dim,gt_pred.(GTMATLOCFLD));
      nfrmtrk = size(ptrk,1);
      ptrk = reshape(ptrk,out_sz{:});
      
      tbltrkMFT = table(mIdx,uint32(mft(:,2)),uint32(mft(:,3)),...
        'VariableNames',{'mov' 'frm' 'iTgt'});
      
      sz_occ = size(ptrk);
      sz_occ(end) = sz_occ(end)/2;
      if isfield(gt_pred,GTMATOCCFLD)
        ptrkocc = cat(pts_dim,gt_pred.(GTMATOCCFLD));
        assert(isequal(size(ptrkocc),sz_occ));
      else
        ptrkocc = nan(sz_occ);
      end
      
      tablevars = {ptrk,ptrkocc};
      tablevarnames = {'pTrk' 'pTrkocc'};      
      tblGT = [tbltrkMFT table(tablevars{:},'VariableNames',tablevarnames)];

    end
        
    function [tfCanTrack,reason] = canTrack(obj)
      tfCanTrack = false;
      reason = '';
      
      if obj.bgTrkIsRunning
        if ~obj.bgTrnMonBGWorkerObj.getIsRunning
          obj.bgTrkReset
        else
          reason = 'Tracking is already in progress.';
          return;
        end
      end
      
      % For now we do this check here even though the actual parfeval() 
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn tracking monitor.';
        return;
      end

      % check trained tracker
      if isempty(obj.trnName)
        reason = 'No trained tracker found.';
        return;
      end
      
      if isempty(obj.sPrmAll),
        reason = 'Training parameters not set.';
        return;
      end

      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'Cache directory not set.';
        return;
      end
      
      backend = obj.lObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
            
      dmc = obj.trnLastDMC;
      if ~dmc.isRemote && ~strcmp(dmc.rootDir,cacheDir)
        reason = 'Cache directory has changed since training.';
        return;
      end
      
      dmcLcl = dmc.copy();
      % shouldn't be necessary, given previous line checking that these
      % things are the same??
      %dmcLcl.setRootDir(cacheDir);
      dlConfigLcl = DeepModelChainOnDisk.getCheckSingle(dmcLcl.trainConfigLnx);
      if exist(dlConfigLcl,'file')==0
        reason = sprintf('Cannot find training file: %s\n',dlConfigLcl);
        return;
      end
      
      tfCanTrack = true;      
    end
    
    function tfSuccess = trkSpawn(obj,totrackinfo,backend,varargin)

      tfSuccess = false;
      [track_type] = myparse(varargin,'track_type','track');

      % split up movies, views into jobs
      [jobs,gpuids] = obj.SplitTrackIntoJobs(backend,totrackinfo);
      njobs = numel(jobs);
      if njobs > numel(gpuids) ,
        warning('Not enough GPUs with enough available memory for the tracking jobs.') ;
        return 
      end

      cacheDir = obj.lObj.DLCacheDir;
      aptroot = obj.setupBackEndTrain(backend,cacheDir);

      nowstr = datestr(now,'yyyymmddTHHMMSS');

      syscmds = cell(1,njobs);
      cmdfiles = cell(1,njobs);      
      logcmds = {};

      totrackinfojobs = [];

      totrackinfo.setTrainDMC(obj.trnLastDMC);
      totrackinfo.setTrackid(nowstr);
      totrackinfo.setDefaultFiles();

      for ijob = 1:numel(jobs),
        [imovjob,ivwjob] = ind2sub(size(jobs),ijob);
        id = sprintf('mov%d_vw%d',imovjob,ivwjob);
        totrackinfojob = totrackinfo.selectSubset(jobs{ijob}{:});
        dmcjob = obj.trnLastDMC.selectSubset('view',totrackinfojob.views-1);
        totrackinfojob.setTrainDMC(dmcjob);
        totrackinfojob.setJobid(id);
        totrackinfojob.setDefaultFiles();

        basecmd = APTInterf.trackCodeGenBase(totrackinfojob,'ignore_local',backend.ignore_local,'aptroot',aptroot,'track_type',track_type);
        backendArgs = obj.getBackEndArgs(backend,gpuids(ijob),totrackinfojob,aptroot,'track');
        syscmds{ijob} = backend.wrapBaseCommand(basecmd,backendArgs{:});
        cmdfiles{ijob} = DeepModelChainOnDisk.getCheckSingle(totrackinfojob.cmdfile);

        if backend.type == DLBackEnd.Docker,
          containerName = totrackinfojob.containerName;
          logfile = totrackinfojob.logfile;
          logcmds{ijob} = backend.logCommand(containerName,logfile); %#ok<AGROW> 
        end

        totrackinfojob.prepareFiles();
        obj.trkCreateConfig(totrackinfojob.trackconfigfile);

        if ijob == 1,
          totrackinfojobs = totrackinfojob;
        else
          totrackinfojobs(imovjob,ivwjob) = totrackinfojob; %#ok<AGROW> 
        end
      end

      tfSuccess = obj.setupBGTrack(totrackinfojobs,totrackinfo,syscmds,cmdfiles,logcmds,backend);
      %[logfiles,errfiles,outfiles,partfiles,movfiles] = trksysinfo.getMonitorArtifacts();
    end

    function tfSuccess = setupBGTrack(obj,totrackinfojobs,totrackinfo,syscmds,cmdfiles,logcmds,backend,varargin)
      [track_type] = myparse(varargin,'track_type','movie');

      if obj.dryRunOnly
        fprintf(1,'Dry run, not tracking:\n');
        fprintf('%s\n',syscmds{:});
        return;
      end

      % start track monitor
      assert(isempty(obj.bgTrkMonitor));

      bgTrkWorkerObj = DeepTracker.createBgTrkWorkerObj(obj.lObj.nview,obj.trnLastDMC,backend);
      obj.trkSysInfo = ToTrackInfoSet(totrackinfojobs);
      bgTrkWorkerObj.initFiles(obj.trkSysInfo);

      % KB 20190115: adding trkviz
      nFramesTrack = totrackinfo.getNFramesTrack(obj.lObj);
      nFramesTrackSum = sum(nFramesTrack);
      if totrackinfo.islistjob
        fprintf('Tracking %d frames.\n',nFramesTrackSum);
      else
        fprintf('Tracking %d frames across %d movies.\n',nFramesTrackSum,...
        numel(nFramesTrack));
      end

      trkVizObj = feval(obj.bgTrkMonitorVizClass,totrackinfo.nviews,obj,bgTrkWorkerObj,backend.type,nFramesTrack);
      bgTrkMonitorObj = BgTrackMonitor;
      bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,@obj.trkCompleteCbk,'track_type',track_type);
      addlistener(bgTrkMonitorObj,'bgStart',@(s,e)obj.notify('trackStart'));
      addlistener(bgTrkMonitorObj,'bgEnd',@(varargin) obj.trackStoppedCbk(varargin{:})); 
      obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);

      % run the jobs
      [tfSuccess,jobID] = backend.run(syscmds,...
        'logcmds',logcmds,...
        'cmdfiles',cmdfiles,...
        'jobdesc','tracking job');

      if backend.type == DLBackEnd.Bsub,
        jobID = cell2mat(jobID);
      end
      bgTrkWorkerObj.jobID = jobID;

    end

    function tfSuccess = trkSpawnList(obj,totrackinfo,backend,varargin)
      [isgt] = myparse(varargin,'isgt',false);
      tfSuccess = false;

      cacheDir = obj.lObj.DLCacheDir;
      aptroot = obj.setupBackEndTrain(backend,cacheDir);
      nowstr = datestr(now,'yyyymmddTHHMMSS');

      totrackinfo.setTrainDMC(obj.trnLastDMC);
      totrackinfo.setTrackid(nowstr);
      if isgt
        totrackinfo.setJobid('gt');
      else
        totrackinfo.setJobid('list');
      end        
      totrackinfo.setDefaultFiles();

      totrackinfo.makeListFile(isgt);
      gpuid =nan;

      basecmd = APTInterf.trackCodeGenBase(totrackinfo,'ignore_local',backend.ignore_local,'aptroot',aptroot);
      backendArgs = obj.getBackEndArgs(backend,gpuid,totrackinfo,aptroot,'track');
      syscmds = backend.wrapBaseCommand(basecmd,backendArgs{:});
      cmdfiles = DeepModelChainOnDisk.getCheckSingle(totrackinfo.cmdfile);

      if backend.type == DLBackEnd.Docker
        containerName = totrackinfo.containerName;
        logfile = totrackinfo.logfile;
        logcmds = {backend.logCommand(containerName,logfile)}; 
      else
        logcmds = [];
      end

      totrackinfo.prepareFiles();
      obj.trkCreateConfig(totrackinfo.trackconfigfile);

      tfSuccess = obj.setupBGTrack(totrackinfo,totrackinfo,{syscmds},{cmdfiles},logcmds,backend,'track_type','list');
    end

    function nframes = getNFramesTrack(obj,totrackinfo) %#ok<INUSL>
      % This returns a [nmovsettrk] array, the number of frames to be
      % tracked in each movieset.
      %
      % Note that trksysinfo may either be an [nmovssettrk nviewjobs] 
      % TrackJobs array with one row per movieset to be tracked; or it may 
      % be a scalar TrackJobs object with with tfserialmov=true which
      % represents [nmovsettrk] movies in a single object.

      % could be a single regular TrackJob, or a single TrakcJob with
      % tfserialmov=true
      nframes = totrackinfo.getNFramesTrack();
    end


    function trkPrintTrkOutDir(obj)
%       modelChainID = obj.trnName;
%       if isempty(modelChainID) 
%         error('Training is not complete or in progress.');
%       end
      if ~obj.bgTrkIsRunning
        fprintf('Tracking is not in progress; log is for most recent tracking session.\n');
      end
      bgObj = obj.bgTrkMonBGWorkerObj; % For AWS this can cause trouble because the AWSEC2 instance is 
        % detached
      bgObj.dispTrkOutDir();
    end
    
    function trkCreateConfig(obj,configfile,varargin)
      % trkCreateConfig(obj,'sPrmAll',[])
      % 
      [sPrmAll] = myparse(varargin,'sPrmAll',[]);
      
      s = struct;
      s.projectFile = obj.lObj.projectfile;
      s.projname = obj.lObj.projname;
      %s.cfg = obj.lObj.getCurrentConfig();
      tdata = obj.getTrackSaveToken();
      s.trackerData = DeepTracker.massageTrackerData(tdata,...
        obj.lObj,'sPrmAll',sPrmAll,'fortracking',true);
      slbl = Lbl.compressStrippedLbl(s);
      [jse] = Lbl.jsonifyStrippedLbl(slbl);
      jsonoutf = configfile;
      [fh,msg] = fopen(jsonoutf,'w');
      if fh < 0,
        error('Could not open file %s for writing: %s\n',jsonoutf,msg);
      end
      fprintf(fh,'%s\n',jse);
      fclose(fh);
    end
    
  end
  methods (Static)
    function bgTrkWorkerObj = createBgTrkWorkerObj(nView,~,backend)

      % dmc is not used in BgTrackWorkerObj subclasses!
      dmcDummy = [];%nan(1,nView);
      switch backend.type
        case DLBackEnd.Bsub
          bgTrkWorkerObj = BgTrackWorkerObjBsub(nView,dmcDummy);
        case DLBackEnd.Conda,
          bgTrkWorkerObj = BgTrackWorkerObjConda(nView,dmcDummy);
        case DLBackEnd.Docker,
          bgTrkWorkerObj = BgTrackWorkerObjDocker(nView,dmcDummy,backend);
        case DLBackEnd.AWS,
           bgTrkWorkerObj = BgTrackWorkerObjAWS(nView,dmcDummy,backend.awsec2);
        otherwise
          error('Not implemented back end %s',backend.type);
      end
    end
    function sha = getSHA(file)
      if ismac
        file = strrep(file,' ','\ ');
        shacmd = sprintf('MD5 %s',file);
        [~,res] = DeepTracker.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        res = strtrim(res);
        toks = regexp(res,' ','split');
        sha = toks{end};        
        sha = regexprep(sha,' ','');          
      elseif isunix
        file = strrep(file,' ','\ ');
        shacmd = sprintf('md5sum %s',file);
        [~,res] = DeepTracker.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,' ','split');
        sha = toks{1};        
        sha = regexprep(sha,' ','');
      else
        shacmd = sprintf('certUtil -hashFile "%s" MD5',file);
        [~,res] = DeepTracker.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,'\n','split');
        sha = toks{2};
        sha = regexprep(sha,' ','');
      end
    end
  end
  methods

    function trkPrintLogs(obj)
      btm = obj.bgTrkMonitor;
      if isempty(btm)
        error('Tracking is neither in progress nor complete.');
      end
      btm.bgWorkerObj.printLogfiles();
    end
    
    function bgTrkReset(obj)
      obj.trkSysInfo = [];
      if ~isempty(obj.bgTrkMonitor)
        delete(obj.bgTrkMonitor);
      end
      obj.bgTrkMonitor = [];
      if ~isempty(obj.bgTrkMonBGWorkerObj)
        delete(obj.bgTrkMonBGWorkerObj);
      end
      obj.bgTrkMonBGWorkerObj = [];
    end
    
    function bgTrkStart(obj,trkMonitorObj,trkWorkerObj)
      % fresh start new training monitor 
      % trkMonitorObj: should be 'prepared'
      
      if ~isempty(obj.bgTrkMonitor)
        error('Tracking monitor exists. Call .bgTrkReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrkMonBGWorkerObj));
      
      trkMonitorObj.start();
      obj.bgTrkMonitor = trkMonitorObj;
      obj.bgTrkMonBGWorkerObj = trkWorkerObj;
    end

    function createTrkfilesFromListout(obj)
      njobs = obj.trkSysInfo.n;
      for i = 1:njobs
        curj = obj.trkSysInfo.ttis(i);
        for view = curj.views(:)'
          outfile = curj.listoutfiles{view};
          S = load(outfile);
          movies = curj.getMovfiles('view',view);
          trkfiles = curj.getTrkfiles('view',view);
          nMovies = numel(movies);
          for midx = 1:nMovies
            K = TrkFile;
            K.movfile = movies{midx};
            K.initFromTableFull(S,view,midx);
            K.save(trkfiles{midx});
          end          
        end
      end
    end
    
    function trkCompleteCbk(obj,res)

      try

        %[nMovies,nViews,nStgs] = size(res);
        nMovies = obj.trkSysInfo.nmovies;
        stages = obj.trkSysInfo.stages;
        views = obj.trkSysInfo.views;
        islistjob = obj.trkSysInfo.islistjob;

        if islistjob
          obj.createTrkfilesFromListout();
        end

        for movi = 1:nMovies,
          movfiles = obj.trkSysInfo.getMovfiles('movie',movi,'stage',stages(end));
          % seems to only be using the last stage of tracking
          trkfiles = obj.trkSysInfo.getTrkfiles('movie',movi,'stage',stages(end));
          croproi = obj.trkSysInfo.getCroprois('movie',movi);
          calibrationfile = obj.trkSysInfo.getCalibrationfiles('movie',movi);
          if ~isempty(calibrationfile),
            calibrationfile = calibrationfile{1};
          end
          caldata = obj.trkSysInfo.getCalibrationdata('movie',movi);
          obj.trkPostProcIfNec(movfiles,trkfiles,'caldata',caldata,'calibrationfile',...
            calibrationfile,'cropROIs',cat(1,croproi{:}));
          moviestr = String.cellstr2DelimList(movfiles,', ');

          fprintf('Tracking complete for %s, results saved to:\n',moviestr);
          for vwi = views,
            for stgi = stages,
              fprintf('  View %d, stage %d: %s\n',vwi,stgi,DeepModelChainOnDisk.getCheckSingle(obj.trkSysInfo.getTrkfiles('movie',movi,'view',vwi,'stage',stgi)));
            end
          end
          [tffound,mIdx] = obj.lObj.getMovIdxMovieFilesAllFull(movfiles);
          if tffound,
            obj.trackResAddTrkfile(mIdx,trkfiles);
            if mIdx==obj.lObj.currMovIdx,
              obj.trackCurrResUpdate(); % calls vizInit(false)
              if obj.lObj.maIsMA
                obj.jumpToNearestTracking();
                % Jumping to the firstframe was super annoying!!
                % changing so that we don't MK 20220729
              end
              obj.newLabelerFrame();
            end
          end
        end
      
      catch ME,
        warning('Error gathering tracking results:\n%s',getReport(ME));
        return
      end

      if obj.trkSysInfo.ttis(1).isgtjob
        obj.gtComplete();
      end
      
    end

    function jumpToNearestTracking(obj)
      % Jump to the startframe of the first tracklet and select it. This enables the
      % Tracklet HUD and timeline.
      %
      % bit of a hack here as special-casing and end-running
      % TrackingVisualizerBase api.
      if ~obj.lObj.maIsMA,
        return;
      end
      tv = obj.trkVizer;
      if isempty(tv.ptrx)
        return;
      end
      curfr = obj.lObj.currFrame;
      ss = [tv.ptrx(:).firstframe];
      ee = [tv.ptrx(:).endframe];
      active = find((ss<=curfr)&(ee>=curfr),1);
      if isempty(active)
        % closest tracklet
        [min_ss,sel_ss] = min(abs(curfr-ss));
        [min_ee,sel_ee] = min(abs(curfr-ee));
        if min_ss < min_ee,
          sel = sel_ss;
        else
          sel = sel_ee;
        end
        f0 = tv.ptrx(sel).firstframe;
        if f0~=obj.lObj.currFrame
          obj.lObj.setFrame(f0); % this should result in call to .newLabelerFrame();
        end
      else
        obj.newLabelerFrame(); % not sure what this does... 
        %obj.lObj.setFrame(curfr); % this should result in call to .newLabelerFrame();
        sel = tv.iTrx2iTrxViz(active);
      end

      tv.trxSelected(sel,true); % the first tv.tvtrx trx should map to ptrx(1)
      %                 f0 = tv.ptrx(1).firstframe;
      %                 if f0~=obj.lObj.currFrame
      %                   obj.lObj.setFrame(f0); % this should result in call to .newLabelerFrame();
      %                 else
      %                   obj.newLabelerFrame();
      %                 end
      %                 tv.trxSelected(1,true); % the first tv.tvtrx trx should map to ptrx(1)
    end


    function trkCompleteCbkAWS(obj,backend,trkfilesLocal,res)
      fprintf('AWS: tracking complete at %s\n',datestr(now));
      assert(numel(trkfilesLocal)==numel(res));
 
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        
        aws = backend.awsec2;
        
        % download trkfiles 
        sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
        for ivw=1:numel(res)
          trkLcl = trkfilesLocal{ivw};
          trkRmt = res(ivw).trkfile;
          fprintf('Trying to download %s to %s...\n',trkRmt,trkLcl);
          aws.scpDownloadOrVerify(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs); % XXX doc orVerify
          fprintf('downloaded...\n');
        end
        
        obj.trkPostProcIfNec(mIdx,trkfilesLocal);
        obj.trackResAddTrkfile(mIdx,trkfilesLocal);
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
    end

    function trkPostProcIfNec(obj,movfiles,trkfiles,varargin) % obj const
      % When appropriate, perform postprocessing and re-save trkfiles in
      % place.
            
      [pp3dtype,calibrationfile,rois,vcd] = myparse(varargin,...
        'pp3dtype',obj.sPrmAll.ROOT.PostProcess.reconcile3dType, ...
        'calibrationfile','',...
        'cropROIs',[],...
        'caldata',[]...
        );

      do3dreconcile = ~strcmp(pp3dtype,'none');
      nvw = obj.lObj.nview;
      moviestr = String.cellstr2DelimList(movfiles,', ');
      %npts = obj.lObj.nPhysPoints;

      if do3dreconcile && nvw >= 2
        if isempty(vcd) || (iscell(vcd)&&isempty(vcd{1}))
          if ~isempty(calibrationfile),
            vcd = CalRig.loadCreateCalRigObjFromFile(calibrationfile);
          else
            warningNoTrace('Cannot perform 3D postprocessing; calibration data unset for %s.',moviestr);
            return;
          end
        end

        assert(numel(trkfiles)==nvw);
        [trks,tfsucc] = ...
          cellfun(@(x)DeepTracker.hlpLoadTrk(x,'rawload',true),trkfiles,'uni',0);
        tfsucc = cell2mat(tfsucc);
        if ~all(tfsucc)
          ivwFailed = find(~tfsucc);
          ivwFailedStr = num2str(ivwFailed(:)');
          warningNoTrace('Cannot perform 3D postprocessing of %s; could not load trkfiles for views: %s.',moviestr,ivwFailedStr);
          return;
        end

        try
          trksave = PostProcess.triangulate(trks,...
            rois,vcd,pp3dtype);
        catch ME
          warningNoTrace('3d postprocessing %s failed: %s',moviestr,ME.getReport());
          return;
        end

        for i = 1:numel(trksave),
          trksavecurr = trksave{i};
          save(trkfiles{i},'-append','-struct','trksavecurr');
          fprintf(1,'Saved/appended variables ''pTrkSingleView'', ''pTrk'', ''pTrk3d'' to trkfile %s.\n',...
            trkfiles{i});
        end
      end
    end

    function trainStoppedCbk(obj,varargin)
      obj.trainCleanup();
      obj.notify('trainEnd');
    end
    
    function trackStoppedCbk(obj,varargin)
      obj.trackCleanup();
      obj.notify('trackEnd');
    end

    function trackCleanup(obj,varargin)
       obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
    
    function trainCleanup(obj,varargin)

      if obj.bgTrkIsRunning,
        fprintf('Stopping tracking...\n');
        obj.bgTrkMonitor.stop();
        obj.bgTrkMonitor.reset();
        assert(~obj.bgTrkIsRunning);
      end

      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      isCurr = obj.checkTrackingResultsCurrent();
      if ~isCurr
        obj.cleanOutOfDateTrackingResults(isCurr);
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();

        %MK 20230301 -- tried to make it work for single animal projects
        %but couldn't create tinfo properly enough after a few feeble
        %attempts. Abandoing it for someone more valorous
%         if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
%           res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Delete');
%           if strcmpi(res,'Retrack'),
%             tblMFTRetrack = obj.getTrackingResultsTable([],'ftonly',true);
%             tinfo = ToTrackInfo('tblMFT',tblMFTRetrack,'trainDMC',obj.trnLastDMC,...
%               'moviefiles',obj.lObj.movieFilesAll,'trxfiles',obj.lObj.trxF);
%             obj.track('totrackinfo',tinfo);
%           end
%         end

      end
      
      % completed/stopped training. old tracking results are deleted/updated, so trackerInfo should be updated
      obj.updateTrackerInfo();
      
      if isempty(obj.skip_dlgs) || ~obj.skip_dlgs
        res = questdlg(sprintf('Training stopped after %s iterations. Save trained model to file?',...
          DeepTracker.printIter(obj.trackerInfo.iterCurr,obj.trackerInfo.iterFinal)),'Save?','Save','Save as...','No','Save');
        if strcmpi(res,'Save'),
          obj.lObj.projSaveSmart();
          obj.lObj.projAssignProjNameFromProjFileIfAppropriate();
        elseif strcmpi(res,'Save as...'),
          obj.lObj.projSaveAs();
          obj.lObj.projAssignProjNameFromProjFileIfAppropriate();
        end
      end
    end
    
    function xvStoppedCbk(obj,varargin)
      
      % load xv res
      % KB TODO update this code once cross-val is debugged
      dmc = obj.trnSplitLastDMC;
      tfE = cellfun(@exist,dmc.valresultsLnx);
      if all(tfE)
        splitIdx = dmc.getSplits();
        nsplt = numel(unique(splitIdx));
        
        info = [];
        locs = [];
        preds = [];
        splt = [];
        %mdlfile = [];
        for isplt=1:nsplt,
          resfile = dmc.valresultsLnx('splitIdx',isplit);
          assert(numel(resfile)==1);
          resfile = resfile{1};
          % TODO make this work with multi-view, etc.
          res = load(resfile,'-mat');
          fprintf(1,'Loaded results file %s\n',resfile);
                    
          predlocs = res.pred_locs.locs; % n x maxnanimals x npts x 2
          lbllocs = res.labeled_locs; % etc
          ni = numel(res.list);
          assert(isequal(ni,size(lbllocs,1),size(predlocs,1)));

          %errl2 = sqrt(sum((lbllocs-predlocs).^2,4)); % [n x maxnanimals x npts]
          info = cat(1,info,cat(1,res.list{:}));
          locs = cat(1,locs,lbllocs); %reshape(lbllocs,ni,[]));
          preds = cat(1,preds,predlocs); %reshape(predlocs,ni,[])); 
          %errs = cat(1,errs,errl2);
          splt = cat(1,splt,isplt*ones(ni,1));
          %mdlfile = cat(1,mdlfile,repmat({char(res.model_file)},ni,1));
        end
        
        info = cell2mat(info);
        LOCTHRESH = -1e3;
        tfLblExist = locs(:,:,1,1)>LOCTHRESH; % n x maxnanimals
        tfPrdExist = preds(:,:,1,1)>LOCTHRESH; % note: nan will not count as existing
        [~,~,npts,d] = size(locs);
        locs(repmat(~tfLblExist,1,1,npts,d)) = nan;
        preds(repmat(~tfPrdExist,1,1,npts,d)) = nan;
        [~,match,matchcosts,~,~,nFP,nFN,nMch,nLbl,nPrd] = ...
          MAGT.comparePredsLbls(locs,preds,tfLblExist,tfPrdExist);

        tblXVres = table(info(:,1),info(:,2),info(:,3),splt,...
          preds,locs,nFP,nFN,nMch,nLbl,nPrd,match,matchcosts,'VariableNames',...
          [MFTable.FLDSID {'fold' 'p' 'pLbl' 'numFP' 'numFN' 'numMatch' 'numLbl' 'numPred' 'matches' 'matchcosts'}]);
        obj.lObj.xvResults = tblXVres;
        obj.lObj.xvResultsTS = now;
        fprintf(1,'Set XV results on lObj.xvResults.*\n');

        obj.notify('trainEnd');

        splitProjDirs = fileparts(fileparts(valresfiles));
        imreadfn = @(x)MAGT.readCoco(x,splitProjDirs);
        MAGT.report(tblXVres,obj.lObj,imreadfn);
      end
    end
    
    function [trnstrs,modelFiles] = getTrainStrModelFiles(obj)
      obj.updateLastDMCsCurrInfo();

      trnstrs = cell(1,obj.trnLastDMC.n);
      modelFiles = cell(1,obj.trnLastDMC.n);
      for i = 1:obj.trnLastDMC.n,
        assert(~isnan(obj.trnLastDMC.iterCurr(i)));
        trnstrs{i} = sprintf('trn%s_iter%d',obj.trnName,obj.trnLastDMC.iterCurr(i));
        modelFiles(i) = obj.trnLastDMC.trainCurrModelLnx(i);
        modelFiles{i} = regexprep(modelFiles{i},'\.index$','');
      end
    end
    
  end
  methods (Static) % train/track codegen
    function [tfsucc,res,warningstr] = syscmd(cmd,varargin)
      [tfsucc,res,warningstr] = AWSec2.syscmd(cmd,varargin{:},...
        'setenvcmd','LD_LIBRARY_PATH=: ');
    end
    function downloadPretrainedWeights(varargin) 
      aptroot = myparse(varargin,...
        'aptroot',APT.Root...
        );
      
      urlsAll = DeepTracker.pretrained_weights_urls;
      weightfilepats = DeepTracker.pretrained_weights_files_pat_lnx;
      deepnetrootlnx = [aptroot '/deepnet'];
      pretrainedlnx = [deepnetrootlnx '/pretrained'];
      for i = 1:numel(urlsAll)
        url = urlsAll{i};
        pat = weightfilepats{i};
        wfile = sprintf(pat,deepnetrootlnx);

        if exist(wfile,'file')>0
          fprintf('Tensorflow resnet pretrained weights %s already downloaded.\n',url);
          continue;
        end
          
        % hmm what happens when the weightfilenames change?
        fprintf('Downloading tensorflow resnet pretrained weights %s (APT)..\n',url);
        outfiles = untar(url,pretrainedlnx);
        sprintf('Downloaded and extracted the following files/directories:\n');
        fprintf('%s\n',outfiles{:});
      end      
    end
    function repoSScmd = repoSnapshotCmd(aptroot,aptrepo)
      repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
      repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,aptrepo);
    end
    function codestr = codeGenSSHGeneral(remotecmd,varargin)
      % Currently this assumes a JRC backend due to oncluster special case      
      [host,bg,prefix,sshoptions,timeout] = myparse(varargin,...
        'host',DLBackEndClass.jrchost,... % 'logfile','/dev/null',...
        'bg',false,... % AL 20201022 see note below
        'prefix',DLBackEndClass.jrcprefix,...
        'sshoptions','-o "StrictHostKeyChecking no"',...
        'timeout',[]);
      
      if ~isempty(prefix),
        remotecmd = [prefix,'; ',remotecmd];
      end
      if ~isempty(timeout),
        sshoptions1 = ['-o "ConnectTimeout ',num2str(timeout),'"'];
        if ~ischar(sshoptions) || isempty(sshoptions),
          sshoptions = sshoptions1;
        else
          sshoptions = [sshoptions,' ',sshoptions1];
        end
      end
          
      if ~ischar(sshoptions) || isempty(sshoptions),
        sshcmd = 'ssh';
      else
        sshcmd = ['ssh ',sshoptions];
      end
            
      if bg
        % AL 20201022 not sure why this codepath was nec. Now it is causing
        % problems with LSF/job scheduling. The </dev/null & business
        % confuses LSF and the account/runtime limit doesn't get set. So
        % for now this is a nonproduction codepath.
        codestr = sprintf('%s %s ''%s </dev/null &''',sshcmd,host,remotecmd);
      else
        tfOnCluster = ~isempty(getenv('LSB_DJOB_NUMPROC'));
        if tfOnCluster
          codestr = remotecmd;
        else
          codestr = sprintf('%s %s ''%s''',sshcmd,host,remotecmd);
        end
      end
    end
    function codestr = codeGenSingGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      DFLTBINDPATH = {
        '/groups/branson/bransonlab'
        '/groups/branson/home'
        '/nrs/branson'
        '/scratch'};      
      dobj = DLBackEndClass(1);
      [bindpath,singimg] = myparse(varargin,...
        'bindpath',DFLTBINDPATH,...
        'singimg',''...
        );
      assert(~isempty(singimg)) ;
      delete(dobj);
      bindpath = cellfun(@(x)['"' x '"'],bindpath,'uni',0);      
      Bflags = [repmat({'-B'},1,numel(bindpath)); bindpath(:)'];
      Bflagsstr = sprintf('%s ',Bflags{:});
      codestr = sprintf('singularity exec --nv %s %s bash -c "%s"',...
        Bflagsstr,singimg,basecmd);
    end
    
    function plnx = codeGenPathUpdateWin2LnxContainer(pwin,mntloc)
      PAT1 = '^(?<drivelet>[a-zA-Z]):\\';
      match_struct = regexp(pwin, PAT1, 'names') ;
      if isempty(match_struct) ,
        plnx = pwin ;
      else
        % We need to lowercase the drive letter for recent (as of April 2023) versions of WSL
        drive_letter = match_struct.drivelet ;
        REP1 = sprintf('%s/%s/', mntloc, lower(drive_letter)) ;
        plnx = regexprep(pwin,PAT1,REP1);
      end
      
      PAT2 = '^\\\\(?<server>[^/\\]+)[/\\]';
      REP2 = sprintf('%s/$<server>/',mntloc);
      plnx = regexprep(plnx,PAT2,REP2);
      
      PAT3 = '\\';
      REP3 = '/';
      plnx = regexprep(plnx,PAT3,REP3);
    end
    
    function codestr = codeGenCondaGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      [condaEnv,gpuid] = myparse(varargin,...
        'condaEnv','APT',...
        'gpuid',0);
      codestr = synthesize_conda_command(['activate ',condaEnv]);
      if ~isnan(gpuid),
        if ispc,
          envcmd = sprintf('set CUDA_DEVICE_ORDER=PCI_BUS_ID&& set CUDA_VISIBLE_DEVICES=%d',gpuid);
        else
          envcmd = sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID&& export CUDA_VISIBLE_DEVICES=%d',gpuid);
        end
         codestr = [codestr,' && ',envcmd];
      end
      codestr = [codestr,' && ',basecmd];
    end
    function codestr = codeGenBsubGeneral(basecmd,varargin)
      [nslots,gpuqueue,outfile,additionalargs] = myparse(varargin,...
        'nslots',1,...
        'gpuqueue',DeepTracker.default_jrcgpuqueue,...
        'outfile','/dev/null', ...
        'additionalargs', '');
      codestr = sprintf('bsub -n %d -gpu "num=1" -q %s -o "%s" -R"affinity[core(1)]" %s %s',...
        nslots,gpuqueue,outfile,additionalargs,basecmd);      
    end
    function [codestr,containerName] = trainCodeGenDocker(backend,...
        fileinfo,trainType,...
        view1b,mntPaths,gpuid,varargin)
                  
      [dockerargs,isMultiView,prev_models,prev_models2,augOnly,augOut,baseargs0] = ... 
        myparse(varargin,...
        'dockerargs',{},...
        'isMultiView',false,...
        'prev_model',[],...
        'prev_model2',[],...
        'augOnly',false, ...
        'augOut','', ... % used only if augOnly==true  
        'baseargs',{} ...
        );

      if ~isMultiView,
        view1b = DeepModelChainOnDisk.getCheckSingle(view1b);
      end

      modelChainID = fileinfo.modelChainID;
      trainID = fileinfo.trainID;
      netModeName = fileinfo.netModeName;

      filequote = backend.getFileQuoteDockerCodeGen;
      baseargs = [{'trainType' trainType 'filequote' filequote} baseargs0];
      if ~isMultiView,
        baseargs = [baseargs, {'view' view1b}];
      end
      if ~isempty(prev_models)
        baseargs = [baseargs, {'prev_model' prev_models}];
      end
      if ~isempty(prev_models2),
        baseargs = [baseargs, {'prev_model2' prev_models2}];
      end

      basecmd = APTInterf.trainCodeGen(fileinfo,...
        baseargs{:},'augOnly',augOnly,'augOut',augOut);      

      if isMultiView,      
        containerName = [modelChainID '_' trainID '_' netModeName];
      else
        containerName = [modelChainID '_' trainID '_' netModeName '_view' num2str(view1b)];
      end

      % using this bool as torch proxy?
      tfRequiresTrnPack = false;
      for i = 1:numel(fileinfo.netType),
        tfRequiresTrnPack = tfRequiresTrnPack || fileinfo.netType{i}.requiresTrnPack(fileinfo.netMode{i});
      end
      if tfRequiresTrnPack
        shmSize = 8;
      else
        shmSize = [];
      end
      codestr = backend.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,'gpuid',gpuid,dockerargs{:},...
        'detach',~augOnly,'tty',augOnly,'shmsize',shmSize);      
    end
    function [codestr] = trainCodeGenConda(fileinfo,trainType,view1b,gpuid,varargin)
      
      [condaargs,isMultiView,outfile,prev_model] = myparse(varargin,'condaargs',{},'isMultiView',false,...
        'outfile','','prev_model',[]);
      %fprintf(2,'TODO: restart/trainType\n');
      %baseargs = {'view' view1b};
      baseargs = {'trainType' trainType};
      if ~isempty(prev_model)
        baseargs = [baseargs,{'prev_model' prev_model}];
      end
      if ~isMultiView,
        baseargs = [baseargs,{'view' view1b}];
      end
      
      basecmd = APTInterf.regTrainCodeGen(fileinfo,baseargs{:},'filesep',filesep,'filequote','"');
      
      if ~isempty(outfile),
        basecmd = sprintf('%s > %s 2>&1',basecmd,outfile);
      end
      
      codestr = DeepTracker.codeGenCondaGeneral(basecmd,...
        'gpuid',gpuid,condaargs{:});
      
    end
    function baseargs = trainTopDownBaseArgs(dmc)
      stages = unique(dmc.getStages());
      if numel(stages) > 1,
        stagearg = 0;
      else
        stagearg = stages;
      end
      baseargs = {...
        'maTopDown' true ... % missing: 'maTopDownStage'
        'maTopDownStage1NetType' dmc.getNetType('stage',1) ...
        'maTopDownStage1NetMode' dmc.getNetMode('stage',1) ...
        'maTopDownStage' stagearg ...
        };
    end
    function [codestr,containerName] = trainCodeGenDockerDMC(...
        dmc,backend,mntPaths,gpuid,varargin)
      [trnCmdType,augOnly,augOut,isTopDown,leftovers] = myparse_nocheck(varargin,...
        'trnCmdType',dmc.trainType,... 
        'augOnly',false, ...
        'augOut','', ...
        'isTopDown',false...
        );
      trnCmdType = DeepModelChainOnDisk.getCheckSingle(trnCmdType);
      if ~isempty(dmc.prev_models),
        if isTopDown,
          stages = unique(dmc.getStages());
          for i = 1:numel(stages),
            stage = stages(i);
            prev_models = dmc.getPrevModels('stage',stage);
            if isempty(prev_models),
              continue;
            end
            if i == 1,
              arg = 'prev_model';
            else
              arg = sprintf('prev_model%d',i);
            end
            leftovers = [leftovers {arg,prev_models}]; %#ok<AGROW> 
          end
        else
          leftovers = [leftovers {'prev_model' dmc.prev_models}];
        end
      end
      if isTopDown,
        baseargs = DeepTracker.trainTopDownBaseArgs(dmc);
      else
        baseargs = {};
      end
%       [codestr,containerName] = DeepTracker.trainCodeGenDocker(backend,...
%         dmc.modelChainID,dmc.trainID,dmc.trainConfigLnx,...
%         dmc.rootDir,dmc.errfileLnx,dmc.netType,dmc.netMode,...
%         trnCmdType,dmc.view+1,mntPaths,gpuid,leftovers{:},...
%         'augOnly',augOnly,'augOut',augOut);
      [codestr,containerName] = DeepTracker.trainCodeGenDocker(backend,...
        dmc.trainFileInfoSingle(),...
        trnCmdType,dmc.getView()+1,mntPaths,gpuid,leftovers{:},...
        'augOnly',augOnly,'augOut',augOut,'baseargs',baseargs);
    end
    function [codestr] = trainCodeGenCondaDMC(dmc,gpuid,varargin)
      [trnCmdType,leftovers] = myparse_nocheck(varargin,'trnCmdType',dmc.trainType);
      trnCmdType = DeepModelChainOnDisk.getCheckSingle(trnCmdType);
      prev_models = dmcs.getPrevModels();
      if ~isempty(prev_models)
        leftovers = [leftovers {'prev_model' prev_models}];
      end
      [codestr] = DeepTracker.trainCodeGenConda(...
        dmc.trainFileInfoSingle(),trnCmdType,dmc.getView()+1,gpuid,...
        'outfile',DeepModelChainOnDisk.getCheckSingle(dmc.trainLogLnx),leftovers{:});
    end
    function codestr = trainCodeGenSing(fileinfo,varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      backend = obj.lObj.trackDLBackEnd ;
      singimg = pick_singularity_image(backend, fileinfo.netMode) ;
      singimg = add_pair_to_key_value_list(singargs, 'singimg', singimg) ;
      baseargs = [baseargs {'confparamsfilequote','\\\"','ignore_local',1}];
      basecmd = APTInterf.trainCodeGen(fileinfo,baseargs{:});      
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trainCodeGenBsubSing(fileinfo,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trainCodeGenSing(fileinfo,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end    
    function codestr = trainCodeGenSSHBsubSing(fileinfo,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{});
      remotecmd = DeepTracker.trainCodeGenBsubSing(fileinfo,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    function codestr = trainCodeGenSSHBsubSingDMC(aptroot,dmc,varargin)
      [singargs,bsubargs,baseargsadd,trnCmdType,isTopDown] = myparse(varargin,...
        'singargs',{},...
        'bsubargs',{},...
        'baseargsadd',{},...
        'trnCmdType',dmc.trainType,...
        'isTopDown',false...
        );
      trnCmdType = DeepModelChainOnDisk.getCheckSingle(trnCmdType);
      if isempty(aptroot)
        aptroot = dmc.dirAptRootLnx;
      end
      % there should only be one modelchainid & trainid for this training
      aptrepo = DeepModelChainOnDisk.getCheckSingle(dmc.aptRepoSnapshotLnx);
        
      repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
      repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,aptrepo);
      prefix = [DLBackEndClass.jrcprefix '; ' repoSScmd];      
      baseargs = {'view' dmc.getView()+1 'trainType' trnCmdType 'deepnetroot' [aptroot '/deepnet']};
      % TODO this split probably won't work properly
      if dmc.isSplit
        baseargs(end+1:end+2) = {
          'val_split' 
          dmc.splitIdx % 'classify_val' true 'classify_val_out' dmc.valresultsLnx
          };
      end
      prev_models = dmc.getPrevModels();
      if ~isempty(prev_models)
        baseargs(end+1:end+2) = {'prev_model' prev_models};
      end
      if isTopDown,
        baseargs = [baseargs, DeepTracker.trainTopDownBaseArgs(dmc)];
      end
      baseargs = [baseargs baseargsadd];
      codestr = DeepTracker.trainCodeGenSSHBsubSing(...
        dmc.trainFileInfoSingle(),...
        'baseArgs',baseargs,...
        'singargs',singargs,...
        'bsubArgs',[bsubargs {'outfile' DeepModelChainOnDisk.getCheckSingle(dmc.trainLogLnx)}],...
        'sshargs',{'prefix' prefix});
    end
    function downloadPretrainedExec(aptroot)
      % kb investigate: This doesn't work well on the cluster due to tf 
      % being a restricted site, plus /tmp acts weird
      assert(isunix,'Only supported on *nix platforms.');
      deepnetroot = [aptroot '/deepnet'];
      cmd = sprintf(DeepTracker.pretrained_download_script_py,deepnetroot);
      [~,res] = DeepTracker.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end      
    function codestr = updateAPTRepoCmd(varargin)
      [aptparent,downloadpretrained,branch] = myparse(varargin,...
        'aptparent','/home/ubuntu',...
        'downloadpretrained',false,...
        'branch','develop'... % branch to checkout
        );
      
      aptroot = [aptparent '/APT/deepnet'];
      
      codestr = {
        sprintf('cd %s;',aptroot);
        sprintf('git checkout %s;',branch);
        'git pull;'; 
        };
      if downloadpretrained
        % assumes we are on lnx. we cd-ed into deepnet above
        codestr{end+1,1} = sprintf(DeepTracker.pretrained_download_script_py,'.');
      end
      codestr = cat(2,codestr{:});
    end   
    function updateAPTRepoExecJRC(cacheRoot) % throws if fails
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      updatecmd = DeepTracker.updateAPTRepoCmd('aptparent',cacheRoot);
      updatecmd = DeepTracker.codeGenSSHGeneral(updatecmd,'bg',false);
      [~,res] = DeepTracker.syscmd(updatecmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = cpPTWfromJRCProdLnx(aptrootLnx)
      % copy cmd (lnx) deepnet/pretrained from production repo to JRC loc 
      srcPTWlnx = [DLBackEndClass.jrcprodrepo '/deepnet/pretrained'];
      dstPTWlnx = [aptrootLnx '/deepnet'];      
      cmd = sprintf('cp -r -u "%s" "%s"',srcPTWlnx,dstPTWlnx);
    end
    function cpupdatePTWfromJRCProdExec(aptrootLnx) % throws if errors
      cmd = DeepTracker.cpPTWfromJRCProdLnx(aptrootLnx);
      cmd = DeepTracker.codeGenSSHGeneral(cmd,'bg',false);
      [~,res] = DeepTracker.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = dirExistsCmd(ddir)
      cmd = sprintf('bash -c "[ -d ''%s'' ] && echo ''y'' || echo ''n''"',ddir);
    end      
    function cloneJRCRepoIfNec(cacheRoot) % throws on fail
      % Clone 'remote' repo into cacheRoot from prod, if necessary
      % 
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      
      % does repo in 'remote' cache exist?
      aptroot = [cacheRoot '/APT'];
      aptrootexistscmd = DeepTracker.dirExistsCmd(aptroot);
      aptrootexistscmd = DeepTracker.codeGenSSHGeneral(aptrootexistscmd,...
        'bg',false);
      
      [~,res] = DeepTracker.syscmd(aptrootexistscmd,...
        'dispcmd',true,...
        'failbehavior','err');
      res = strtrim(res);
      
      % clone it if nec
      switch res
        case 'y'
          fprintf('Found JRC/APT repo at %s.\n',aptroot);
        case 'n'
          cloneaptcmd = sprintf('git clone %s %s',DLBackEndClass.jrcprodrepo,aptroot);
          cloneaptcmd = DeepTracker.codeGenSSHGeneral(cloneaptcmd,'bg',false);
          [~,res] = DeepTracker.syscmd(cloneaptcmd,...
            'dispcmd',true,...
            'failbehavior','err');
          fprintf('Cloned JRC/APT repo into %s.\n',aptroot);
        otherwise
          error('Failed to update APT repo on JRC filesystem.');
      end
    end
          
    function codestr = trainCodeGenAWS(dmc,varargin)
      incViewFlag = myparse(varargin,...
        'incViewFlag',false... % if true, include -view flag to train a single view. if false, no -view flag specified, all views trained serially
        );
      
      assert(isscalar(dmc));
      
      trnCodeGenArgs = {
        dmc.trainFileInfoSingle(),...
        'deepnetroot','/home/ubuntu/APT/deepnet',...
        'trainType',dmc.trainType};
      if incViewFlag
        trnCodeGenArgs = [trnCodeGenArgs {'view' dmc.getView()+1}];
      end
      
      codestr = {
        'cd /home/ubuntu/APT/deepnet;';
        'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
        APTInterf.regTrainCodeGen(trnCodeGenArgs{:});
        };
      codestr = cat(2,codestr{:});
    end
    function str = cellstr2SpaceDelimWithEscapedSpace(c)
      % c: cellstr
      %
      % Use this to convert c to a space-delimited string for use as a
      % command-line argument. It is assumed this argument will be used in 
      % a *nix environment with eg python/argparse; individual elements of 
      % c will have any naked whitespaces escaped so that any such elements 
      % will not be (mis)interpretered as 2+ separate arguments.
      c = cellfun(@String.escapeSpaces,c,'uni',0);
      str = String.cellstr2DelimList(c,' ');
    end
    function str = cellstr2SpaceDelimWithQuote(c,quotechar)
      c = cellfun(@(x)[quotechar x quotechar],c,'uni',0);
      str = String.cellstr2DelimList(c,' '); 
    end
    function codestr = trackCodeGenBaseListFile(trnID,cache,dlconfigfile,outfile,...
        errfile,nettype,view,listfile,varargin)
      % view: 1-based
      
      [deepnetroot,model_file,fs,filequote] = myparse_nocheck(varargin,...
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... 
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        );

      tfmodel = ~isempty(model_file);      
      aptintrf = [deepnetroot fs 'APT_interface.py'];

      code = { ...
        'python' [filequote aptintrf filequote] ...
        '-name' trnID ...
        '-view' num2str(view) ... % 1b 
        '-cache' [filequote cache filequote] ...
        '-err_file' [filequote errfile filequote] ...
        };
      if tfmodel
        code(end+1:end+2) = {'-model_files' [filequote model_file filequote]};
      end
      code = [code ...
        '-type' char(nettype) ...
        [filequote dlconfigfile filequote] 'track' ...
        '-out' [filequote outfile filequote] ...
        '-list_file' [filequote listfile filequote] ];
      
      codestr = String.cellstr2DelimList(code,' ');
    end
    function codestr = trackCodeGenBaseGTClassify(trnID,cache,dlconfigfile,gtoutfile,...
        errfile,nettype,varargin)
      % CodeGen for gtclassify; single view with single gtoutfile
      % 
      % Looks a lot like trackCodeGenBaseListFile
      
      [view,deepnetroot,model_file,fs,filequote] = myparse(varargin,...
        'view',[],... % 1b
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... 
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        );

      tfmodel = ~isempty(model_file);      
      aptintrf = [deepnetroot fs 'APT_interface.py'];

      code = { ...
        'python' [filequote aptintrf filequote] ...
        '-name' trnID ...
        };
      if ~isempty(view)
        code(end+1:end+2) = {'-view' num2str(view)}; ... % 1b 
      end
      code = [code ...
        { '-cache' [filequote cache filequote] ...
        '-err_file' [filequote errfile filequote] ...
        } ];
      if tfmodel
        code(end+1:end+2) = {'-model_files' [filequote model_file filequote]};
      end
      code = [code ...
        '-type' char(nettype) ...
        [filequote dlconfigfile filequote] 'gt_classify' ...
        '-out' [filequote gtoutfile filequote] ];
      
      codestr = String.cellstr2DelimList(code,' ');
    end
    function trackWriteListFile(movfileRem,movfileLcl,tMFTConc,listfileLcl,varargin)
      
      [trxfileRem,isWinBackend,croprois] = myparse(varargin,...
        'trxFiles',{},...
        'isWinBackend',false, ...
        'croprois',[] ...
        );
      
      nviews = size(movfileRem,2);
      ismultiview = nviews > 1;
      
      listinfo = struct;
      if ismultiview,
        listinfo.movieFiles = cell(size(movfileRem,1),1);
        for i = 1:size(movfileRem,1),
          listinfo.movieFiles{i} = movfileRem(i,:);
        end
        listinfo.trxFiles = cell(size(trxfileRem,1),1);
        for i = 1:size(trxfileRem,1),
          listinfo.trxFiles{i} = trxfileRem(i,:);
        end
        listinfo.cropLocs = cell(size(croprois,1),1);
        for i = 1:size(movfileRem,1),
          listinfo.cropLocs{i} = croprois(i,:);
        end
      else
        listinfo.movieFiles = movfileRem;
        listinfo.trxFiles = trxfileRem;
        listinfo.cropLocs = croprois;
      end

      % which movie index does each row correspond to?
      % assume first movie is unique
      [ism,idxm] = ismember(tMFTConc.mov(:,1),movfileLcl(:,1));
      assert(all(ism));
     
      listinfo.toTrack = cell(0,1);
      for mi = 1:size(movfileRem,1),
        idx1 = find(idxm==mi);
        if isempty(idx1),
          continue;
        end
        [t,~,idxt] = unique(tMFTConc.iTgt(idx1));
        for ti = 1:numel(t),
          idx2 = idxt==ti;
          idxcurr = idx1(idx2);
          f = unique(tMFTConc.frm(idxcurr));
          df = diff(f);
          istart = [1;find(df~=1)+1];
          iend = [istart(2:end)-1;numel(f)];
          for i = 1:numel(istart),
            if istart(i) == iend(i),
              fcurr = f(istart(i));
            else
              fcurr = [f(istart(i)),f(iend(i))+1];
            end
            listinfo.toTrack{end+1,1} = {mi,t(ti),fcurr};
          end
        end
      end

      if isWinBackend
        % AL20200929. json validity requires escaping backslash
        listinfo.movieFiles = regexprep(listinfo.movieFiles,'\\','\\\\');
        listinfo.trxFiles = regexprep(listinfo.trxFiles,'\\','\\\\');
      end
      fid = fopen(listfileLcl,'w');
      fprintf(fid,jsonencode(listinfo));
      fclose(fid);
      
    end
    
    function [codestr] = dataAugCodeGenDocker(backend,...
        ID,dlconfigfile,cache,errfile,netType,outfile,varargin)
      
      [baseargs,dockerargs,mntPaths] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{});
      
      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.dataAugCodeGenBase(ID,dlconfigfile,cache,errfile,...
        netType,outfile,baseargs{:},'filequote',filequote);
      
      codestr = backend.codeGenDockerGeneral(basecmd,ID,...
        'bindpath',mntPaths,dockerargs{:});
    end    
    
    function codestr = dataAugCodeGenBase(ID,dlconfigfile,cache,errfile,...
        nettype,outfile,varargin)
      
      [deepnetroot,model_file,fs,filequote] = myparse(varargin,...
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... % can be [nview] cellstr
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!        
        ); 
     
      tfcache = ~isempty(cache);
      tfmodel = ~isempty(model_file);
      
      if tfmodel
        model_file = cellstr(model_file);
      end

      aptintrf = [deepnetroot fs 'APT_interface.py'];      
    
      codestr = sprintf('python %s -name %s',...
        [filequote aptintrf filequote],ID);
      if tfcache
        %cache = String.escapeSpaces(cache);
        codestr = [codestr ' -cache ' [filequote cache filequote]];
      end
      %errfile = String.escapeSpaces(errfile);
      codestr = [codestr ' -err_file ' [filequote errfile filequote]];
      if tfmodel
        %modelfilestr = DeepTracker.cellstr2SpaceDelimWithEscapedSpace(model_file);
        codestr = sprintf('%s -model_files %s',codestr,...
          DeepTracker.cellstr2SpaceDelimWithQuote(model_file,filequote));
      end
      codestr = [codestr sprintf(' -type %s %s data_aug -out %s',...
        char(nettype),[filequote dlconfigfile filequote],[filequote outfile filequote])];
    end    
    
    function [codestr,containerName] = trackCodeGenDocker(backend,fileinfo,...
        frm0,frm1,varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,dockerargs,mntPaths,containerName] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{},'containerName','');
      
      baseargs = [{'cache' fileinfo.cache} baseargs];
      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = APTInterf.trackCodeGenBase(fileinfo,frm0,frm1,baseargs{:},...
        'filequote',filequote);

      if isempty(containerName),
        if iscell(fileinfo.outtrk),
          [~,containerName] = fileparts(fileinfo.outtrk{1});
        else
          [~,containerName] = fileparts(fileinfo.outtrk);
        end
      end
      
      codestr = backend.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,dockerargs{:});
    end
    
    function [codestr] = trackCodeGenConda(fileinfo,frm0,frm1,varargin)
%         movtrk,outtrk,frm0,frm1,...
%         modelChainID,trainID,dlconfigfile,cache,errfile,netType,view1b,mntPaths,...
%         varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,condaargs,outfile] = myparse(varargin,...
        'baseargs',{},'condaargs',{},'outfile','');
      
      addnlbaseargs = {'cache' fileinfo.cache 'filequote' '"' 'updateWinPaths2LnxContainer' false};
      baseargs = [addnlbaseargs baseargs];
        
      basecmd = APTInterf.trackCodeGenBase(fileinfo,frm0,frm1,baseargs{:});
      if ~isempty(outfile),
        basecmd = sprintf('%s > %s 2>&1',basecmd,outfile);
      end
      codestr = DeepTracker.codeGenCondaGeneral(basecmd,...
        condaargs{:});
    end
    
    function codestr = trackCodeGenVenv(fileinfo,frm0,frm1,varargin)
      [baseargs,venvHost,venv,cudaVisDevice,logFile] = myparse(varargin,...
        'baseargs',{},... % p-v cell for trackCodeGenBase
        'venvHost','10.103.20.155',... % host to run DL verman-ws1
        'venv','/groups/branson/bransonlab/mayank/venv',... 
        'cudaVisDevice',[],... % if supplied, export CUDA_VISIBLE_DEVICES to this
        'logFile','/dev/null'...
      ); 
      
      basecode = APTInterf.trackCodeGenBase(fileinfo,...
        frm0,frm1,baseargs{:});
      if ~isempty(cudaVisDevice)
        cudaDeviceStr = ...
          sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID; export CUDA_VISIBLE_DEVICES=%d; ',...
          cudaVisDevice);
      else
        cudaDeviceStr = '';
      end
        
      codestrremote = sprintf('cd %s; source bin/activate; %s%s',venv,...
        cudaDeviceStr,basecode);
      codestr = DeepTracker.codeGenSSHGeneral(codestrremote,...
        'host',venvHost,'logfile',logFile);
    end
    
    function codestr = trackCodeGenSing(backend, fileinfo,frm0,frm1,varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      baseargs = [baseargs {'confparamsfilequote','\\\"','ignore_local',1}];
      basecmd = APTInterf.trackCodeGenBase(fileinfo,frm0,frm1,baseargs{:});
      singimg = pick_singularity_image(backend, fileinfo.netMode) ;
      singargs2 = add_pair_to_key_value_list(singargs, 'singimg', singimg) ;
      codestr = DeepTracker.codeGenSingGeneral(basecmd, singargs2{:});
    end

    function codestr = trackCodeGenBsubSing(backend, fileinfo,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trackCodeGenSing(backend, fileinfo,frm0,frm1,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end
    
    function codestr = trackCodeGenSSHBsubSing(backend, fileinfo,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );
      baseargs = [baseargs {'cache' fileinfo.cache}];      
            
      remotecmd = DeepTracker.trackCodeGenBsubSing(backend, fileinfo,frm0,frm1,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    
    function codestr = trackCodeGenListFileSSHBsubSing(backend, trksysinfo,...
        trnID,nettype,netmode,view,varargin)
      
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );      
      
      cache = trksysinfo.dmcRootDir;
      dlconfigfile = trksysinfo.trainConfigLnx;
      errfile = trksysinfo.errfile;
      outfile = trksysinfo.outfile;
      listfile = trksysinfo.listfile;

      codebase = DeepTracker.trackCodeGenBaseListFile(trnID,cache,dlconfigfile,...
        outfile,errfile,nettype,view,listfile,baseargs{:});
      singimg = pick_singularity_image(backend, netmode) ;
      singargs2 = add_pair_to_key_value_list(singargs, 'singimg', singimg) ;      
      codesing = DeepTracker.codeGenSingGeneral(codebase,singargs2{:});
      codebsub = DeepTracker.codeGenBsubGeneral(codesing,bsubargs{:});
      codestr = DeepTracker.codeGenSSHGeneral(codebsub,sshargs{:});      
    end    
    function codestr = trackCodeGenAWS(...
        fileinfo,frm0,frm1,baseargs)
      % movRemoteFull: can be cellstr when tracking all views
      % trkRemoteFull: "
      % 
      % baseargs: PV cell vector that goes to .trackCodeGenBase
      
      deepnetroot = '/home/ubuntu/APT/deepnet';
      baseargs = [baseargs {'cache' fileinfo.cache}];
      codestrbase = APTInterf.trackCodeGenBase(fileinfo,frm0,frm1,...
        'deepnetroot',deepnetroot,baseargs{:});
      
      codestr = {
         'cd /home/ubuntu/APT/deepnet;';
         'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
         codestrbase
        };
      codestr = cat(2,codestr{:});
    end
    
    function [m,tfsuccess,isold] = parseTrkFileName(trkfile)
      
      tfsuccess = false;
      isold = false;
      [p,n,e] = fileparts(trkfile);
      m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>\d{8}T\d{6})_(view)?(?<view>\d+)?_?(iter)?(?<iter>\d+)?_?(?<trk_ts>\d{8}T\d{6}).*$','names','once');
      if ~isempty(m),
        if ~isfield(m,'iter')
          fprintf('trkfile %s does not have iteration name in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
            m.iter = iter(1);
            isold = true;
          catch ME,
            warning('Could not parse iteration from trkInfo.model_file');
            disp(getReport(ME));
            return;
          end
        else
          m.iter = str2double(m.iter);
        end
        if ~isfield(m,'view'),
          fprintf('trkfile %s does not have view in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            view = DeepModelChainOnDisk.getModelFileView(char(tmp.trkInfo.model_file));
            m.view = view(1);
            isold = true;
          catch ME,
            warning('Could not parse view from trkInfo.model_file');
            disp(getReport(ME));
            return;
          end
        else
          m.view = str2double(m.view);
        end
          
      else
        try
          tmp = load(trkfile,'trkInfo','pTrkTS','-mat');
          m = struct;
          [~,m.base] = fileparts(tmp.trkInfo.mov_file);
          m.trn_ts = tmp.trkInfo.name;
          iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
          m.iter = iter(1);
          if iscell(tmp.pTrkTS),
            min_ts = min(cellfun(@(x) min([nan;x(:)]),tmp.pTrkTS(:)));
          else
            min_ts = min(tmp.pTrkTS(:));
          end
          m.trk_ts = datestr(min_ts,'yyyymmddTHHMMSS');
          isold = true;
        catch ME,
          warning('Could not parse trk file info from trkInfo');
          disp(getReport(ME));
          return;
        end
      end
      m.path = p;
      m.ext = e;
      m.newName = fullfile(m.path,[m.base '_trn' m.trn_ts '_iter' num2str(m.iter) '_' m.trk_ts m.ext]);
      tfsuccess = true;
    end
    
    function [tfsucc,res] = waitForBsubComplete(jobid,cmd,nout,maxWaitTime,doKill)
      starttime = tic;
      res = cell(1,nout);
      bjobscmd = sprintf('bjobs %d',jobid);
      bjobscmd = DeepTracker.codeGenSSHGeneral(bjobscmd,'bg',false);
      killcmd = sprintf('bkill %d',jobid);
      killcmd = DeepTracker.codeGenSSHGeneral(killcmd,'bg',false);
      runStatuses = {'PEND','RUN','PROV','WAIT'};
      doneStatuses = {'DONE'};
      tfJobRunning = false;
      tfJobDone = false;
      
      while true,
        if toc(starttime) > maxWaitTime,
          break;
        end
        [tfsucc,res{:}] = cmd();
        %[augims,tfsucc] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
        if tfsucc,
          break;
        end
        tfJobRunning = false;
        [st2,res2] = system(bjobscmd);
        if st2 == 0,
          ss = strsplit(res2,'\n');
          ism = ~cellfun(@isempty,regexp(ss,'^JOBID','once'));
          i = find(ism,1);
          if ~isempty(i) && i < numel(ss),
            
            % make sure outout is formatted as I think it should be
            assert(~isempty(regexp(ss{i},'^\s*JOBID\s*USER\s*STAT','once')))
            res3 = ss{i+1};
            m = regexp(res3,'^(?<jobid>\d+)\s+(?<user>\w+)\s+(?<stat>\w+)','names','once');
            assert(~isempty(m));
            tfJobRunning = ismember(m.stat,runStatuses);
            tfJobDone = ismember(m.stat,doneStatuses);
            %fprintf('%fs: %s\n',toc(starttime),m.stat);
            
          end
        end
        if ~tfJobRunning && ~tfJobDone,
          warning('Could not find results. Output of bjobs:\n%s\n',res2);
          break;
        end
        drawnow;
      end
      if ~tfsucc && tfJobRunning && doKill,
        [st4,res4] = system(killcmd);
        if ~st4 == 0,
          error('Error killing:\n%s',res4);
        end
      end
      
    end


  end
  methods (Static) % train/track broker util
    function hdir = dlerrGetHomeDir
      m = getenvall;
      hdir = m('HOME');
    end
%     function errfile = dlGetTrackErrFile(trnID,hdir)
%       if exist('hdir','var')==0
%         hdir = DeepTracker.dlerrGetHomeDir;
%       end
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       errfileS = [trnID '_' nowstr '.err'];
%       errfile = fullfile(hdir,errfileS);
%     end
  end
  
  %% TrackRes = Tracking DB. all known tracking results on disk.  
  methods
    function trackResInit(obj)
      m = containers.Map('keytype','int32','valuetype','any');
      obj.movIdx2trkfile = m;
    end
    function trackResAddTrkfile(obj,mIdx,trkfiles)
      % Remember/add a set of [nview] trkfiles associated with mIdx
      
      assert(isscalar(mIdx));
      assert(iscellstr(trkfiles));
            
      [v,id] = obj.trackResGetTrkfiles(mIdx);      
      v(end+1,:) = trkfiles(:)';
      obj.movIdx2trkfile(id) = v;
    end
    function [trkfiles,id] = trackResGetTrkfiles(obj,mIdx)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        trkfiles = m(id);
      else
        trkfiles = cell(0,obj.lObj.nview);
      end      
    end
    function trackResSetTrkfiles(obj,mIdx,trkfiles)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        obj.movIdx2trkfile(id) = trkfiles;
      else
        obj.trackResAddTrkfile(mIdx,trkfiles)
      end      
    end
    function removeMissingTrkFiles(obj,mIdx)
      [trkfiles,id] = obj.trackResGetTrkfiles(mIdx);
      tfexists = cellfun(@(x) exist(x,'file'),trkfiles)>0;
      if ~all(tfexists),
        obj.movIdx2trkfile(id) = trkfiles(tfexists);
      end
    end
    function [tfhasdata,xy,occ,sf,ef,aux,auxlbl] = ...
                            getTrackingResultsCurrMovieTgt(obj)
      lo = obj.lObj;
      if lo.maIsMA
        if ~isempty(obj.trkVizer)
          iTgt = obj.trkVizer.currTrklet;
        else
          iTgt = [];
        end
      else
        iTgt = lo.currTarget;
      end
      trk = obj.trkP;
      if ~isempty(iTgt) && ~isnan(iTgt) && ~isempty(trk)
        nt = obj.trnNetType;
        auxflds = nt.trkAuxFields;
        if isempty(auxflds)
          ispropcurr = [];
        else
        ispropcurr = cellfun(@(x) isprop(trk,x),auxflds);
        end
        auxlbl = nt.trkAuxLabels(:);
        auxflds = auxflds(ispropcurr);
        auxlbl = auxlbl(ispropcurr);
        [tfhasdata,xy,occ,sf,ef,aux] = trk.getPTrkTgt2(iTgt,'auxflds',auxflds);
      else
        tfhasdata = false;
        xy = [];
        occ = [];
        sf = nan;
        ef = nan;
        aux = [];
        auxlbl = cell(0,1);
      end      
    end
    function [trkfileObjs,tfHasRes] = getTrackingResults(obj,mIdx)
      % Get tracking results for MovieIndices mIdx
      %
      % mIdx: [nMov] vector of MovieIndices
      %
      % trkfiles: [nMovxnView] cell of TrkFile objects, or [] if tfHasRes(...) is false
      % tfHasRes: [nMov] logical. If true, corresponding movie(set) has 
      %   tracking nontrivial (nonempty) tracking results
      %
      % DeepTracker uses the filesys as the tracking result DB. This loads 
      % from known/expected trkfiles.
            
      assert(isa(mIdx,'MovieIndex'));
      nMov = numel(mIdx);
      nView = obj.nview;
      trkfileObjs = cell(nMov,nView);
      tfHasRes = false(nMov,1);
      lObj = obj.lObj;
      for i=1:nMov
        mIdxI = mIdx(i);
        trkfilesI = obj.trackResGetTrkfiles(mIdxI);
        movfile = lObj.getMovieFilesAllFullMovIdx(mIdxI);
        movnframes = lObj.getNFramesMovIdx(mIdxI);
        ntrk = size(trkfilesI,1);
        
        if ntrk==0
          % trkfileObjs, tfHasRes, trkfiles initted appropriately
          continue;
        end          
        if ntrk>1
          warningNoTrace('Merging tracking results from %d poseTF trkfiles.\n',ntrk);
        end        
        for ivw=1:nView
          [trkfilesIobj,tfsuccload] = ...
            cellfun(@(f) DeepTracker.hlpLoadTrk(f,'movfile',movfile{ivw},...
                                                  'movnframes',movnframes),...
            trkfilesI(:,ivw),'uni',0);
          tfsuccload = cell2mat(tfsuccload);
          trkfilesIobj = trkfilesIobj(tfsuccload);
          if isempty(trkfilesIobj)
            % if all loads failed
            % none; trkfiles, tfHasRes OK
          else
            tObj = trkfilesIobj{1};
            if numel(trkfilesIobj)>1
              tObj = tObj.merge(trkfilesIobj(2:end),'new_ids',lObj.maIsMA);
            end
            trkfileObjs{i,ivw} = tObj;
            tfHasRes(i) = true;
          end
        end
      end
    end
    function isCurr = checkTrackingResultsCurrent(obj)
      
      isCurr = true;
      obj.updateLastDMCsCurrInfo();
      
      for moviei = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(moviei);
        % some trkfiles don't exist for some reason
        obj.removeMissingTrkFiles(mIdx);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if isempty(trkfiles),
          continue;
        end
        
        isFixed = false;
        newtrkfiles = trkfiles;
        for i = 1:size(trkfiles,1),
          for ivw = 1:size(trkfiles,2),
            [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfiles{i,ivw},ivw);
            assert(tfSuccess);
            if isOldFileName,
              isFixed = true;
              [tfSucc,msg] = copyfile(trkfiles{i,ivw},trkInfo.newName);
              if ~tfSucc,
                warning('Could not rename %s to %s: %s',trkfiles{i,ivw},newtrkfiles{i,ivw},msg);
              else
                newtrkfiles{i,ivw} = trkInfo.newName;
              end
            end
            if ~isCurr,
              %fprintf('Trkfile %s out of date, removing all tracking for movie %d\n',trkfiles{i},moviei);
              break;
            end
          end
        end
        if isFixed,
          obj.trackResSetTrkfiles(mIdx,newtrkfiles);
        end
        if ~isCurr,
          break;
        end

      end
      
    end
        
    function cleanOutOfDateTrackingResults(obj,isCurr)

      if nargin < 2,
        isCurr = obj.checkTrackingResultsCurrent();
      end
      if isCurr,
        return;
      end
      obj.trackResInit();
      obj.trackCurrResInit();
      % deleting old tracking results, so can switch to new tracker info
      obj.vizInit();
      obj.updateTrackerInfo();      
    end
    
    function [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfile,ivw)
      isCurr = true;
      [trkInfo,tfSuccess,isOldFileName] = DeepTracker.parseTrkFileName(trkfile);
      if ~tfSuccess,
        return;
      end
      isCurr = strcmp(DeepModelChainOnDisk.getCheckSingle(obj.trnLastDMC.getModelChainID('view',ivw-1)),trkInfo.trn_ts) && ...
        (DeepModelChainOnDisk.getCheckSingle(obj.trnLastDMC.getIterCurr('view',ivw-1))==trkInfo.iter);
    end
    
    function tf = isTrkFiles(obj)
    
      tf = false;
      for i = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(i);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if ~isempty(trkfiles),
          tf = true;
          return;
        end
      end
      
    end
    
  end
  methods (Static)
    
    function [trkfileObj,tfsuccload] = hlpLoadTrk(tfile,varargin)
      % why in the world is this here and not TrkFile? MK 20230509
      [rawload,movfile,movnframes] = myparse(varargin,...
        'rawload',false,...
        'movfile','',...
        'movnframes',[] ...
        );
            
      try
        if rawload
          trkfileObj = load(tfile,'-mat');
        else
          trkfileObj = TrkFile.loadsilent(tfile,'movfile',movfile,...
            'movnframes',movnframes);
        end
        tfsuccload = true;
      catch ME
        warningNoTrace('Failed to load trkfile: ''%s''. Error: %s',...
          tfile,ME.message);
        trkfileObj = [];
        tfsuccload  = false;
      end
    end    
    
    function [tfsucc,augims] = loadAugmentedData(outfile,nview)

      tfsucc = false;
      augims = struct;
      for i = 1:nview,
        outfile_curr = sprintf('%s_%d.mat',outfile,i-1);
        if ~exist(outfile_curr,'file'),
          return;
        end
        da = load(outfile_curr);
        augims.ims{i} = permute(da.ims,[2,3,4,1]);
        augims.locs{i} = da.locs;
      end
      tfsucc = true;
    end
    
    function s = printIter(iterCurr,iterFinal)

      s = '';
      assert(numel(iterCurr)==numel(iterFinal));
      for i = 1:numel(iterCurr),
        s = [s,sprintf('%d/%d, ',iterCurr(i),iterFinal(i))]; %#ok<AGROW> 
      end
      if ~isempty(s),
        s = s(1:end-2);
      end

    end

  end
  methods
    
    function tblTrkRes = getTrackingResultsTable(obj,mIdxs,varargin) % obj const
      % Get all current tracking results in a table
      %
      % mIdxs: [nmovrequested] vector of MovieIndices. Pass [] to get all
      %   results/movies.
      % 
      % tblTrkRes: [NTrk x ncol] table of tracking results
      %            .pTrk; ABSOLUTE coords
      % pTrkiPt: [npttrk] indices into 1:obj.npts, tracked points. 
      %          size(tblTrkRes.pTrk,2)==npttrk*d
  
      [ftonly,aliveonly] = myparse(varargin,...
        'ftonly',false,...
        'aliveonly',false...
        );
      
%       isMA = obj.lObj.maIsMA;
%       if isMA
%         assert(ftonly);
%       end
        
      m = obj.movIdx2trkfile;
      
      if m.isempty
        tblTrkRes = [];
        %pTrkiPt = [];
        return;
      end
      
      if nargin < 2 || isequal(mIdxs,[])
        mIdxs = m.keys;
        mIdxs = cell2mat(mIdxs(:));
      end
      if ~isa(mIdxs,'MovieIndex'),
        mIdxs = MovieIndex(mIdxs);
      end
      [trk,tfhasres] = obj.getTrackingResults(mIdxs);

      tblTrkRes = [];
      %pTrkiPt = -1;
      for i=1:numel(mIdxs)

        if tfhasres(i)
          tbls = cellfun(@(x)x.tableform('ftonly',ftonly,'aliveonly',aliveonly),trk(i,:),'uni',0);
          tblI = TrkFile.mergetablesMultiview(tbls{:});         
%           if isMA
%             tbl = TrxUtil.tableFT(trk{i,1});
%             tbl.iTgt = repmat(1,height(tbl),1);
%           else
%             if isfield(trk{i,1},'pTrkiPt')
%               if isequal(pTrkiPt,-1)
%                 pTrkiPt = trk{i,1}.pTrkiPt;
%               end
%               if ~isequal(pTrkiPt,trk{i,1}.pTrkiPt)
%                 error('Trkfiles differ in tracked points .pTrkiPt.');
%               end
%               tbl = trk{i,1}.tableform;
%             else
%               tbl = TrxUtil.tableFT(trk{i,1});
%               tbl.iTgt = repmat(1,height(tbl),1);
%               % MK 20210415: TODO update this for trx based tracklets
%               % format trk file.
%             end
%           end
          tblmov = table(repmat(mIdxs(i),height(tblI),1),'VariableNames',{'mov'});
          tblI = [tblmov tblI]; %#ok<AGROW>
          tblTrkRes = [tblTrkRes; tblI]; %#ok<AGROW>
        end         
      end
    end
    function clearTrackingResults(obj)
      % FUTURE TODO: For now we do not actually delete the previous trkfiles.
      obj.trackResInit();
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  
  %% TrackCurrRes = tracked state for current movie. Loaded into .trkP*
  methods
    function trackCurrResInit(obj)
      % Assumes that .trnNetType is set
      obj.trkP = [];
      % all calls to trackCurrResInit should be followed by calls to
      % vizInit() to destroy trkVizer.
    end
    function trackCurrResUpdate(obj)
      % update trackCurrRes (.trkP*) from trackRes (tracking DB)
      labeler = obj.lObj ;
      if ~isvalid(labeler) ,
          return
      end
      mIdx = labeler.currMovIdx;
      if isempty(mIdx) || mIdx==0 || obj.lObj.isinit
        % proj load etc
        return;
      end
      [trks,tfHasRes] = obj.getTrackingResults(mIdx);
      if tfHasRes
        %obj.trackCurrResLoadFromTrks(trks);
        trks{1}.mergeMultiView(trks{2:end});
        trk1 = trks{1};
        trk1.initFrm2Tlt(obj.lObj.nframes);
        obj.trkP = trk1;
        obj.vizInit(false);
      else
        obj.trackCurrResInit();
        obj.vizInit();
      end
      notify(obj,'newTrackingResults');
    end
    
    function [tfhaspred,xy,tfocc] = getTrackingResultsCurrFrm(obj)
      % See TrkFile/getPTrkFrame
      
      frm = obj.lObj.currFrame;
      xyPCM = obj.trkP;
      
      if isempty(xyPCM)
        npts = obj.nPts;
        nTgt = obj.lObj.nTargets;
        tfhaspred = false(nTgt,1);
        xy = nan(npts,2,nTgt);
        tfocc = false(npts,nTgt);        
      else
        % AL20160502: When changing movies, order of updates to 
        % lObj.currMovie and lObj.currFrame is unspecified. currMovie can
        % be updated first, resulting in an OOB currFrame; protect against
        % this.
        
        %frm = min(frm,size(xyPCM,3));
        %xy = squeeze(xyPCM(:,:,frm,:)); % [npt x d x ntgt]
        [tfhaspred,xy,tfocc] = xyPCM.getPTrkFrame(frm,'collapse',true);
        
%         if nargout>1
%           fprintf(2,'TODOXXX');
%           %tfscrocc = strcmp(obj.trkAuxLbl,'scr_occ');
%           switch nnz(tfscrocc)
%             case 0
%               scrocc = nan(obj.nPts,obj.lObj.nTargets);
%             case 1
%               %scrocc = squeeze(obj.trkAux(:,frm,:,tfscrocc));
%             otherwise
%               assert(false,'Multiple fields matching ''scr_occ''.');              
%           end
%           tfocc = scrocc > DeepTracker.MDN_OCCLUDED_THRESH;              
%         end
      end
    end
  end
    
  %% Viz
  methods
    function vizInit(obj,existingTVvizInit)
      % - if .trkP is empty, deletes .trkVizer and returns.
      % - if .trkVizer is empty:
      %     - creates one
      %     - calls trkVizer.vizInit
      % - if .trkVizer existed, call vizInit() if existingTVvizInit==true.
      % - call trkVizer.trkInit() on current .trkP.
      
      if isempty(obj.trkP)
        delete(obj.trkVizer);
        obj.trkVizer = [];
        return;
      end
      
      if nargin < 2
        existingTVvizInit = true;
      end
      
      lObj = obj.lObj;
      tv = obj.trkVizer;
      if isempty(tv)
        tvtagpfix = sprintf('dt_%s',obj.algorithmName);
        tv = lObj.createTrackingVisualizer('predPointsPlotInfo',tvtagpfix);        
        obj.trkVizer = tv;
        tfnewTV = true;
      else
        tfnewTV = false;
      end
      
      if tfnewTV || existingTVvizInit
        % might need to re-vizInit an existing trkVizer eg if number of trx 
        % has changed, maxNanimals has changed, etc.      
        if ~isempty(lObj.trackParams)
          maxNanimals = lObj.trackParams.ROOT.MultiAnimal.Track.max_n_animals;
          maxNanimals = max(ceil(maxNanimals*1.5),10);
        else
          maxNanimals = 20;
        end
        % ntgtmax spec only used by tracklets currently
        tv.vizInit('ntgtmax',maxNanimals);
        tv.setHideViz(obj.hideViz);
      end      
      % eg don't call tv.vizInit() if i) it already existed ii) we are just
      % updating the .trkP.
      
      tv.trkInit(obj.trkP);
    end
    function setHideViz(obj,tf)
      if ~isempty(obj.trkVizer)
        obj.trkVizer.setHideViz(tf);
      end
      obj.hideViz = tf;
    end
    function setShowPredsCurrTargetOnly(obj,tf)
      if ~isempty(obj.trkVizer)
        obj.trkVizer.setShowOnlyPrimary(tf);
      end
      obj.showPredsCurrTargetOnly = tf;
    end
    function updateLandmarkColors(obj)
      ptsClrs = obj.lObj.predPointsPlotInfo.Colors;
      ptsClrs = obj.lObj.Set2PointColors(ptsClrs);
      if ~isempty(obj.trkVizer)
        obj.trkVizer.updateLandmarkColors(ptsClrs);      
      end
    end
    % For updating other cosmetics, go ahead and call obj.trkVizer methods
    % directly
  end

  %% Labeler nav
  methods
    function newLabelerFrame(obj)
      lObj = obj.lObj;
      tv = obj.trkVizer;
      if lObj.isinit || ~lObj.hasMovie || isempty(tv)
        return;
      end
      tv.newFrame(lObj.currFrame);
    end
    function newLabelerTarget(obj)
      if ~obj.lObj.maIsMA && ~isempty(obj.trkVizer)
        iTgt = obj.lObj.currTarget;
        obj.trkVizer.updatePrimary(iTgt);
      end
    end
    function newLabelerMovie(obj)
%       if ~obj.lObj.maIsMA && obj.lObj.hasTrx
%         % in this case, the number of targets (trx) can vary by movie and
%         % currently .trkVizer (TrackingVisualizerMT) needs to be updated
%         % for the number of targets
%         obj.vizInit(); 
%       end
      if obj.lObj.hasMovie
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end
      obj.vizInit();
    end
  end
  
  %% Labeler listeners
  methods
    function labelerMovieRemoved(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      tfLabeledTrainingRowRemoved = ~isempty(edata.mIdxRmedHadLbls) && ...
                                    edata.mIdxRmedHadLbls>0; % negative indices indicate GT movie(s)
      if tfLabeledTrainingRowRemoved
        warningNoTrace('Labeled row(s) removed from project. Clearing trained tracker and tracking results.');
        obj.initHook();
      else
        % relabel movie indices
        obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
        
        % skip this stuff; current movie can never be removed so preds for
        % current movie should not change
        %obj.trackCurrResUpdate();
        %obj.newLabelerFrame();
      end  
      
      [tf,tpdir] = obj.trainPackExists();
      if tf
        warningNoTrace('Clearning training package image cache.');
        TrnPack.clearims(tpdir);
      end
    end
    function labelerMoviesReordered(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
      
      % Assume trackCurrRes does not need update
      
      [tf,tpdir] = obj.trainPackExists();
      if tf
        warningNoTrace('Clearning training package image cache.');
        TrnPack.clearims(tpdir);
      end
    end
  end  
  
  methods
    function result = singularityImgPath(obj)
      backend = obj.backend ;  %#ok<PROP> 
      result = backend.singularity_image_path ;  %#ok<PROP> 
    end
  end    

end
