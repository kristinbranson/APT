classdef DeepTracker < LabelTracker
  
  properties (Dependent)
    algorithmName;
    algorithmNamePretty
    sPrm % new-style DT params
  end
  properties (Constant,Hidden)
    SAVEPROPS = {'sPrmAll' 'containerBindPaths' ...
      'trnNetType' 'trnLastDMC' 'movIdx2trkfile' 'hideViz'}; 
    RemoteAWSCacheDir = '/home/ubuntu/cacheDL';
    jrchost = 'login1.int.janelia.org';
    jrcprefix = 'source /etc/profile';
    jrcprodrepo = '/groups/branson/bransonlab/apt/repo/prod';
    
    pretrained_weights_urls = {...
      'http://download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC.tar.gz'
      'http://download.tensorflow.org/models/resnet_v1_50_2016_08_28.tar.gz'...
      };
    pretrained_weights_files_pat_lnx = {...
      '%s/pretrained/resnet_v2_fp32_savedmodel_NHWC/1538687283/variables/variables.index'... % fill in deepnetroot
      '%s/pretrained/resnet_v1_50.ckpt'... 
      };
    pretrained_download_script_py = '%s/download_pretrained.py'; % fill in deepnetroot
    
    MDN_OCCLUDED_THRESH = 0.5;
  end
  properties (Hidden)
    jrcgpuqueue = 'gpu_any';
    jrcnslots = 1;
  end
  properties
    dryRunOnly % transient, scalar logical. If true, stripped lbl, cmds 
      % are generated for DL, but actual DL train/track are not spawned
    deepnetgitbranch % transient/unmanaged. set me to use/run a diff branch
  end
  properties
    containerBindPaths % cellstr of bind paths for sing/docker
      % Will be used if it is nonempty; otherwise an attempt will be made 
      % to autogenerate the required bind/mount paths.
  end
  properties (Dependent)
    condaEnv; % = 'APT'; % name of conda environment
  end
      
    %% train
    
    % - The trained model lives in the fileSys in <cacheDir>/<proj>view%d/trnName.
    % - Right now you can only have one train running at a time.
    
    % chars, currently autogenerated.
    % - When you retrain, you make a new trnName, every time.
    % - In the cacheDir, a subfolder is created .../<trnName>. This
    % subfolder holds the entire state for your trained model.
    % - Within the subfolder, multiple stripped lbls may exist:
    %   .../<trnName>/<trnNameLbl1>, .../<trnName>/<trnNameLbl2>, ...
    %   representing restarts-with-data-augmentation. The current stripped
    %   lbl (ie typically the one used in the most recent train) is
    %   identified by .trnNameLbl.
    % - As far as DeepTracker.m is concerned, the only output/artifacts 
    % generated by training are these two identifiers.
    % FUTURE TODO: what happens when user alters cacheDir?
    
    % AL These IDs are pure dups of trnLastDMC
%     trnName % modelChainID
%     trnNameLbl % trainID
  
  properties (SetAccess=private)
    trnNetType = DLNetType.mdn; % scalar DLNetType
  end
  properties (Dependent)
    trnName
    trnNameLbl
    filesep
  end
  properties
    % Notes on trnLastDMC.
    %
    % This prop represents the "most recently trained model" for this
    % tracker obj. In many/most workflows the APT UI and backend share a
    % local filesystem and this most recent model lives on this local 
    % filesystem.
    %
    % In some cases, training and tracking occurs remotely relative to the 
    % APT frontend. In this case, there are two relevant filesystems: the 
    % local one available to APT, and the remote one available to the 
    % backend. At various points in a training/tracking workflow, trained 
    % models will exist on BOTH filesystems:
    %
    % * At project load, an existing model might be untarred locally, or 
    % there might be no existing model for a new project.
    % * At train time, a new model model is generated remotely.
    % * At retrain-, augmentedtrain-, or track-time, the local model will 
    % first be uploaded to the remote filesys if necessary.
    % * At project save time, remote models will be downloaded locally
    % before tarring into the project.
    %
    % With regards to this issue, our invariant for .trnLastDMC is that 
    %
    %   .trnLastDMC contains the most recently updated model for the 
    %   tracker, with the .reader property correctly indicating the 
    %   filesystem location of that model. This model is the one that
    %   should be used for inference, saved to projects, etc. Let's call it
    %   the "latest model" (for this tracker).
    %
    % * At project load, all .trnLastDMCs will point to the local
    % filesystem/cache.
    % * When a remote fresh train is spawned, .trnLastDMC is immediately 
    % set to the remote location. Even if the train fails or is killed
    % early, whatever is there remotely is still the latest model.
    % * If a remote track is spawned and the latest model is local, it is
    % uploaded first so the track can occur. The moment this upload 
    % completes, the latest model is moved/set to the remote location.
    % * For now we punt on retrains/augmentedtrains. These pose an issue in
    % that depending on the result of the remote train, the latest model
    % may remain local (eg if the remote train fails, maybe). Maybe the 
    % rule is as simple as "the remote model becomes the latest model if 
    % training completes successfully" but I am not sure. Skip it for now.
    % * At project save-time, the latest model (whereever it may be) is
    % tarred into the project. If the latest model is remote, then it is
    % downloaded first. This download does not update the latest model
    % pointer as the user may continue using the remote/latest model for 
    % tracking.
    %
    % So for now, for the AWS backend, the latest model may start locally, 
    % but once a train or track operation occurs, it will be remote from
    % that point onwards. Conceptually a user could switch backends to
    % local and that would allow the movie to "move back down" but we're
    % not going to worry about that for now.
    trnLastDMC % [nview] Last DeepModelChainOnDisk(s), set during training
    trnTblP % transient, unmanaged. Training rows for last retrain
    
    bgTrnMonitor % BgTrainMonitor obj
    bgTrnMonBGWorkerObj % bgTrainWorkerObj for last/current train
    bgTrnMonitorVizClass % class of trainMonitorViz object to use to monitor training
        
    %% track

    % - Right now you can only have one track running at a time.
    
    trkDockerCPU = false; % transient, scalar logical. If true and using Docker backend, use CPU for tracking
    
    trkGenHeatMaps % transient, scalar logical. If true, include --hmaps opt
      % to generate heatmaps on disk
   
    trkSysInfo % [nview] transient, unmanaged. struct array of info used 
    % for current or most recent tracking codegen/system call. currently 
    % only used for debugging, printing logfiles etc.
    
    bgTrkMonitor % BgTrackMonitor obj
    bgTrkMonBGWorkerObj % bgTrackWorkerObj for last/current rack
    bgTrkMonitorVizClass % class of trackMonitorViz object to use to monitor tracking
    
    % trackres: tracking results DB is in filesys
    movIdx2trkfile % map from MovieIndex.id to [ntrkxnview] cellstrs of trkfile fullpaths
  end
  
  properties (SetObservable)
    
    trackerInfo = [];% information about the current tracker being used for tracking
    
  end
  properties (Dependent)
    bgTrnIsRunning
    bgTrkIsRunning 
  end

  properties
    % track curr res -- in-mem tracking results for current mov    
    trkP   % [npt x 2 x nfrm x ntgt] tracking results for current mov
    trkPTS % [npt x nfrm x ntgt] timestamp for trkP*
    
    trkAux % [npt x nfrm x ntgt x naux] auxiliary per-pt results eg confidences
    trkAuxLbl % [naux] labels for 4th dim of trxAux
              % naux given in DLNetType
%     trkPMD % [NTst <ncols>] table. cols: .mov, .frm, .iTgt
%            % .mov has class movieIndex 
  end
  properties (Dependent)
    nPts % number of label points     
    nview 
    %hasTrained
  end
  
  properties
    trkVizer % scalar TrackingVisualizer
  end
  
  events
    % Thrown when new tracking results are loaded for the current lObj
    % movie
    newTrackingResults 
    
    trainStart
    trainEnd
    trackStart
    trackEnd    
  end
  
  methods
    function v = get.algorithmName(obj)
      v = char(obj.trnNetType);
    end
    function v = get.algorithmNamePretty(obj)
      v = ['Deep Convolutional Network - ' obj.trnNetType.prettyString];
    end
    function v = get.condaEnv(obj)
      v = obj.lObj.trackDLBackEnd.condaEnv;
    end
    function v = get.trnName(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = {dmc.modelChainID};
        assert(all(strcmp(v{1},v)));
        v = v{1};
      end
    end
    function v = get.trnNameLbl(obj)
      dmc = obj.trnLastDMC;
      if isempty(dmc)
        v = '';
      else
        v = {dmc.trainID};
        assert(all(strcmp(v{1},v)));
        v = v{1};
      end
    end
    function v = get.filesep(obj)
      v = obj.lObj.trackDLBackEnd.filesep;
    end
    function v = get.nPts(obj)
      v = obj.lObj.nLabelPoints;
    end
    function v = get.nview(obj)
      v = obj.lObj.nview;
    end
    function v = get.bgTrnIsRunning(obj)
      btm = obj.bgTrnMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
    function v = get.bgTrkIsRunning(obj)
      btm = obj.bgTrkMonitor;
      v = ~isempty(btm) && btm.isRunning;
    end
  end
  
  methods
    function obj = DeepTracker(lObj,varargin)
      obj@LabelTracker(lObj);
      
      for i=1:2:numel(varargin)
        prop = varargin{i};
        val = varargin{i+1};
        obj.(prop) = val;
      end
      
      obj.bgTrnMonitor = [];
      obj.bgTrnMonitorVizClass = 'TrainMonitorViz';
      obj.bgTrkMonitor = [];
      obj.bgTrkMonitorVizClass = 'TrackMonitorViz';
      
      obj.trkVizer = TrackingVisualizerHeatMap(lObj);
    end
    function delete(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      delete(obj.trkVizer);
      obj.trkVizer = [];
    end
    function initHook(obj)
      obj.trnResInit();
      obj.bgTrkReset();
      obj.trackResInit();
      obj.trackCurrResInit();
      obj.vizInit();
    end
  end
  
  %% Params
  methods
    
    % AL 20190415. Note on DeepTrack.Saving.CacheDir
    % Currently nothing never refers to
    % DeepTrackerObj.sPrmAll.Saving.CacheDir. Instead, only lObj.DLCacheDir
    % and DeepTrackerObj.trnLastDMC(iview).rootDir are used. 
    %
    % - (re)train time: DeepTrackerObj uses lObj.DLCacheDir and sets 
    % .trnLastDMC(:).rootDir to this location.
    % - track time: currently we assert that lObj.DLCacheDir matches the
    % .rootDir of any local DMCs to be used
    
    function [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        didParamsChange(obj,sPrmAll) % obj const
      
      tfDiffEmptiness = xor(isempty(obj.sPrmAll),isempty(sPrmAll));
      tfCommonChanged = tfDiffEmptiness || ~APTParameters.isEqualTrackDLParams(obj.sPrmAll,sPrmAll);
      tfPreProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPreProcParams(obj.sPrmAll,sPrmAll);
      tfPostProcChanged = tfDiffEmptiness || ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      
      sOldSpecific = obj.sPrm;
      netType = obj.trnNetType.prettyString;
      sNewSpecific = sPrmAll.ROOT.DeepTrack.(netType);
      tfSpecificChanged = ~isequaln(sOldSpecific,sNewSpecific);
    end
    
    function sPrmAll = massageParamsIfNec(obj,sPrmAll,varargin)
      % net-specific parameter treatments
      % Openpose currently requires particular constraints between
      % parameters that are not required for other DL trackers. Current
      % treatment is
      % - lObj.trackParams continues to be "anything", ie user continues
      % to specify whatever they like in Tracking Parameters. (More
      % precisely, there may be constraints amongst parameters at this
      % level, but these constraints are common to all DL trackers.)
      % - When the universal params are to be set on a specific DL
      % tracker, we may mutate them to meet any DLnet-specific
      % constraints.
      % - So in normal "steady" usage, specific DeepTrackers may have
      % parameters that differ (typically v slightly) from the "main"
      % params. This may be noted in the trackerInfoString.
      
      [throwwarnings] = myparse(varargin,...
        'throwwarnings',true...
        );
      
      net = obj.trnNetType;
      switch net
        case {DLNetType.openpose DLNetType.leap}
          dl_steps = sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps;
          save_step = sPrmAll.ROOT.DeepTrack.Saving.save_step;
          display_step = sPrmAll.ROOT.DeepTrack.Saving.display_step;
          
          if dl_steps < display_step
            dl_steps = display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be greater than or equal to the display step. Updating to %d DL steps.',...
                net.prettyString,dl_steps);
            end
          end
          
          if mod(dl_steps,display_step)~=0
            dl_steps = ceil(dl_steps/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the number of DL steps to be an even multiple of the display step. Increasing DL steps to %d.',...
                net.prettyString,dl_steps);
            end
          end
          
          if save_step < display_step
            save_step = display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be greater than or equal to display step. Updating the DL save step to %d.',...
                net.prettyString,save_step);
            end
          end
          
          if mod(save_step,display_step)~=0
            save_step = ceil(save_step/display_step)*display_step;
            if throwwarnings
              warningNoTrace('%s requires the DL save step to be an even multiple of the display step. Increasing the DL save step to %d.',...
                net.prettyString,save_step);
            end
          end
          
          sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps = dl_steps;
          sPrmAll.ROOT.DeepTrack.Saving.save_step = save_step;
      
        otherwise
          % none
      end
    end
      
    function setAllParams(obj,sPrmAll)
      sPrmAll = obj.massageParamsIfNec(sPrmAll);
      
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
        obj.didParamsChange(sPrmAll);
      
      obj.sPrmAll = sPrmAll;
      
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged,
        obj.initHook();
      end
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        obj.updateTrackerInfo(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
    function tfPostProcChanged = setPostProcParams(obj,sPrmAll)
      tfPostProcChanged = ~APTParameters.isEqualPostProcParams(obj.sPrmAll,sPrmAll);
      obj.sPrmAll.ROOT.PostProcess = sPrmAll.ROOT.PostProcess;
      if tfPostProcChanged
        warningNoTrace('Postprocessing parameters changed; clearing existing tracking results.');
        obj.trackResInit();
        obj.trackCurrResUpdate();
        obj.updateTrackerInfo(); % AL: prob unnec but also prob doesn't hurt
        obj.newLabelerFrame();
      end
    end
      
    function v = get.sPrm(obj)
      if isempty(obj.sPrmAll),
        v = [];
      else
        netType = obj.trnNetType.prettyString;
        v = obj.sPrmAll.ROOT.DeepTrack.(netType);
      end
    end
    function sPrm = getParams(obj)
      sPrm = obj.sPrm;
    end
    function tc = getTrackerClassAugmented(obj)
      tc = {class(obj) 'trnNetType' obj.trnNetType};
    end
    function s = getSaveToken(obj)
      s = struct();
      props = obj.SAVEPROPS;
      for p=props(:)',p=p{1}; %#ok<FXSET>
        s.(p) = obj.(p);
      end      
    end
    function loadSaveToken(obj,s)
      s = DeepTracker.modernizeSaveToken(s);
      
      obj.initHook(); % maybe handled upstream
      flds = fieldnames(s);
      flds = setdiff(flds,'hideViz');
      for f=flds(:)',f=f{1}; %#ok<FXSET>
        obj.(f) = s.(f);
      end
      
      obj.dryRunOnly = false;
      
      obj.setHideViz(s.hideViz);
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  methods (Static)
    function s = modernizeSaveToken(s)
      % 20181215
      if isfield(s,'awsEc2')
        s = rmfield(s,'awsEc2');
      end
      if isfield(s,'backendType')
        s = rmfield(s,'backendType');
      end
      % 20181218
      if ~isfield(s,'containerBindPaths')
        s.containerBindPaths = cell(0,1);
      end 
      
      % 20190214
      % (Comment is basically C+P from CPRLabelTracker)
      % IMPORTANT philisophical note. We update/modernize .sPrmAll here,
      % but any changes should not invalidate previous trained trackers.
      % Parameters may be renamed, new parameters added, etc; but eg any 
      % new parameters added should be added with default values that 
      % effectively would have been previously used.

      assert(isfield(s,'sPrmAll') && ~isfield(s,'sPrm')); % taken care of in Labeler/lblModernize
      sPrmDflt = APTParameters.defaultParamsStructAll;      
      if ~isempty(s.sPrmAll)
        % Labeler/lblModernize may not have modernized s.sPrmAll
        s.sPrmAll = structoverlay(sPrmDflt,s.sPrmAll,...
          'dontWarnUnrecog',true); % to allow removal of obsolete params
      else
        % AL 20190713 leave s.sPrmAll empty for untrained trackers
        tfTrained = isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC);
        assert(~tfTrained,'Apparent trained tracker with no parameters.');
        % s.sPrmAll = sPrmDflt;
        % Let's leave s.sPrmAll empty for now
      end
      
      % 20190405 
      % .trnName, .trnNameLbl removed as they dup .trnLastDMC
      if isfield(s,'trnName')
        s = rmfield(s,'trnName');
      end
      if isfield(s,'trnNameLbl')
        s = rmfield(s,'trnNameLbl');
      end
      % Add .reader to any .trnLastDMCs; assume local filesys
      if isfield(s,'trnLastDMC') && ~isempty(s.trnLastDMC) && ~isfield(s.trnLastDMC,'reader')
        rdrObj = DeepModelChainReaderLocal();
        [s.trnLastDMC.reader] = deal(rdrObj);
      end
      
      % 20190415
      % remove .movIdx2trkfile for now, with bundle-save we don't save
      % DeepTracker-stored tracking results
      if isfield(s,'movIdx2trkfile')
        s = rmfield(s,'movIdx2trkfile');
      end
      
      % 20190520: filesep needed for local windows
      if isfield(s,'trnLastDMC'),
        for i = 1:numel(s.trnLastDMC),
          if ~isempty(s.trnLastDMC(i)) && isempty(s.trnLastDMC(i).filesep),
            s.trnLastDMC.filesep = '/';
          end
        end
      end
    end
  end
  
  %% Backends
  methods
    
    % if we don't need to be careful with quotes, we can use this
    function s = dockercmd(obj)
      if isempty(APT.DOCKER_REMOTE_HOST),
        s = 'docker';
      else
        s = sprintf('ssh -t %s docker',APT.DOCKER_REMOTE_HOST);
      end
    end
    
    function [gpuid,freemem,gpuInfo] = getFreeGPUs(obj,nrequest,varargin)
      be = obj.lObj.trackDLBackEnd;
      [gpuid,freemem,gpuInfo] = be.getFreeGPUs(nrequest,varargin{:});      
    end
        
  end
  
  %% Train
  methods
    
    function train(obj)
      error('Incremental training is currently unsupported for Deep Learning.');
    end
    
    % Training timeline
    %
    % - Call to retrain. this creates a new jobname every time.
    % - stripped lbl written to <cacheDir>/<trnID>.lbl
    % - bg trn monitor started
    % - training spawned
    % - as log/intermediate results are written, loss viz in plot.
    % - you can start tracking at any time with the latest model by calling
    % track().
    % - FUTURE TODO you can't forcibly stop training for now.
    % - FUTURE TODO you can't choose to use a trained model before the last/final
    % - FUTURE TODO clean up old/unwanted trained models.
    % one if say it looked less overtrained or better.
    % - trained models will sit on disk; stripped lbl at 
    % <cache>/<trnName>.lbl, and models at <cache>/.../<trnName>
    
    % For Training, there are two processes
    % 1. The backend train itself. After this is spawned, this currently 
    % cannot be managed/killed from this class. If there is an issue the
    % actual compute needs to be manually killed.
    % 2. Background monitoring of the train. This can be reset with
    % bgTrnReset().
    
    function trnResInit(obj)      
      obj.trnLastDMC = [];
      obj.bgTrnReset();
    end

    function bgTrnStart(obj,backEnd,dmcs)
      % fresh start new training monitor 
            
      if ~isempty(obj.bgTrnMonitor)
        error('Training monitor exists. Call .bgTrnReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrnMonBGWorkerObj));

      nvw = obj.lObj.nview;
      assert(numel(dmcs)==nvw);

      trnMonObj = BgTrainMonitor;
      addlistener(trnMonObj,'bgStart',@(s,e)obj.notify('trainStart'));
      addlistener(trnMonObj,'bgEnd',@(varargin) obj.trainStoppedCbk(varargin{:}));

      switch backEnd.type
        case DLBackEnd.Bsub
          trnWrkObj = BgTrainWorkerObjBsub(nvw,dmcs);
        case DLBackEnd.Conda
          trnWrkObj = BgTrainWorkerObjConda(nvw,dmcs);
        case DLBackEnd.Docker
          trnWrkObj = BgTrainWorkerObjDocker(nvw,dmcs);
        case DLBackEnd.AWS
          trnWrkObj = BgTrainWorkerObjAWS(nvw,dmcs,backEnd.awsec2);
        otherwise
          assert(false);
      end

      trnVizObj = feval(obj.bgTrnMonitorVizClass,nvw,obj,trnWrkObj,backEnd.type);
                
      trnMonObj.prepare(trnVizObj,trnWrkObj);
      trnMonObj.start();
      obj.bgTrnMonitor = trnMonObj;
      obj.bgTrnMonBGWorkerObj = trnWrkObj;
    end
    
    function bgTrnRestart(obj,bgTrnMonitorObj)
      % Mostly for debugging hanging monitors. "Kills" current bg training
      % monitor and restarts.
      
      fprintf(2,'Needs cleanup\n');
      
      if isempty(obj.bgTrnMonitor) || isempty(obj.bgTrnMonBGWorkerObj)
        error('Training monitor does not exist.');
      end
      
      workerObj = obj.bgTrnMonBGWorkerObj;
      fprintf(1,'Restarting bg train monitor. Monitor cls: %s. Worker cls: %s\n',...
        class(bgTrnMonitorObj),class(workerObj));

      workerObj.reset();
      delete(obj.bgTrnMonitor);
      obj.bgTrnMonitor = [];
      obj.bgTrnMonBGWorkerObj = [];
      
      obj.bgTrnStart(bgTrnMonitorObj,workerObj); % xxx TODO
    end

    function bgTrnReset(obj)
      % stop the training monitor
      if ~isempty(obj.bgTrnMonitor)
        delete(obj.bgTrnMonitor);
      end
      obj.bgTrnMonitor = [];      
      if ~isempty(obj.bgTrnMonBGWorkerObj)
        delete(obj.bgTrnMonBGWorkerObj);
      end
      obj.bgTrnMonBGWorkerObj = [];
    end    
    
    function tf = getHasTrained(obj)
      tf = ~isempty(obj.trnLastDMC);
    end
    
    function [tfCanTrain,reason] = canTrain(obj)
      
      tfCanTrain = false;
      reason = '';
      if obj.bgTrnIsRunning
        reason = 'Training is already in progress.';
        return;
      end
      if obj.bgTrkIsRunning,
        reason = 'Tracking is in progress.';
        return;
      end
      
      % For now we do this check here even though the actual parfeval()
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn training monitor.';
        return;
      end

      % AL 20190321 parameters now set at start of retrain
%       if isempty(obj.sPrmAll)
%         reason = 'No tracking parameters have been set.';
%         return;
%       end
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'No cache directory has been set.';
        return;
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        reason = 'Please give your project a name. The project name will be used to identify your trained models on disk.';
        return;
      end
      
      backend = lblObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
      
      if isempty(obj.trnNetType)
        reason = 'Deep net type is empty.';
        return;
      end
      
      if obj.trnNetType==DLNetType.openpose && isempty(lblObj.skeletonEdges)
        reason = 'Please define a skeleton to track with OpenPose.';
        return;
      end
      
      tfCanTrain = true;      
    end
    
    function retrain(obj,varargin)
      
      [wbObj,dlTrnType,oldVizObj] = myparse(varargin,...
        'wbObj',[],...
        'dlTrnType',DLTrainType.New, ...
        'oldVizObj',[] ...
        );
      
      if obj.bgTrnIsRunning
        error('Training is already in progress.');
      end
      
      if obj.bgTrkIsRunning
        error('Tracking is in progress.');
      end
      
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
      projname = lblObj.projname;
      if isempty(projname)
        error('Please give your project a name. The project name will be used to identify your trained models on disk.');
      end      
      
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n');      
      
      if obj.isTrkFiles(),
        
        res = questdlg('Tracking results exist for previous deep trackers. When training stops, these will be deleted. Continue training?','Continue training?','Yes','No','Cancel','Yes');
        if ~strcmpi(res,'Yes'),
          return;
        end
        
      end
      
      obj.setAllParams(lblObj.trackGetParams());
      
      if isempty(obj.sPrmAll)
        error('No tracking parameters have been set.');
      end

      obj.bgTrnReset();
      if ~isempty(oldVizObj),
        delete(oldVizObj);
      end
      
      modelChain0 = obj.trnName;
      switch dlTrnType
        case DLTrainType.New
          modelChain = datestr(now,'yyyymmddTHHMMSS');
          if ~isempty(modelChain0)
            assert(~strcmp(modelChain,modelChain0));
            fprintf('Training new model %s.\n',modelChain);
          end
        case {DLTrainType.Restart DLTrainType.RestartAug}
          if isempty(modelChain0)
            error('Model has not been trained.');
          end
          modelChain = modelChain0;
          fprintf('Restarting train on model %s.\n',modelChain);
        otherwise
          assert(false);
      end
                  
      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
          obj.trnSpawnBsubDocker(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj);
        case DLBackEnd.AWS
          obj.trnSpawnAWS(trnBackEnd,dlTrnType,modelChain,'wbObj',wbObj);          
        otherwise
          assert(false);
      end
      
      % Nothing should occur here as failed trnSpawn* will early return      
    end
    
    function trnPrintLogs(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.printLogfiles();      
    end
    
    function trnPrintModelChainDir(obj)
      modelChainID = obj.trnName;
      if isempty(modelChainID) 
        error('Training is not complete or in progress.');
      end
      if ~obj.bgTrnIsRunning
        fprintf('Training is not in progress; log is for most recent training session.\n');
      end
      trnBgWorkerObj = obj.bgTrnMonBGWorkerObj;
      trnBgWorkerObj.dispModelChainDir();
    end
    
    function trnKill(obj)
      if ~obj.bgTrnIsRunning
        error('Training is not in progress.');
      end
      
      obj.bgTrnMonBGWorkerObj.killProcess();      
    end
    
    % update trackerInfo from trnLastDMC
    function updateTrackerInfo(obj)
      
      % info about algorithm and training
      info.algorithm = obj.algorithmNamePretty;
      info.isTraining = obj.bgTrnIsRunning;
              
      if isempty(obj.trnLastDMC),
        info.isTrainStarted = false;
        info.isTrainRestarted = false;
        info.trainStartTS = [];
        info.iterCurr = 0;
        info.iterFinal = nan;
        info.nLabels = 0;
      else
        info.isTrainStarted = true;
        info.isTrainRestarted = strcmp(obj.trnLastDMC(1).trainType,'Restart');
        info.trainStartTS = datenum(unique({obj.trnLastDMC.modelChainID}),'yyyymmddTHHMMSS');
        assert(all(~isnan(info.trainStartTS)));
        info.iterCurr = unique([obj.trnLastDMC.iterCurr]);
        if isempty(info.iterCurr),
          info.iterCurr = 0;
        end
        info.iterFinal = unique([obj.trnLastDMC.iterFinal]);
        info.nLabels = unique([obj.trnLastDMC.nLabels]);
      end
      
      obj.trackerInfo = info;
    end
    
    % set select properties of trackerInfo 
    function setTrackerInfo(obj,varargin)
      
      [iterCurr] = myparse(varargin,'iterCurr',[]);
      ischange = false;
      
      trackerInfo = obj.trackerInfo; %#ok<PROPLC>
      if ~isempty(iterCurr),
        ischange = ischange || iterCurr ~= trackerInfo.iterCurr; %#ok<PROPLC>
        trackerInfo.iterCurr = iterCurr; %#ok<PROPLC>
      end
      if ischange,
        obj.trackerInfo = trackerInfo; %#ok<PROPLC>
      end
      
    end
    
    % return a cell array of strings with information about current tracker
    function [infos] = getTrackerInfoString(obj,doupdate)
      % For OpenPose, consider adding blurb about massaged params
      
      if nargin < 2,
        doupdate = false;
      end
      if doupdate,
        obj.updateTrackerInfo();
      end
      infos = {};
      infos{end+1} = obj.trackerInfo.algorithm;
      if obj.trackerInfo.isTrainStarted,
        isNewLabels = any(obj.trackerInfo.trainStartTS < obj.lObj.lastLabelChangeTS);

        infos{end+1} = sprintf('Train start: %s',datestr(min(obj.trackerInfo.trainStartTS)));
        if numel(obj.trackerInfo.iterCurr) > 1,
          scurr = mat2str(obj.trackerInfo.iterCurr);
        else
          scurr = num2str(obj.trackerInfo.iterCurr);
        end
        if numel(obj.trackerInfo.iterFinal) > 1,
          sfinal = mat2str(obj.trackerInfo.iterFinal);
        else
          sfinal = num2str(obj.trackerInfo.iterFinal);
        end
        infos{end+1} = sprintf('N. iterations: %s / %s',scurr,sfinal);
        if isempty(obj.trackerInfo.nLabels),
          nlabelstr = '?';
        elseif numel(obj.trackerInfo.nLabels) == 1,
          nlabelstr = num2str(obj.trackerInfo.nLabels);
        else
          nlabelstr = mat2str(obj.trackerinfo.nLabels);
        end          
        infos{end+1} = sprintf('N. labels: %s',nlabelstr);
        if isNewLabels,
          s = 'Yes';
        else
          s = 'No';
        end
        infos{end+1} = sprintf('New labels since training: %s',s);
        
        sPrmAllLabeler = obj.lObj.trackGetParams();
        sPrmAllAsSet = obj.massageParamsIfNec(sPrmAllLabeler,'throwwarnings',false);
        args = {'trackerAlgo',obj.algorithmName,'hasTrx',obj.lObj.hasTrx,'trackerIsDL',true};
        
        isParamChange = ~APTParameters.isEqualFilteredStructProperties(...
          obj.sPrmAll,sPrmAllAsSet,args{:});
        isParamChangeLbler = ~APTParameters.isEqualFilteredStructProperties(...
          obj.sPrmAll,sPrmAllLabeler,args{:});        
        if isParamChange,
          s = 'Yes';
        else
          s = 'No';
        end
        infos{end+1} = sprintf('Parameters changed since training: %s',s);
        
        if isParamChangeLbler
          if ~isParamChange
            assert(obj.trnNetType==DLNetType.openpose || obj.trnNetType==DLNetType.leap);
          end
          infos{end+1} = sprintf('Parameter adjustment: %s',obj.trnNetType.prettyString);
        end        
      else
        infos{end+1} = 'No tracker trained.';
      end
      
    end
    
    function props = propList(obj)
      props = obj.trnNetType.timelinePropList;
    end
    
    function [augims,dataAugDir] = dataAug(obj,ppdata,varargin)
      
      [sPrmAll,dataAugDir] = myparse(varargin,...
        'sPrmAll',[],'dataAugDir','' ...
        );
      
      if isempty(sPrmAll),
        sPrmAll = obj.sPrmAll;
      end
      if isempty(sPrmAll)
        error('Tracking parameters not set.');
      end
      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        error('No cache directory has been set.');
      end
      
      lblObj = obj.lObj;
%       projname = lblObj.projname;
%       if isempty(projname)
%         error('Please give your project a name. The project name will be used to identify your trained models on disk.');
%       end
            
      trnBackEnd = lblObj.trackDLBackEnd;
      fprintf('Your deep net type is: %s\n',char(obj.trnNetType));
      fprintf('Your training backend is: %s\n',char(trnBackEnd.type));
      fprintf('Your training vizualizer is: %s\n',obj.bgTrnMonitorVizClass);
      fprintf(1,'\n');      

      switch trnBackEnd.type
        case {DLBackEnd.Bsub DLBackEnd.Conda DLBackEnd.Docker}
          [augims,dataAugDir] = obj.dataAugBsubDocker(ppdata,sPrmAll,trnBackEnd,'dataAugDir',dataAugDir);
        case DLBackEnd.AWS
          error('not implemented');
          %obj.trnSpawnAWS(trnBackEnd,modelChain,'wbObj',wbObj);    
        otherwise
          assert(false);
      end
    end
    
  end
  methods
    %% BSub Trainer
      
    function trnSpawnBsubDocker(obj,backEnd,trnType,modelChainID,varargin)
      %
      % backEnd: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set
      %
      % TODO break up bsub/docker sep meths

      [wbObj] = myparse(varargin,...
        'wbObj',[]... 
        );
      
      % (aws check instance running)
      
      cacheDir = obj.lObj.DLCacheDir;
      
      % Currently, cacheDir must be visible on the JRC shared filesys.
      % In the future, we may need i) "localWSCache" and ii) "jrcCache".
      
      % (aws update remote repo)

      nvw = obj.lObj.nview;
      isMultiViewTrain = false;
      nTrainJobs = nvw;
      if backEnd.type == DLBackEnd.Docker || backEnd.type == DLBackEnd.Conda,
        % how many gpus do we have available?
        gpuids = obj.getFreeGPUs(nvw);
        if numel(gpuids) < nvw,
          if nvw == 1,
            error('No GPUs with sufficient RAM available locally');
          else
            gpuids = gpuids(1);
            isMultiViewTrain = true;
            nTrainJobs = 1;
          end
        end
      end
      
       % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...   
        'rootDir',cacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',isMultiViewTrain,...
        'reader',DeepModelChainReader.createFromBackEnd(backEnd),...
        'filesep',obj.filesep...
        );

      switch backEnd.type
        case DLBackEnd.Bsub
          if backEnd.deepnetrunlocal
            aptroot = APT.Root;
            %dmc.aptRootUser = aptroot;
            %DeepTracker.downloadPretrainedExec(aptroot);
            DeepTracker.cpupdatePTWfromJRCProdExec(aptroot);
          else
            aptroot = [cacheDir '/APT'];
            DeepTracker.cloneJRCRepoIfNec(cacheDir);
            DeepTracker.updateAPTRepoExecJRC(cacheDir);
            DeepTracker.cpupdatePTWfromJRCProdExec(aptroot);
          end
        case [DLBackEnd.Conda,DLBackEnd.Docker],
          aptroot = APT.Root;
          obj.downloadPretrainedWeights('aptroot',aptroot); 
      end
      
      % create/ensure stripped lbl; set trainID
      tfGenNewStrippedLbl = trnType==DLTrainType.New || trnType==DLTrainType.RestartAug;
      
      trnCmdType = trnType;
      
      if tfGenNewStrippedLbl
        s = obj.trnCreateStrippedLbl('wbObj',wbObj);
        % store nLabels in dmc
        dmc.nLabels = s.nLabels;
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmc.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;

        dlLblFileLcl = dmc.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
        % read nLabels from stripped lbl file
        dmc.readNLabels();
         
        % if no training has actually happened, do not restart, just start
        % anew
        obj.updateLastDMCsCurrInfo();
        isPartiallyTrained = true;
        for i = 1:numel(obj.trnLastDMC),
          isPartiallyTrained = isPartiallyTrained && obj.trnLastDMC(i).isPartiallyTrained();
        end
        if ~isPartiallyTrained,
          trnCmdType = DLTrainType.New;
        end
        
      end

      % At this point
      % We have (modelChainID,trainID). stripped lbl is on disk. 

      syscmds = cell(nvw,1);
      switch backEnd.type
        case DLBackEnd.Bsub
          mntPaths = obj.genContainerMountPath('aptroot',aptroot);
        case DLBackEnd.Docker 
          mntPaths = obj.genContainerMountPath();          
      end
      
      switch backEnd.type
        case DLBackEnd.Bsub
          singArgs = {'bindpath',mntPaths};
          for ivw=1:nvw
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            syscmds{ivw} = DeepTracker.trainCodeGenSSHBsubSingDMC(...
              aptroot,dmc(ivw),...
              'singArgs',singArgs,'trnCmdType',trnCmdType,...
              'bsubargs',{'gpuqueue' obj.jrcgpuqueue 'nslots' obj.jrcnslots});
          end
        case DLBackEnd.Docker
          containerNames = cell(nTrainJobs,1);
          logcmds = cell(nTrainJobs,1);
          syscmds = cell(nTrainJobs,1);
          for ivw=1:nvw,
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            if ivw <= nTrainJobs,
            gpuid = gpuids(ivw);
            [syscmds{ivw},containerNames{ivw}] = ...
                DeepTracker.trainCodeGenDockerDMC(dmc(ivw),backEnd,mntPaths,gpuid,...
                'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType);
            logcmds{ivw} = sprintf('%s logs -f %s &> "%s" &',...
              obj.dockercmd,containerNames{ivw},dmc(ivw).trainLogLnx);
            end
          end
        case DLBackEnd.Conda
          condaargs = {'condaEnv',obj.condaEnv};
          for ivw=1:nvw,
            if ivw>1
              dmc(ivw) = dmc(1).copy();
            end
            dmc(ivw).view = ivw-1; % 0-based
            if ivw <= nTrainJobs,
              gpuid = gpuids(ivw);
              syscmds{ivw} = ...
                DeepTracker.trainCodeGenCondaDMC(dmc(ivw),gpuid,...
                'isMultiView',isMultiViewTrain,'trnCmdType',trnCmdType,...
                'condaargs',condaargs);
            end
          end
        otherwise
          assert(false);
      end
      
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backEnd,dmc);
        
        bgTrnWorkerObj = obj.bgTrnMonBGWorkerObj;
        
        % spawn training
        if backEnd.type==DLBackEnd.Docker
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [st,res] = system(syscmds{iview});
            if st==0
              bgTrnWorkerObj.parseJobID(res,iview);
              
              fprintf(1,'%s\n',logcmds{iview});
              [st2,res2] = system(logcmds{iview});
              if st2==0
              else
                fprintf(2,'Failed to spawn logging job for view %d: %s.\n\n',...
                  iview,res2);
              end
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        elseif backEnd.type==DLBackEnd.Conda
          bgTrnWorkerObj.jobID = cell(1,nTrainJobs);
          for iview=1:nTrainJobs
            fprintf(1,'%s\n',syscmds{iview});
            [job,st,res] = parfevalsystem(syscmds{iview});
            if ~st,
              bgTrnWorkerObj.parseJobID(job,iview);
            else
              fprintf(2,'Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end            
          end
        else
          bgTrnWorkerObj.jobID = nan(1,nTrainJobs);
          assert(nTrainJobs==numel(dmc));
          for iview=1:nTrainJobs
            syscmdrun = syscmds{iview};
            fprintf(1,'%s\n',syscmdrun);
            
            cmdfile = dmc(iview).cmdfileLnx;
            %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
            [fh,msg] = fopen(cmdfile,'w');
            if isequal(fh,-1)
              warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
            else
              fprintf(fh,'%s\n',syscmdrun);
              fclose(fh);
              fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
            end
            
            [st,res] = system(syscmdrun);
            if st==0
              PAT = 'Job <(?<jobid>[0-9]+)>';
              stoks = regexp(res,PAT,'names');
              if ~isempty(stoks)
                jobid = str2double(stoks.jobid);
              else
                jobid = nan;
                warningNoTrace('Failed to ascertain jobID.');
              end
              fprintf('Training job (view %d) spawned, jobid=%d.\n\n',...
                iview,jobid);
              % assigning to 'local' workerobj, not the one copied to workers
              bgTrnWorkerObj.jobID(iview) = jobid;
            else
              fprintf('Failed to spawn training job for view %d: %s.\n\n',...
                iview,res);
            end
          end
        end        
        obj.trnLastDMC = dmc;
      end
    end
    
    function [augims,dataAugDir] = dataAugBsubDocker(obj,ppdata,sPrmAll,backEnd,varargin)
      
      [dataAugDir] = myparse(varargin,'dataAugDir','');
      
      cacheDir = obj.lObj.DLCacheDir;

      tfLblFileExists = false;
      if ~isempty(dataAugDir) && exist(dataAugDir,'dir'),
        dlLblFileLcl = fullfile(dataAugDir,'dataaug.lbl');
        if exist(dlLblFileLcl,'file'),
          tfLblFileExists = true;
        end
        [~,ID] = fileparts(dataAugDir);
      end
            
      if tfLblFileExists,
        s = load(dlLblFileLcl,'-mat','trackParams','trackerData');
        s.trackParams = sPrmAll;
        ITRKER_SLBL = 2;
        s.trackerData{ITRKER_SLBL}.sPrmAll = sPrmAll;
        save(dlLblFileLcl,'-struct','s','-append');
        fprintf('Reusing cached lbl file %s\n',dlLblFileLcl);
      else
        s = obj.trnCreateStrippedLbl('ppdata',ppdata,'sPrmAll',sPrmAll);
        ID = datestr(now,'yyyymmddTHHMMSS');
        dataAugDir = fullfile(cacheDir,'DataAug',ID);
        if ~exist(dataAugDir,'dir'),
          [succ,msg] = mkdir(dataAugDir);
          if ~succ
            error('Failed to create dir %s: %s',dataAugDir,msg);
          end
        end
        % Write stripped lblfile to local cache
        dlLblFileLcl = fullfile(dataAugDir,'dataaug.lbl');
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
      end
      
      errfile = fullfile(dataAugDir,'dataaug.err');
      outfile = fullfile(dataAugDir,'dataaug');
      
      switch backEnd.type
        case DLBackEnd.Bsub
          if backEnd.deepnetrunlocal
            aptroot = APT.Root;
            %DeepTracker.downloadPretrainedExec(aptroot);
            DeepTracker.cpupdatePTWfromJRCProdExec(aptroot);
          else
            aptroot = [cacheDir '/APT'];
            DeepTracker.cloneJRCRepoIfNec(cacheDir);
            DeepTracker.updateAPTRepoExecJRC(cacheDir);
            DeepTracker.cpupdatePTWfromJRCProdExec(aptroot);
          end
        case DLBackEnd.Docker
        case DLBackEnd.Conda
      end
      
      switch backEnd.type
        case DLBackEnd.Bsub
          mntPaths = obj.genContainerMountPath('aptroot',aptroot);
        case DLBackEnd.Docker 
          mntPaths = obj.genContainerMountPath();          
        case DLBackEnd.Conda
      end
      
      switch backEnd.type
        case DLBackEnd.Bsub
          singArgs = {'bindpath',mntPaths};
          syscmd = DeepTracker.dataAugCodeGenSSHBsubSing(...
            ID,dlLblFileLcl,cacheDir,errfile,obj.trnNetType,outfile,...
            'singArgs',singArgs);
        case DLBackEnd.Docker
          dockerargs = {'detach',false};
          [syscmd] = ...
            DeepTracker.dataAugCodeGenDocker(backEnd,...
            ID,dlLblFileLcl,cacheDir,errfile,obj.trnNetType,outfile,...
            'mntPaths',mntPaths,'dockerargs',dockerargs);
        case DLBackEnd.Conda
          error('Not implemented'); % TODO
        otherwise
          assert(false);
      end
      
      if backEnd.type==DLBackEnd.Docker,
        
        fprintf(1,'%s\n',syscmd);
        [st,res] = system(syscmd);
        
        tfsucc = (st == 0) && ~isempty(regexp(res,'Augmented data saved to','once'));
        if tfsucc,
          [tfsucc,augims] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
          if ~tfsucc,
            error('Error loading augmented data');
          end
        else
          error('Error creating sample augmented images:\n%s',res);
        end
        
      else
        
        fprintf(1,'%s\n',syscmd);
        [st,res] = system(syscmd);
        if st==0,
          PAT = 'Job <(?<jobid>[0-9]+)>';
          stoks = regexp(res,PAT,'names');
          if ~isempty(stoks),
            jobid = str2double(stoks.jobid);
            
            cmd =  @() DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
            nout = 1;
            maxWaitTime = 60; % seconds
            [tfsucc,augims] = DeepTracker.waitForBsubComplete(jobid,cmd,nout,maxWaitTime,true);
            if ~tfsucc,
              error('Data augmentation did not complete within %d seconds',maxWaitTime);
            end
            augims = augims{1};
          else
            error('Failed to ascertain jobID.');
          end
        else
          error('Error creating sample augmented images:\n%s',res);
        end
      end
      
    end
    
    function paths = genContainerMountPath(obj,varargin)
      
      [aptroot,extradirs] = myparse(varargin,...
        'aptroot',APT.Root,'extra',{});
      
      if ~isempty(obj.containerBindPaths)
        assert(iscellstr(obj.containerBindPaths),'containerBindPaths must be a cellstr.');
        fprintf('Using user-specified container bind-paths:\n');
        paths = obj.containerBindPaths;
      else
        lObj = obj.lObj;
        
        macroCell = struct2cell(lObj.projMacrosGetWithAuto());
        cacheDir = obj.lObj.DLCacheDir;
        assert(~isempty(cacheDir));
        
        mfaf = lObj.movieFilesAllFull;
        tfaf = lObj.trxFilesAllFull;
        mfafgt = lObj.movieFilesAllGTFull;
        tfafgt = lObj.trxFilesAllGTFull;
        
        projbps = cell(0,1);
        projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,mfaf,'.movieFilesAllFull');
        if ~isempty(mfafgt)
          projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,mfafgt,'.movieFilesAllGTFull');
        end
        if lObj.hasTrx
          projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,tfaf,'.trxFilesAllFull');
          if ~isempty(tfafgt)
            projbps = DeepTracker.hlpAugBasePathsWithWarn(projbps,tfafgt,'.trxFilesAllGTFull');
          end
        end
        
%         % add in home directory and their ancestors
%         homedir = getuserdir;
%         homeancestors = [{homedir},getpathancestors(homedir)];
%         if isunix,
%           homeancestors = setdiff(homeancestors,{'/'});
%         end
        
        fprintf('Using auto-generated container bind-paths:\n');
        dlroot = [aptroot '/deepnet'];
        paths = [cacheDir;dlroot;macroCell(:);projbps(:);extradirs(:)];
        paths = unique(paths);
      end
      
      cellfun(@(x)fprintf('  %s\n',x),paths);
    end   
    
    function updateLastDMCsCurrInfo(obj)      
      dmcs = obj.trnLastDMC;
      for i=1:numel(dmcs)
        dmcs(i).updateCurrInfo();
      end
    end
    
  end
  methods (Static)
    function basepaths = hlpAugBasePathsWithWarn(basepaths,newpaths,descstr)
      bps = FSPath.commonbase(newpaths);
      if isempty(bps)
        % no nonempty common base found, ie common base is '/'
        warningNoTrace('No common base path found for %s.',descstr);
      else
        fprintf(1,'Found base path ''%s'' for %s.\n',bps,descstr);
        basepaths{end+1,1} = bps;
      end
    end    
  end
  %% AWS Trainer    
  methods
      
    function trnSpawnAWS(obj,backend,trnType,modelChainID,varargin)
      %
      % backend: scalar DLBackEndClass
      % trnType: scalar DLTrainType
      % modelChainID: trainID 
      %
      % PostConds (success):
      %  - training aws job spawned
      %  - .trnLastDMC set
      
      [wbObj] = myparse(varargin,...
        'wbObj',[]... 
        );
            
      aws = backend.awsec2;
      if isempty(aws)
        error('AWSec2 object not set.');
      end
      aws.checkInstanceRunning(); % harderrs if instance isn't running
      
      if isempty(obj.deepnetgitbranch)
        args = {};
      else
        args = {'updateCmdArgs' {'branch' obj.deepnetgitbranch}};
      end
      DeepTracker.updateAPTRepoExecAWS(aws,args{:});
      
      nvw = obj.lObj.nview;

      % Base DMC, to be further copied/specified per-view
      dmc = DeepModelChainOnDisk(...        
        'rootDir',obj.RemoteAWSCacheDir,...
        'projID',obj.lObj.projname,...
        'netType',char(obj.trnNetType),...
        'view',nan,... % to be filled in 
        'modelChainID',modelChainID,...
        'trainID','',... % to be filled in 
        'trainType',trnType,...
        'iterFinal',obj.sPrmAll.ROOT.DeepTrack.GradientDescent.dl_steps,...
        'isMultiView',nvw>1,... % currently all multiview projs train serially
        'reader',DeepModelChainReader.createFromBackEnd(backend),...
        'filesep',obj.filesep...
        );
      dmcLcl = dmc.copy();
      dmcLcl.rootDir = obj.lObj.DLCacheDir;
      
      % create/ensure stripped lbl, local and remote
      tfGenNewStrippedLbl = trnType==DLTrainType.New || ...
                            trnType==DLTrainType.RestartAug;
                          
      if tfGenNewStrippedLbl        
        s = obj.trnCreateStrippedLbl('awsRemote',true,'wbObj',wbObj); 
        % store nLabels in DMC
        dmc.nLabels = s.nLabels;
        
        trainID = datestr(now,'yyyymmddTHHMMSS');
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;
        
        % Write stripped lblfile to local cache
        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        dlLblFileLclDir = fileparts(dlLblFileLcl);
        
        % MK 2019018. Creating the cache dir in case it does not exist
        % realized later that cache dir should exist by default.
        % so commenting it out for now, but might be useful.
%         dlCacheDir = fileparts(dlLblFileLclDir);
%         if exist(dlCacheDir,'dir')==0
%           fprintf('Creating local dir: %s\n',dlCacheDir);
%           [succ,msg] = mkdir(dlCacheDir);
%           if ~succ
%             error('Failed to create local dir %s: %s',dlCacheDir,msg);
%           end
%         end
        
        if exist(dlLblFileLclDir,'dir')==0
          fprintf('Creating local dir: %s\n',dlLblFileLclDir);
          [succ,msg] = mkdir(dlLblFileLclDir);
          if ~succ
            error('Failed to create local dir %s: %s',dlLblFileLclDir,msg);
          end
        end
        save(dlLblFileLcl,'-mat','-v7.3','-struct','s');
        fprintf('Saved stripped lbl file locally: %s\n',dlLblFileLcl);
      else % Restart
        trainID = obj.trnNameLbl;
        assert(~isempty(trainID));
        
        dmc.trainID = trainID;
        dmcLcl.trainID = trainID;

        dlLblFileLcl = dmcLcl.lblStrippedLnx;
        if exist(dlLblFileLcl,'file')>0
          fprintf(1,'Found existing local stripped lbl file: %s\n',dlLblFileLcl);
        else
          error('Cannot find local stripped lbl file: %s',dlLblFileLcl);
        end
        
        dmc.restartTS = datestr(now,'yyyymmddTHHMMSS');
        dmcLcl.restartTS = dmc.restartTS;
        % read nLabels from stripped lbl file
        dmcLcl.readNLabels();
        dmc.nLabels = dmcLcl.nLabels;
      end
      dlLblFileRemote = dmc.lblStrippedLnx;
      aws.scpUploadOrVerifyEnsureDir(dlLblFileLcl,dlLblFileRemote,'training file');
      
      % At this point
      % We have (modelChainID,trainID), dlLblFileRemote. remote is ready to 
      % train
      
      % gen DMCs
      for ivw=1:nvw
        if ivw>1
          dmc(ivw) = dmc(1).copy();
        end
        dmc(ivw).view = ivw-1; % 0-based
      end

      % codegen
      % Multiview train is currently serial (no -view flag spec'd)
      % - single logfile
      % - single errfile
      codestr = obj.trainCodeGenAWS(dmc(1)); % all dmcs identical save for view flag
      logfileRemote = dmc(1).trainLogLnx;
      syscmds = { aws.sshCmdGeneralLogged(codestr,logfileRemote) };
            
      if obj.dryRunOnly
        cellfun(@(x)fprintf(1,'Dry run, not training: %s\n',x),syscmds);
      else
        obj.bgTrnStart(backend,dmc);

        % spawn training
        syscmdrun = syscmds{1};
        fprintf(1,'%s\n',syscmdrun);
        system(syscmdrun);
        fprintf('Training job spawned.\n\n');

        % record local cmdfile
        cmdfile = dmcLcl.cmdfileLnx; % currently writes "...viewNan..." since view is not set; this is benign
        %assert(exist(cmdfile,'file')==0,'Command file ''%s'' exists.',cmdfile);
        [fh,msg] = fopen(cmdfile,'w');
        if isequal(fh,-1)
          warningNoTrace('Could not open command file ''%s'': %s',cmdfile,msg);
        else
          fprintf(fh,'%s\n',syscmdrun);
          fclose(fh);
          fprintf(1,'Wrote command to cmdfile %s.\n',cmdfile);
        end
        
        pause(3.0); % Hack try to more reliably get PID -- still not 100% AL 20190130
        aws.getRemotePythonPID(); % Conceptually, bgTrnWorkerObj should
            % remember. Right now there is only one PID per aws so it's ok
        
        obj.trnLastDMC = dmc;
      end
    end
        
    function ppdata = fetchPreProcData(obj,tblP,ppPrms)
      % Fetch preprocessed data per this tracker. Don't update any cache
      % b/c the preproc params supplied may be "trial"/random.
      % 
      % tblP: MFTable
      % ppPrms: scalar struct, preproc params only.
      % 
      % ppdata: CPRData
            
      %ppdb = obj.lObj.ppdb;
      ppdb = PreProcDB();
      ppdb.init();
      [~,ppdata] = ppdb.add(tblP,obj.lObj,'prmpp',ppPrms,'computeOnly',true);
    end
        
    function s = trnCreateStrippedLbl(obj,varargin)
      % 
      % - Mutates .trnTblP
      % - can update .lObj.ppdb
      % - Uploads trxs via AWS (maybe obsolete now)
      % - Can throw
      
      [awsRemote,wbObj,ppdata,sPrmAll] = myparse(varargin,...
        'awsRemote',false,...
        'wbObj',[],...
        'ppdata',[],...
        'sPrmAll',[]...
        );
      
      [tfsucc,tblPTrn,s] = obj.lObj.trackCreateDeepTrackerStrippedLbl(...
         'wbObj',wbObj,'ppdata',ppdata,'sPrmAll',sPrmAll);
      if ~tfsucc
        error('Failed to create DL stripped lbl file.');
      end
      if isempty(ppdata),
        obj.trnTblP = tblPTrn;
      end
      
      ITRKER_SLBL = 2;
      assert(s.trackerData{ITRKER_SLBL}.trnNetType==obj.trnNetType);
      
      % for images, deepnet will use preProcData; trx files however need
      % to be uploaded
            
      if awsRemote 
        % 1. The moviefiles in s should be not be used; deepnet should be
        % reading images directly from .preProcData_I. Fill s.movieFilesAll
        % with jibber as an assert.
        % 2. The trxfiles in s refer to local files; for AWS training we
        % will need them to refer to remote locs.
        %   a. For each trxfile that appears in the training data, we
        %      upload it and replace all appropriate rows of s.trxFilesAll.
        %   b. For all other rows of s.trxFilesAll, we replace with jibber
        %      as an assert.

        % Originally we uploaded trxfiles but this is no longer nec since
        % training relies on the cache which is now pre-rotated etc etc
        
        s.movieFilesAll(:) = {'__UNUSED__'};
        if obj.lObj.hasTrx
          s.trxFilesAll(:) = {'__UNUSED__'};
        end
      end
    end
    
%     function trnCompleteCbkAWS(obj,res)      
%       bgWorker = obj.bgTrnMonBGWorkerObj;
%       % use the aws from here, guess .lObj.trackDLBackEnd could have changed? Hmmmmm
%       aws = bgWorker.awsEc2; 
%       
%       obj.updateLastDMCsCurrInfo();
%       
%       dmc = obj.trnLastDMC;
%        
%         % download trkfiles 
%         sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
%         for ivw=1:numel(res)
%           trkLcl = trkfilesLocal{ivw};
%           trkRmt = res(ivw).trkfile;
%           aws.scpDownload(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs);
%         end
%     end
    
  end
  
  %% Track  
  methods
    
    % Tracking timeline
    % - Call to track. We are talking a single movie right now.
    % - .trnLastDMC must be set. The current backend behavior is the most 
    % recent model in <cache>/.../trnName will be used
    % - BG track monitor started. This polls the filesys for the output
    % file.
    % - Spawn track shell call.
    % - When tracking is done for a view, movIdx2trkfile is updated.
    % - When tracking is done for all views, we stop the bgMonitor and we
    % are done.    
    
    function track(obj,tblMFT,varargin)
      % Apply trained tracker to the specified frames.
      % 
      % tblMFT: MFTable with cols MFTable.FLDSID
      
      if obj.bgTrkIsRunning
        error('Tracking is already in progress.');
      end
      if obj.bgTrnIsRunning && obj.lObj.trackDLBackEnd.type==DLBackEnd.AWS
        % second clause is really, "only have 1 GPU avail"
        % AWS, currently we are testing with p2.xlarge and p3.2xlarge which
        % are single-GPU EC2 instances. multi-GPU instances are avail
        % however.
        error('Tracking while training is in progress is currently unsupported on AWS.');
      end
      
      isexternal = iscell(tblMFT);
      
      sPrmLabeler = obj.lObj.trackGetParams();
      sPrmSet = obj.massageParamsIfNec(sPrmLabeler);
      [tfCommonChanged,tfPreProcChanged,tfSpecificChanged,tfPostProcChanged] = ...
          obj.didParamsChange(sPrmSet);
      if tfCommonChanged || tfPreProcChanged || tfSpecificChanged
        warningNoTrace('Deep Learning parameters have changed since your last retrain.');
        % Keep it simple for now. Note training might be in progress but
        % even if not etc.
      end
      
      obj.setPostProcParams(sPrmSet);
      % Specifically allow/support case where tfPostProcChanged is true
      % to enable turning off/on postproc or trying diff pp algos with a 
      % given trained tracker   
      
      obj.bgTrkReset();
        
      % track an external movie
      if isexternal
        movfiles = tblMFT;
        [trxfiles,trkfiles,f0,f1,cropRois,targets] = myparse(varargin,...
          'trxfiles',{},'trkfiles',{},'f0',[],'f1',[],'cropRois',{},'targets',{});
        assert(size(movfiles,2)==obj.lObj.nview,'movfiles must be nmovies x nviews');
        [nmovies,nviews] = size(movfiles); 
        
        if obj.lObj.hasTrx,
          assert(all(size(trxfiles)==size(movfiles)),'Trx files must be input');
        end
        assert(all(size(trkfiles)==size(movfiles)),'Output trk files must be input');

        if isempty(cropRois),
          cropRois = repmat({CropInfo.empty(0,0)},nmovies,1);
        end
        
        if isempty(targets),
          targets = repmat({[]},[nmovies,1]);
        end
        
        trkfilesexist = cellfun(@exist,trkfiles);
        if any(trkfilesexist(:)),
          trkfilesdelete = trkfiles(trkfilesexist>0);
          res = questdlg([{'The following output trk files already exist. Delete them?'};trkfilesdelete(:)],'Delete existing trk files?','Delete','Cancel','Cancel');
          if strcmpi(res,'Delete'),
            for i = 1:numel(trkfilesdelete),
              delete(trkfilesdelete{i});
            end
          else
            return;
          end
        end
        
        if ~strcmp(obj.sPrmAll.ROOT.PostProcess.reconcile3dType,'none')
          msg = '3D reconciliation is currently not supported for external movie tracking. Tracking results will not be postprocessed or reconciled in 3D. '
          uiwait(msgbox(msg,'3D Reconciliation','modal'));
        end
      end
      
      if ~isexternal && isempty(tblMFT)
        warningNoTrace('Nothing to track.');
        return;
      end
      
      if obj.bgTrnIsRunning,
        assert(obj.lObj.trackDLBackEnd.type~=DLBackEnd.AWS);
        obj.updateLastDMCsCurrInfo();
        iterCurr = zeros(size(obj.trnLastDMC));
        for i = 1:numel(obj.trnLastDMC),
          ic = obj.trnLastDMC(i).iterCurr;
          if isempty(ic) || isnan(ic)
            iterCurr(i) = 0;
          else
            iterCurr(i) = ic;
          end
        end
        iterCurr = min(iterCurr);
        if iterCurr == 0,
          % AL updated msg to be palatable for both single and multi-views
          % (in the latter case you may have a tracker for one view but not
          % another)
          warndlg('Training in progress, and in-progress tracker(s) has not been saved yet. Please wait to track.','Tracker not ready','modal'); 
          return;
        end
        res = questdlg(sprintf('Training in progress. Tracking will use in-progress tracker, which has been trained for %d / %d iterations. When training completes, these frames will need to be retracked. Continue?',...
          iterCurr,obj.trnLastDMC(1).iterFinal),'Use in-progress tracker?','Track','Cancel','Track');
        if strcmpi(res,'Cancel'),
          return;
        end
      end
                    
      % check trained tracker
      if isempty(obj.trnName)
        error('No trained tracker found.');
      end

      dmc = obj.trnLastDMC;
      backend = obj.lObj.trackDLBackEnd;

      if backend.type==DLBackEnd.AWS
        aws = backend.awsec2;        
        
        % update apt code
        if isempty(obj.deepnetgitbranch)
          args = {};
        else
          args = {'updateCmdArgs' {'branch' obj.deepnetgitbranch}};
        end
        DeepTracker.updateAPTRepoExecAWS(aws,args{:});
        
        for i=1:numel(dmc)
          if ~dmc(i).isRemote
            dmc(i).mirror2remoteAws(aws);
          end
        end
      end
      
      obj.updateTrackerInfo();
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      if ~isexternal,
        isCurr = obj.checkTrackingResultsCurrent();
        if ~isCurr,
          
          res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Cancel','Delete');
          if strcmpi(res,'Cancel'),
            return;
          end
          if strcmpi(res,'Retrack'),
            tblMFTRetrack = obj.getTrackedMFT();
            ism = ismember(tblMFTRetrack,tblMFT);
            tblMFT = [tblMFT;tblMFTRetrack(~ism,:)];
          end
          obj.cleanOutOfDateTrackingResults(isCurr);
        end
        
        % figure out what to track
        tblMFT = MFTable.sortCanonical(tblMFT);
        mIdx = unique(tblMFT.mov);
        if ~isscalar(mIdx)
          error('Tracking only single movies is currently supported.');
        end
        tMFTConc = obj.lObj.mftTableConcretizeMov(tblMFT);
        
        fprintf(1,'\n');
        
        tftrx = obj.lObj.hasTrx;
        if tftrx % can prob do away with this conditional
          f0 = min(tblMFT.frm);
          f1 = max(tblMFT.frm);
          % More complex version of warning below would apply
        else
          f0 = tblMFT.frm(1);
          f1 = tblMFT.frm(end);
          if ~isequal((f0:f1)',tblMFT.frm)
            warningNoTrace('Tracking additional frames to form continuous sequence.');
          end
        end
               
        if obj.lObj.cropProjHasCrops
          assert(~tftrx);
        cropInfo = obj.lObj.getMovieFilesAllCropInfoMovIdx(mIdx);
        cropRois = cat(1,cropInfo.roi);
        else
          cropRois = [];
        end        
      end

      tfHeatMap = ~isempty(obj.trkGenHeatMaps) && obj.trkGenHeatMaps;
      if tfHeatMap
        hmapArgs = {'hmaps' true};
      else
        hmapArgs = {};
      end
      
      % Could check here that for local dmcs, dmc.rootDir matches
      % obj.lObj.DLCacheDir (as in canTrack()). However the assertion that
      % the local stripped lbl exists probably suffices
      
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(obj.lObj.DLCacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      assert(exist(dlLblFileLcl,'file')>0);
      
      switch backend.type
        case DLBackEnd.Bsub,
          if isexternal,
            args = {};
            if obj.lObj.hasTrx,
              args = {'trxfiles',trxfiles,'targets',targets};
            end
            % this is not going to work for multiple movies. TODO: fix
            tfSuccess = obj.trkSpawnBsubDocker(backend,[],[],dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'movfiles',movfiles,'trkfiles',trkfiles,args{:});
          else
            tfSuccess = obj.trkSpawnBsubDocker(backend,mIdx,tMFTConc,dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1);
          end
          if ~tfSuccess,
            obj.bgTrkReset();
            return;
          end
          
        case {DLBackEnd.Docker,DLBackEnd.Conda},

          isMultiViewTrack = false;
          if isexternal,
            % TODO: see docker track other branch below
            gpuids = obj.getFreeGPUs(nmovies*nviews);
            if isempty(gpuids),
              warndlg('No GPUs available with sufficient RAM locally','Error tracking','modal');
              return;
            elseif numel(gpuids) < nmovies*nviews,
              isMultiViewTrack = true;
              nMoviesTrack = numel(gpuids);
            else
              nMoviesTrack = nmovies;
            end
            if nMoviesTrack < nmovies,
              res = questdlg([{sprintf('%d GPUs found locally. Only %d movies can be tracked simultaneously.',numel(gpuids),nMoviesTrack)
                'Track the following subset of movies?'}
                reshape(movfiles(1:nMoviesTrack,:),[nMoviesTrack*nviews,1])],...
                'Track a subset of movies?','Track','Cancel','Cancel');
              if strcmpi(res,'Cancel'),
                return;
              end
              movfiles = movfiles(1:nMoviesTrack,:);
              trxfiles = trxfiles(1:nMoviesTrack,:);
              trkfiles = trkfiles(1:nMoviesTrack,:);
              nmovies = nMoviesTrack;
            end
          else
            if obj.trkDockerCPU
              gpuids = [];
              isMultiViewTrack = true;
            else
              gpuids = obj.getFreeGPUs(obj.lObj.nview);
              if isempty(gpuids)
                % On linux, we couldn't find GPUs
                % On win, .getFreeGPUs probably didn't play well with Docker
                % on Windows (ie didnt do the intended query) but anyway we
                % currently don't support GPU tracking on this codepath
                
                if ispc
                  qstr = 'GPU tracking on Windows currently unsupported. Perform tracking on CPU?';
                else
                  qstr = 'No GPUs available with sufficient RAM locally. Perform tracking on CPU?';
                end
                tstr = 'GPU Tracking Unavailable';
                btn = questdlg(qstr,tstr,'Yes','No/Cancel','Yes');
                if isempty(btn)
                  btn = 'No/Cancel';
                end
                switch btn
                  case 'Yes'
                    isMultiViewTrack = true;
                  case 'No/Cancel'
                    %warndlg('No GPUs available with sufficient RAM locally','Error tracking','modal');
                    return;
                end
              elseif numel(gpuids) < obj.lObj.nview,
                isMultiViewTrack = true;
              else
                isMultiViewTrack = false;
              end
            end
          end
          
          args = {'isMultiView',isMultiViewTrack};
          if isempty(gpuids)
            args = [args {'isgpu' false}];
          end
          
          if isexternal,
            if obj.lObj.hasTrx,
              args = [args,{'trxfiles',trxfiles,'targets',targets}];
            end
            tfSuccess = obj.trkSpawnBsubDocker(backend,[],[],dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'movfiles',movfiles,'trkfiles',trkfiles,'gpuids',gpuids,args{:});
          else
            tfSuccess = obj.trkSpawnBsubDocker(backend,mIdx,tMFTConc,dlLblFileLcl,...
              cropRois,hmapArgs,f0,f1,'gpuids',gpuids,args{:});
          end
          if ~tfSuccess,
            obj.bgTrkReset();
            return;
          end

        case DLBackEnd.AWS
          if isexternal,
            error('Not implemented');
          else
            obj.trkSpawnAWS(backend,mIdx,tMFTConc,dlLblFileLcl,cropRois,hmapArgs,f0,f1);
          end
        otherwise
          assert(false);
      end
    end
    
    function tfSuccess = trackListFile(obj,listfiles,outfiles)
      
      be = obj.lObj.trackDLBackEnd;
      if be.type~=DLBackEnd.Bsub
        error('Currently only supported for JRC Cluster backend.');
      end
      
      if obj.bgTrnIsRunning
        % Could probably support, but training currently does a
        % "rolling-cleanout" and this track could take a while, plus, like
        % why.
        error('Unsupported while training is in progress.');
      end

      if isempty(obj.trnName)
        error('No trained tracker found.');
      end
      
      % we don't check/update params from Labeler here
      if ~strcmp(obj.sPrmAll.ROOT.PostProcess.reconcile3dType,'none')
        msg = '3D reconciliation is currently not supported for external movie tracking. Tracking results will not be postprocessed or reconciled in 3D. '
        warningNoTrace(msg);
      end      

      listfiles = cellstr(listfiles);
      outfiles = cellstr(outfiles);
      nview = obj.lObj.nview;
      assert(isequal(nview,numel(listfiles),numel(outfiles)));
            
      lclCacheDir = obj.lObj.DLCacheDir;
      
      dmc = obj.trnLastDMC;
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(lclCacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      assert(exist(dlLblFileLcl,'file')>0,...
        'Can''t find stripped lbl file: %s\n',dlLblFileLcl);
      
      % What /deepnet code are we running
      %[dmc.aptRootUser] = deal([]);
      if be.deepnetrunlocal
        aptroot = APT.Root;
        %[dmc.aptRootUser] = deal(aptroot);
        DeepTracker.downloadPretrainedExec(aptroot);
      else
        DeepTracker.cloneJRCRepoIfNec(cacheDir);
        DeepTracker.updateAPTRepoExecJRC(cacheDir);
        aptroot = [cacheDir '/APT'];
      end      
      
      baseargs = {'deepnetroot' [aptroot '/deepnet']}; 
      
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      modelChainID = obj.trnName;
      [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
 
      % info for code-generation. for now we just record a struct so we can
      % more conveniently read logfiles etc. in future this could be an obj
      % that has a codegen method etc.
      trksysinfo = struct(...
        'listfile',listfiles(:),...
        'outfile',outfiles(:),...
        'trnstr',trnstrs(:),...
        'modelfile',modelFiles(:),...
        'logfile',[],...
        'errfile',[],...
        'snapshotfile',[],...
        'codestr',[]);
      for ivw=1:nview
                 
        % trkfile, outfile
        trkoutdir = dmc(ivw).dirTrkOutLnx;
        if exist(trkoutdir,'dir')==0
          [succ,msg] = mkdir(trkoutdir);
          if ~succ
            error('Failed to create trk cache dir %s: %s',trkoutdir,msg);
          else
            fprintf(1,'Created trk output dir: %s\n',trkoutdir);
          end
        end
        
        [~,listfileS,~] = myfileparts(trksysinfo(ivw).listfile);
        trnstr = trksysinfo(ivw).trnstr;
        logfile = fullfile(trkoutdir,[listfileS '_' trnstr '_' nowstr '.log']);
        errfile = fullfile(trkoutdir,[listfileS '_' trnstr '_' nowstr '.err']);
        ssfile  = fullfile(trkoutdir,[listfileS '_' trnstr '_' nowstr '.aptsnapshot']);     

        baseargsaug = [baseargs {'model_file' trksysinfo(ivw).modelfile}];
        
        bsubargs = {'outfile' logfile};
        sshargs = {};
        trksysinfo(ivw).logfile = logfile;
        trksysinfo(ivw).errfile = errfile;
        trksysinfo(ivw).snapshotfile = ssfile;
        
        singBind = obj.genContainerMountPath('aptroot',aptroot);
        singargs = {'bindpath',singBind};
        
        repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
        repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,trksysinfo(ivw).snapshotfile);
        prefix = [DeepTracker.jrcprefix '; ' repoSScmd];        
        sshargsuse = [sshargs {'prefix' prefix}];
        
        trksysinfo(ivw).codestr = DeepTracker.trackCodeGenListFileSSHBsubSing(...
          modelChainID,dmc(ivw).rootDir,dmc(ivw).lblStrippedLnx,...
          errfile,obj.trnNetType,ivw,...
          trksysinfo(ivw).outfile,trksysinfo(ivw).listfile,...
          'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
          'sshargs',sshargsuse);
      end
            
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.codestr),...
          trksysinfo);
        tfSuccess = true;
      else
        tfSuccess = true;
        for ivw=1:nview
          fprintf(1,'%s\n',trksysinfo(ivw).codestr);
          [st,res] = system(trksysinfo(ivw).codestr);
          if st==0
            fprintf('Tracking job (view %d) spawned:\n%s\n',ivw,res);
          else
            fprintf(2,'Failed to spawn tracking job for view %d: %s.\n\n',...
              ivw,res);
            tfSuccess = false;
            return;
          end
        end
        obj.trkSysInfo = trksysinfo;
      end
    end
    
    function [tfCanTrack,reason] = canTrack(obj)
      tfCanTrack = false;
      reason = '';
      
      if obj.bgTrkIsRunning
        reason = 'Tracking is already in progress.';
        return;
      end
      
      % For now we do this check here even though the actual parfeval() 
      % call for the tracking monitor is made in downstream code.
      p = gcp;
      nrun = numel(p.FevalQueue.RunningFutures);
      if nrun>=p.NumWorkers
        reason = 'Parallel pool is full. Cannot spawn tracking monitor.';
        return;
      end

      % check trained tracker
      if isempty(obj.trnName)
        reason = 'No trained tracker found.';
        return;
      end
      
      if isempty(obj.sPrmAll),
        reason = 'Training parameters not set.';
        return;
      end

      cacheDir = obj.lObj.DLCacheDir;
      if isempty(cacheDir)
        reason = 'Cache directory not set.';
        return;
      end
      
      backend = obj.lObj.trackDLBackEnd;
      [tf,reasonbackend] = backend.getReadyTrainTrack();
      if ~tf
        reason = reasonbackend;
        return;
      end
            
      dmc = obj.trnLastDMC;
      for i=1:numel(dmc)
        if ~dmc(i).isRemote && ~strcmp(dmc(i).rootDir,cacheDir)
          reason = 'Cache directory has changed since training.';
          return;
        end
      end
      
      dmcLcl = dmc.copy();
      [dmcLcl.rootDir] = deal(cacheDir);
      dlLblFileLcl = unique({dmcLcl.lblStrippedLnx});
      assert(isscalar(dlLblFileLcl));
      dlLblFileLcl = dlLblFileLcl{1};
      if exist(dlLblFileLcl,'file')==0
        reason = sprintf('Cannot find training file: %s\n',dlLblFileLcl);
        return;
      end
      
      tfCanTrack = true;      
    end
    
    function tfSuccess = trkSpawnBsubDocker(obj,backend,mIdx,tMFTConc,dlLblFile,...
        cropRois,hmapArgs,frm0,frm1,varargin)
      
      tfSuccess = false;

      [movs,trxfiles,trxids,trkfiles,isgpu,gpuids,isMultiView] = ...
        myparse(varargin,...
        'movfiles',{},...
        'trxfiles',{},...
        'targets',[],...
        'trkfiles',{},...
        'isgpu',true,...
        'gpuids',[],...
        'isMultiView',false);
      
      % Prob need some refactor here possibly along with upstream in 
      % track(). Major branches: isexternal, {bsub x docker}, isMultiView. 
      %
      % One idea, first step is to generate "jobs" data structure that
      % specifies movs/trxs/tgts/etc to be tracked in each job, in some std
      % format, whether job is to be run on local or remote GPUs. There may
      % be multiple jobs-specification convenience methods, eg accepting 
      % either a tblMFT, separate movs/trxfiles/trxids, etc.
      %
      % With jobs-specification factored out, maybe then take a jobs-spec 
      % and a backend, and perform: codegen, job-spawning, monitor launching.
      
      isexternal = ~isempty(movs);

      % Currently mIdx, tMFTConc only one movie

      cacheDir = obj.lObj.DLCacheDir;

      % put/ensure local stripped lbl
      dmc = obj.trnLastDMC;
      assert(isscalar(unique({dmc.lblStrippedLnx})));
      dlLblFile = dmc(1).lblStrippedLnx; 
      if exist(dlLblFile,'file')==0
        error('Cannot find stripped project file: %s\n',dlLblFile);
      end
      
      nView = obj.lObj.nview;
      if isexternal,
        nMovies = size(movs,1);
      else
        nMovies = 1;
      end
      if isMultiView,
        nViewJobs = 1;
      else
        nViewJobs = nView;
      end
      if ~isempty(gpuids),
        assert(numel(gpuids) == nViewJobs*nMovies);
        gpuids = reshape(gpuids,[nMovies,nViewJobs]);
      end
      
      %[dmc.aptRootUser] = deal([]);
      
      switch backend.type
        case DLBackEnd.Bsub
          if backend.deepnetrunlocal
            aptroot = APT.Root;
            %[dmc.aptRootUser] = deal(aptroot);
            %DeepTracker.downloadPretrainedExec(aptroot);
            DeepTracker.cpupdatePTWfromJRCProdExec(aptroot);
          else
            DeepTracker.cloneJRCRepoIfNec(cacheDir);
            DeepTracker.updateAPTRepoExecJRC(cacheDir);
            aptroot = [cacheDir '/APT'];
          end
          hmapArgs = [hmapArgs {'deepnetroot' [aptroot '/deepnet']}]; 
        case DLBackEnd.Docker
        case DLBackEnd.Conda
      end
      
      %obj.downloadPretrainedWeights();
      
      tftrx = obj.lObj.hasTrx;
            
      if isexternal,
        tfcrop = ~cellfun(@isempty,cropRois);
        for i = find(tfcrop(:)'),
          szassert(cropRois{i},[nView 4]);
        end
        assert(size(movs,2) == nView);
        mIdx = {movs,trxfiles};
      else
        tfcrop = ~isempty(cropRois);
        if tfcrop
          szassert(cropRois,[nView 4]);
          cropRois = {cropRois};
        end
        movs = tMFTConc.mov;
        assert(size(movs,2)==nView);
        movs = movs(1,:);
      end
      nowstr = datestr(now,'yyyymmddTHHMMSS');
      modelChainID = obj.trnName;
      [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
      %trnstr = sprintf('trn%s',modelChainID);
      
      % info for code-generation. for now we just record a struct so we can
      % more conveniently read logfiles etc. in future this could be an obj
      % that has a codegen method etc.
      trksysinfo = struct(...
        'trkfile',cell(nMovies,nViewJobs),...
        'logfile',[],...
        'errfile',[],...
        'snapshotfile',[],...
        'codestr',[]);
      for imov = 1:nMovies,
        
        for ivwjob = 1:nViewJobs,
          
          if isMultiView,
            ivw = 1:nView;
          else
            ivw = ivwjob;
          end
          
          % base args
          baseargsaug = hmapArgs;
          modelFile = cellSelectHelper(modelFiles,ivw);
          baseargsaug = [baseargsaug {'model_file' modelFile}]; %#ok<AGROW>
          if tfcrop(imov)
            baseargsaug = [baseargsaug {'croproi' cropRois{imov}(ivw,:)}]; %#ok<AGROW>
          end
          if ~isMultiView,
            baseargsaug = [baseargsaug {'view' ivw}]; %#ok<AGROW> % 1-based OK
          end
          if tftrx
            if isexternal,
              trxfile = cellSelectHelper(trxfiles,imov,ivw);
              trxids_curr = trxids{imov};
            else
              trxids_curr = unique(tMFTConc.iTgt);
              trxids = trxids_curr;
              if isMultiView,
                trxfile = cell(1,nView);
                for ivw1 = 1:nView,
                  trxfilecurr = unique(tMFTConc.trxFile(:,ivw1));
                  assert(isscalar(trxfilecurr));
                  trxfile{ivw1} = trxfilecurr{1};
                end
              else
                trxfile = unique(tMFTConc.trxFile(:,ivw));
                assert(isscalar(trxfile));
                trxfile = trxfile{1};
              end
            end
            baseargsaug = [baseargsaug {'trxtrk' trxfile 'trxids' trxids_curr}]; %#ok<AGROW>
          else
            trxids = [];
          end
          frm0_curr = frm0;
          frm1_curr = frm1;
          if isexternal,
            if numel(frm0) >= imov,
              frm0_curr = frm0(imov);
              frm1_curr = frm1(imov);
            else
              frm0_curr = [];
              frm1_curr = [];
            end
          end
          
          % trkfile, outfile
          if isMultiView,
            trkoutdir = cell(1,nView);
            if isexternal,
              trkfile = trkfiles(imov,:);
            else
              trkfile = cell(1,nView);
            end
            for ivw1 = 1:nView,
              trkoutdir{ivw1} = dmc(ivw1).dirTrkOutLnx;
              if exist(trkoutdir{ivw1},'dir')==0
                [succ,msg] = mkdir(trkoutdir{ivw1});
                if ~succ
                  error('Failed to create trk cache dir %s: %s',trkoutdir{ivw1},msg);
                else
                  fprintf(1,'Created trk output dir: %s\n',trkoutdir{ivw1});
                end
              end
              if ~isexternal,
                mov = movs{imov,ivw1};
                trnstr = trnstrs{ivw1};
                [~,movS] = fileparts(mov);
                defaulttrkfile = fullfile(trkoutdir{ivw1},[movS '_' trnstr '_' nowstr '.trk']);
                trkfile{ivw1} = defaulttrkfile;
              end
            end
          else
            trkoutdir = dmc(ivw).dirTrkOutLnx;
            if exist(trkoutdir,'dir')==0
              [succ,msg] = mkdir(trkoutdir);
              if ~succ
                error('Failed to create trk cache dir %s: %s',trkoutdir,msg);
              else
                fprintf(1,'Created trk output dir: %s\n',trkoutdir);
              end
            end
            
            if isexternal,
              trkfile = trkfiles{imov,ivw};
            else
              mov = movs{imov,ivw};
              trnstr = trnstrs{ivw};
              [~,movS] = fileparts(mov);
              defaulttrkfile = fullfile(trkoutdir,[movS '_' trnstr '_' nowstr '.trk']);
              trkfile = defaulttrkfile;
            end
            
          end
          mov = movs{imov,ivwjob};
          trnstr = trnstrs{ivwjob};
          [~,movS] = fileparts(mov);
          if isMultiView,
            trkoutdir1 = trkoutdir{ivwjob};
          else
            trkoutdir1 = trkoutdir;
          end
          
          if isexternal,
            outfile = fullfile(trkoutdir1,[movS '_' trnstr '_' nowstr sprintf('_mov%d',imov) '.log']);
            errfile = fullfile(trkoutdir1,[movS '_' trnstr '_' nowstr sprintf('_mov%d',imov) '.err']);
            containerName = [movS '_' trnstr '_' nowstr sprintf('_mov%d',imov)];
          else
            outfile = fullfile(trkoutdir1,[movS '_' trnstr '_' nowstr '.log']);
            errfile = fullfile(trkoutdir1,[movS '_' trnstr '_' nowstr '.err']);
            containerName = [movS '_' trnstr '_' nowstr];
          end
          ssfile = fullfile(trkoutdir1,[movS '_' trnstr '_' nowstr '.aptsnapshot']);
          %outfile2 = fullfile(movP,[movS '_' trnstr '_' nowstr '.log2']);
          if isMultiView,
            for ivw1 = 1:nView,
              fprintf('View %d: trkfile will be written to %s\n',ivw1,trkfile{ivw1});
            end
          else
            fprintf('View %d: trkfile will be written to %s\n',ivw,trkfile);
          end
          
          bsubargs = {'nslots' obj.jrcnslots 'gpuqueue' obj.jrcgpuqueue 'outfile' outfile};
          %sshargs = {'logfile' outfile2};
          sshargs = {};
          trksysinfo(imov,ivwjob).trkfile = trkfile;
          trksysinfo(imov,ivwjob).logfile = outfile;
          trksysinfo(imov,ivwjob).errfile = errfile;
          trksysinfo(imov,ivwjob).snapshotfile = ssfile;
          if iscell(trkfile),
            trksysinfo(imov,ivwjob).parttrkfile = cellfun(@(x) [x,'.part'],trkfile,'Uni',0);
          else
            trksysinfo(imov,ivwjob).parttrkfile = [trkfile,'.part'];
          end
          
          parttrkfiles = trksysinfo(imov,ivwjob).parttrkfile;
          if ~iscell(parttrkfiles),
            parttrkfiles = {parttrkfiles};
          end
          
          for ivw1 = 1:numel(parttrkfiles),
            if exist(parttrkfiles{ivw1},'file'),
              fprintf('Deleting partial tracking result %s',parttrkfiles{ivw1});
              try
                delete(parttrkfiles{ivw1});
              catch ME,
                warning('Failed to delete %s: %s',parttrkfiles{ivw1},getReport(ME));
              end
            end
          end
          
          %trksysinfo(ivw).logfilessh = outfile2;
          
          %mov = cellSelectHelper(movs,ivw);
          
          % make sure movie to be tracked is on path
          movdir = fileparts(mov);
          trkdir = fileparts(trkfile);
          extradirs = {};
          if ~isempty(movdir),
            extradirs{end+1} = movdir;
          end
          if ~isempty(trkdir),
            extradirs{end+1} = trkdir;
          end
          
          switch backend.type
            case DLBackEnd.Bsub
              singBind = obj.genContainerMountPath('aptroot',aptroot,'extra',extradirs); % HERE
              singargs = {'bindpath',singBind};
              
              repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
              repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,trksysinfo(imov,ivwjob).snapshotfile);
              prefix = [DeepTracker.jrcprefix '; ' repoSScmd];
              
              sshargsuse = [sshargs {'prefix' prefix}];
              trksysinfo(imov,ivwjob).codestr = DeepTracker.trackCodeGenSSHBsubSing(...
                modelChainID,dmc(ivwjob).rootDir,dlLblFile,errfile,obj.trnNetType,...
                mov,trkfile,frm0_curr,frm1_curr,...
                'baseargs',baseargsaug,'singArgs',singargs,'bsubargs',bsubargs,...
                'sshargs',sshargsuse);
              
            case DLBackEnd.Docker
              singBind = obj.genContainerMountPath();
              if isgpu
                dockerargs = {};
                if isempty(gpuids),
                  % none
                else
                  dockerargs = [dockerargs {'gpuid',gpuids(imov,ivwjob)}]; %#ok<AGROW>
                end
              else
                dockerargs = {'isgpu' false 'dockerimg' 'bransonlabapt/apt_docker:latest_cpu'};
              end
              useLogFlag = ispc;
              if useLogFlag
                baseargsaug = [baseargsaug {'log_file' outfile}]; %#ok<AGROW>
              end
              [trksysinfo(imov,ivwjob).codestr,trksysinfo(imov,ivwjob).containerName] = ...
                DeepTracker.trackCodeGenDocker(backend,...
                  modelChainID,dmc(ivwjob).rootDir,dlLblFile,errfile,obj.trnNetType,...
                  mov,trkfile,frm0_curr,frm1_curr,...
                  'baseargs',baseargsaug,'mntPaths',singBind,'containerName',containerName,...
                  'dockerargs',dockerargs);
              if useLogFlag
                trksysinfo(imov,ivwjob).logcmd = [];
              else
                trksysinfo(imov,ivwjob).logcmd = sprintf('%s logs -f %s &> "%s" &',...
                  obj.dockercmd,trksysinfo(imov,ivwjob).containerName,...
                  outfile);
              end
            case DLBackEnd.Conda
              condaargs = {'condaEnv',obj.condaEnv};
              if ~isempty(gpuids),
                condaargs(end+1:end+2) = {'gpuid',gpuids(imov,ivwjob)};
              end
              [trksysinfo(imov,ivwjob).codestr] = ...
                DeepTracker.trackCodeGenConda(...
                modelChainID,dmc(ivwjob).rootDir,dlLblFile,errfile,obj.trnNetType,...
                mov,trkfile,frm0_curr,frm1_curr,...
                'baseargs',[baseargsaug,{'filesep',obj.filesep}],...
                'outfile',outfile,...
                'condaargs',condaargs);
          end
        end
      end
            
      if obj.dryRunOnly
        arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.codestr),...
          trksysinfo);
        tfSuccess = true;
        return;
      end
      % start track monitor
      assert(isempty(obj.bgTrkMonitor));
      
      logfiles = reshape({trksysinfo.logfile},size(trksysinfo));
      errfiles = reshape({trksysinfo.errfile},size(trksysinfo));
      if isMultiView,
        outfiles = reshape(cat(1,trksysinfo.trkfile),[nMovies,nView]);
        partfiles = reshape(cat(1,trksysinfo.parttrkfile),[nMovies,nView]);        
      else
        outfiles = reshape({trksysinfo.trkfile},size(trksysinfo));
        partfiles = reshape({trksysinfo.parttrkfile},size(trksysinfo));
      end
      switch backend.type
        case DLBackEnd.Bsub
          bgTrkWorkerObj = BgTrackWorkerObjBsub(nView,dmc);
        case DLBackEnd.Conda,
          bgTrkWorkerObj = BgTrackWorkerObjConda(nView,dmc);
        case DLBackEnd.Docker,
          bgTrkWorkerObj = BgTrackWorkerObjDocker(nView,dmc);
      end
      % working here -- make this work with multiple movies
      bgTrkWorkerObj.initFiles(mIdx,movs,outfiles,...
        logfiles,errfiles,partfiles);
      
      tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
      if any(tfErrFileErr)
        error('There is an existing error in an error file: ''%s''.',...
          String.cellstr2CommaSepList(errfiles));
      end
      
      bgTrkMonitorObj = BgTrackMonitor;
      
      % KB 20190115: adding trkviz
      %nvw = obj.lObj.nview;
      % figure out how many frames are to be tracked
      %nFramesTrack = size(tMFTConc,1); % this is inaccurate
      nFramesTrack = obj.getNFramesTrack(tMFTConc,mIdx,frm0,frm1,trxids);
      fprintf('Requested to track %d frames, through interface will track %d frames.\n',size(tMFTConc,1),nFramesTrack)
      
      trkVizObj = feval(obj.bgTrkMonitorVizClass,nView,obj,bgTrkWorkerObj,backend.type,nFramesTrack);
      bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,@obj.trkCompleteCbk);
      
      addlistener(bgTrkMonitorObj,'bgStart',@(s,e)obj.notify('trackStart'));
      addlistener(bgTrkMonitorObj,'bgEnd',@(varargin) obj.trackStoppedCbk(varargin{:})); % AL partially dups stuff in .trkCompleteCbk
      
      %bgTrkMonitorObj.prepare(bgTrkWorkerObj,@obj.trkCompleteCbk);
      obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);
      
      % spawn jobs
      tfSuccess = true;
      for imov = 1:nMovies,
        for ivwjob=1:nViewJobs,
            
          fprintf(1,'%s\n',trksysinfo(imov,ivwjob).codestr);
          if backend.type == DLBackEnd.Conda,
            [job,st,res] = parfevalsystem(trksysinfo(imov,ivwjob).codestr);
          else
            [st,res] = system(trksysinfo(imov,ivwjob).codestr);
          end
          if st==0
            if backend.type == DLBackEnd.Conda,
              bgTrkWorkerObj.parseJobID(job,ivwjob,imov);
            else
              bgTrkWorkerObj.parseJobID(res,ivwjob,imov);
            end
            fprintf('Tracking job (movie %d, job %d) spawned:\n%s\n',imov,ivwjob,res);
          else
            fprintf(2,'Failed to spawn tracking job for movie %d, job %d: %s.\n\n',...
              imov,ivwjob,res);
            tfSuccess = false;
            return;
          end
          switch backend.type,
            case DLBackEnd.Docker,
              logcmd = trksysinfo(imov,ivwjob).logcmd;
              if ~isempty(logcmd)
                [st,res] = system(logcmd);
                if st~=0,
                  fprintf(2,'Error logging docker job %s: %s\n',...
                    trksysinfo(imov,ivwjob).containerName,res);
                  tfSuccess = false;
                  return;
                end
              end
          end
        end
      end
        
      obj.trkSysInfo = trksysinfo;
    end
    function nframes = getNFramesTrack(obj,tMFTConc,mIdx,frm0,frm1,trxids)
      
      isexternal = iscell(mIdx);
      if isexternal,

        movs = mIdx{1};
        trxfiles = mIdx{2};
        [nMovies,nViews] = size(movs);
        nframes = nan(nMovies,1);
        for imov = 1:nMovies,
          nfrm = MovieReader.getNFrames(movs{imov,1});
          if numel(frm0) < imov,
            frm0(imov) = 1;
            frm1(imov) = nfrm;
          end
          if frm0(imov) < 1 || frm1(imov) > nfrm || frm0(imov) > frm1(imov),
            error('Bad values for frm0 and frm1. Required: 1 <= frm0 <= frm1 <= nfrm=%d',nfrm);
          end
          if isempty(trxfiles),
            nframes(imov) = frm1(imov)-frm0(imov)+1;
          else
            [~,frm2trx] = obj.lObj.getTrx(trxfiles{imov,1},nfrm);
            if isempty(trxids{imov}),
              trxids{imov} = 1:size(frm2trx,2);
            end
            nframes(imov) = sum(sum(frm2trx(frm0(imov):frm1(imov),trxids{imov})));
          end
        end
        
      else
        
        if isempty(trxids),
          nframes = frm1-frm0+1;
        else
          if mIdx == obj.lObj.currMovIdx,
            frm2trx = obj.lObj.frm2trx;
          else
            iMov = double(mIdx);
            nfrm = obj.lObj.movieInfoAllGTaware{iMov,1}.nframes;
            trxFile = obj.lObj.trxFilesAllFullGTaware{mIdx,1};
            [~,frm2trx] = obj.lObj.getTrx(trxFile,nfrm);
          end
          nframes = sum(sum(frm2trx(frm0:frm1,trxids)));
        end
      end
    end

  end
  methods (Static)
    function sha = getSHA(file)
      if ismac
        file = strrep(file,' ','\ ');
        shacmd = sprintf('MD5 %s',file);
        [~,res] = AWSec2.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        res = strtrim(res);
        toks = regexp(res,' ','split');
        sha = toks{end};        
        sha = regexprep(sha,' ','');          
      elseif isunix
        file = strrep(file,' ','\ ');
        shacmd = sprintf('md5sum %s',file);
        [~,res] = AWSec2.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,' ','split');
        sha = toks{1};        
        sha = regexprep(sha,' ','');
      else
        shacmd = sprintf('certUtil -hashFile "%s" MD5',file);
        [~,res] = AWSec2.syscmd(shacmd,'dispcmd',true,'failbehavior','err');
        toks = regexp(res,'\n','split');
        sha = toks{2};
        sha = regexprep(sha,' ','');
      end
    end
  end
  methods
    function trkSpawnAWS(obj,backend,mIdx,tMFTConc,dlLblFileLcl,cropRois,...
        hmapArgs,frm0,frm1)
      % Currently mIdx, tMFTConc only one movie
      
      nvw = obj.lObj.nview;
      aws = backend.awsec2;
      aws.checkInstanceRunning(); % harderrs if instance isn't running

      % needed to move this earlier
%       if isempty(obj.deepnetgitbranch)
%         args = {};
%       else
%         args = {'updateCmdArgs' {'branch' obj.deepnetgitbranch}};
%       end
%       DeepTracker.updateAPTRepoExecAWS(aws,args{:}); % prob shouldn't update relative to train...
      
      % put/ensure remote stripped lbl
      dmc = obj.trnLastDMC;
      dlLblFileRemote = dmc(1).lblStrippedLnx;
      assert(all(strcmp({dmc.lblStrippedLnx},dlLblFileRemote)));
      aws.scpUploadOrVerifyEnsureDir(dlLblFileLcl,dlLblFileRemote,'training file');
            
      %trkdirRemoteFull = aws.ensureRemoteDir('trk','descstr','trk');
      datadirRemoteFull = aws.ensureRemoteDir('data','descstr','data');
      % should prob get these from tMFTConc
      assert(isscalar(mIdx));
      movsfull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      trxsfull = obj.lObj.getTrxFilesAllFullMovIdx(mIdx);
      tftrx = obj.lObj.hasTrx;
      if tftrx
        assert(nvw==1,...
          'Multiview projects with trajectory (trx) currently unsupported for tracking on AWS.');
      end
      tfcrop = ~isempty(cropRois);
      if tfcrop
        szassert(cropRois,[nvw 4]);
      end
      
      iterCurrs = [dmc.iterCurr];
      if numel(unique(iterCurrs))>1
        warningNoTrace('Current models have differing number of training iterations.');
      end
      [trnstrs,modelFiles] = obj.getTrkFileTrnStr();
      
      % gen trkfilelocal/remote. upload trkfiles. create local trkdirs.
      trksysinfo = struct(...
        'modelfile',cell(nvw,1),...
        'movlocal',[],...
        'movremote',[],...
        'trkfilelocal',[],...
        'trkfileremote',[],...
        'parttrkfilelocal',[],...
        'parttrkfileremote',[],...
        'trxlocal',[],...
        'trxremote',[],...
        'logfile',[],...
        'errfile',[]...
        );      
      for ivw=1:nvw        
        % upload mov/trx as nec
        mov = movsfull{ivw};
        [~,~,movE] = fileparts(mov);
        movsha = DeepTracker.getSHA(mov);
        movRemoteRel = ['data/' movsha movE];
        movRemoteAbs = ['/home/ubuntu/' movRemoteRel];
        aws.scpUploadOrVerify(mov,movRemoteRel,'movie'); % throws            
        if tftrx
          trx = trxsfull{ivw};
          trxsha = DeepTracker.getSHA(trx);
          trxRemoteRel = ['data/' trxsha];
          trxRemoteAbs = ['/home/ubuntu/' trxRemoteRel];
          aws.scpUploadOrVerify(trx,trxRemoteRel,'trxfile'); % throws            
        end
        
        % trk/log names, local and remote
        nowstr = datestr(now,'yyyymmddTHHMMSS');
        modelChainID = obj.trnName;
        
        trkdirRemote = dmc(ivw).dirTrkOutLnx;
        aws.ensureRemoteDir(trkdirRemote,'relative',false,'descstr','trk');
        dmcLcl = dmc(ivw).copy();
        dmcLcl.rootDir = obj.lObj.DLCacheDir;
        trkdirLocal = dmcLcl.dirTrkOutLnx;
        if exist(trkdirLocal,'dir')==0
          [succ,msg] = mkdir(trkdirLocal);
          if ~succ
            error('Failed to create local trk cache dir %s: %s',trkdirLocal,msg);
          else
            fprintf(1,'Created local trk cache dir: %s\n',trkdirLocal);
          end
        end
      
        [~,movS,movE] = myfileparts(mov);
        trnstr = trnstrs{ivw};
        trkLocalRel = [movS '_' trnstr '_' nowstr '.trk'];
        trkRemoteRel = [movsha '_' trnstr '_' nowstr];
        trkLocalAbs = fullfile(trkdirLocal,trkLocalRel);
        trkRemoteAbs = [trkdirRemote '/' trkRemoteRel '.trk'];
        logfileRemoteAbs = [trkdirRemote '/' trkRemoteRel '.log'];
        errfileRemoteAbs = [trkdirRemote '/' trkRemoteRel '.err'];
        
        trksysinfo(ivw).modelfile = modelFiles{ivw};
        trksysinfo(ivw).movlocal = mov;
        trksysinfo(ivw).movremote = movRemoteAbs;        
        trksysinfo(ivw).trkfilelocal = trkLocalAbs;
        trksysinfo(ivw).trkfileremote = trkRemoteAbs;
        trksysinfo(ivw).parttrkfilelocal = [trkLocalAbs,'.part'];
        trksysinfo(ivw).parttrkfileremote = [trkRemoteAbs,'.part'];        
        if tftrx
          trksysinfo(ivw).trxlocal = trx;
          trksysinfo(ivw).trxremote = trxRemoteAbs;
        end
        trksysinfo(ivw).logfile = logfileRemoteAbs;
        trksysinfo(ivw).errfile = errfileRemoteAbs;
      end
       
      % CodeGen
      baseargsaug = hmapArgs;
      baseargsaug = [baseargsaug {'model_file' modelFiles}];
      if tfcrop
        baseargsaug = [baseargsaug {'croproi' cropRois}];
      end
      %baseargsaug = [baseargsaug {'view' ivw}]; %#ok<AGROW> % 1-based OK
      if tftrx
        assert(nvw==1); 
        trxids = unique(tMFTConc.iTgt); 
        baseargsaug = [baseargsaug {'trxtrk' {trksysinfo.trxremote} 'trxids' trxids}];
      end
      
      if nvw>1
        assert(all(strcmp({dmc.rootDir},dmc(1).rootDir)));
      end
      rootDirRemoteAbs = dmc(1).rootDir; % common rootDir
      errfileRemoteAbs = trksysinfo(1).errfile; % multiview: single errfile/logfile
      logfileRemoteAbs = trksysinfo(1).logfile;
      trkfilesRemoteAbs = {trksysinfo.trkfileremote};
      movfilesRemoteAbs = {trksysinfo.movremote};
      codestr = DeepTracker.trackCodeGenAWS(...
        modelChainID,rootDirRemoteAbs,dlLblFileRemote,errfileRemoteAbs,...
        obj.trnNetType,...
        movfilesRemoteAbs,trkfilesRemoteAbs,frm0,frm1,baseargsaug);
      syscmd = aws.sshCmdGeneralLogged(codestr,logfileRemoteAbs);
        
      if obj.dryRunOnly
        fprintf(1,'Dry run, not tracking: %s\n',syscmd);
%         arrayfun(@(x)fprintf(1,'Dry run, not tracking: %s\n',x.syscmd),...
%           trksysinfo);
      else
        % start track monitor
        assert(isempty(obj.bgTrkMonitor));

        bgTrkWorkerObj = BgTrackWorkerObjAWS(nvw,dmc,aws);

        trkfilesLocal = {trksysinfo.trkfilelocal}';        
        logfiles = {trksysinfo.logfile}; % all identical for multiview
        errfiles = {trksysinfo.errfile}; % "
        % KB: not sure what to do with part files remote vs local yet
        partfilesRemote = {trksysinfo.parttrkfileremote};
        %partfilesLocal = {trksysinfo.parttrkfilelocal}';

        bgTrkWorkerObj.initFiles(mIdx,movsfull,...
          trkfilesRemoteAbs,logfiles,errfiles,partfilesRemote);
        
        tfErrFileErr = cellfun(@bgTrkWorkerObj.errFileExistsNonZeroSize,errfiles);
        if any(tfErrFileErr)
          error('There is an existing error in an error file: ''%s''.',...
            String.cellstr2CommaSepList(errfiles));
        end
                
        bgTrkMonitorObj = BgTrackMonitor;

        % KB 20190115: adding trkviz
        nvw = obj.lObj.nview;
        % figure out how many frames are to be tracked
        nFramesTrack = size(tMFTConc,1);

        trkVizObj = feval(obj.bgTrkMonitorVizClass,nvw,obj,bgTrkWorkerObj,...
          backend.type,nFramesTrack);   
        bgTrkMonitorObj.prepare(trkVizObj,bgTrkWorkerObj,...
          @(x)obj.trkCompleteCbkAWS(backend,trkfilesLocal,x));

        addlistener(bgTrkMonitorObj,'bgStart',@(s,e)obj.notify('trackStart'));
        addlistener(bgTrkMonitorObj,'bgEnd',@(s,e)obj.notify('trackEnd'));
        
        obj.bgTrkStart(bgTrkMonitorObj,bgTrkWorkerObj);
        
        % spawn jobs
%         for ivw=1:nvw
%           syscmd = trksysinfo(ivw).syscmd;
          fprintf(1,'%s\n',syscmd);
%           if ivw>1
%             fprintf(2,'Skipping spawn view %d\n',ivw);
%             continue;
%           end
%           
          system(syscmd);     
          fprintf('Tracking job spawned.\n\n');
%           fprintf('Tracking job (view %d) spawned.\n\n',ivw);

          pause(3.0); % Hack try to more reliably get PID
          aws.getRemotePythonPID();
        
        obj.trkSysInfo = trksysinfo;
      end
    end
    
    function trkPrintLogs(obj)
      btm = obj.bgTrkMonitor;
      if isempty(btm)
        error('Tracking is neither in progress nor complete.');
      end
      btm.bgWorkerObj.printLogfiles();
    end
    
    function bgTrkReset(obj)
      obj.trkSysInfo = [];
      if ~isempty(obj.bgTrkMonitor)
        delete(obj.bgTrkMonitor);
      end
      obj.bgTrkMonitor = [];
      if ~isempty(obj.bgTrkMonBGWorkerObj)
        delete(obj.bgTrkMonBGWorkerObj);
      end
      obj.bgTrkMonBGWorkerObj = [];
    end
    
    function bgTrkStart(obj,trkMonitorObj,trkWorkerObj)
      % fresh start new training monitor 
      % trkMonitorObj: should be 'prepared'
      
      if ~isempty(obj.bgTrkMonitor)
        error('Tracking monitor exists. Call .bgTrkReset first to stop/remove existing monitor.');
      end
      assert(isempty(obj.bgTrkMonBGWorkerObj));
      
      trkMonitorObj.start();
      obj.bgTrkMonitor = trkMonitorObj;
      obj.bgTrkMonBGWorkerObj = trkWorkerObj;
    end
    
    function trkCompleteCbk(obj,res)
      
      isexternal = iscell(res(1).mIdx) || ischar(res(1).mIdx);
      if isexternal,
        % AL: guessing here didn't test
        for i=1:numel(res)
          fprintf('Tracking complete for %s, results saved to %s.\n',...
            res(i).movfile,res(i).trkfile);
        end
        return;
      end
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        
        trkfiles = {res.trkfile}';
        obj.trkPostProcIfNec(mIdx,trkfiles);
        obj.trackResAddTrkfile(mIdx,trkfiles);
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
      
    end

    function trkCompleteCbkAWS(obj,backend,trkfilesLocal,res)
      assert(numel(trkfilesLocal)==numel(res));
 
      mIdx = [res.mIdx];
      assert(all(mIdx==mIdx(1)));
      mIdx = res(1).mIdx;
      movsFull = obj.lObj.getMovieFilesAllFullMovIdx(mIdx);
      if all(strcmp(movsFull(:),{res.movfile}'))
        % we perform this check b/c while tracking has been running in
        % the bg, the project could have been updated, movies
        % renamed/reordered etc.
        
        aws = backend.awsec2;
        
        % download trkfiles 
        sysCmdArgs = {'dispcmd' true 'failbehavior' 'err'};
        for ivw=1:numel(res)
          trkLcl = trkfilesLocal{ivw};
          trkRmt = res(ivw).trkfile;
          aws.scpDownloadOrVerify(trkRmt,trkLcl,'sysCmdArgs',sysCmdArgs); % XXX doc orVerify
        end
        
        obj.trkPostProcIfNec(mIdx,trkfilesLocal);
        obj.trackResAddTrkfile(mIdx,trkfilesLocal);
        if mIdx==obj.lObj.currMovIdx
          obj.trackCurrResUpdate();
          obj.newLabelerFrame();
          fprintf('Tracking complete for current movie at %s.\n',datestr(now));
        else
          iMov = mIdx.get();
          fprintf('Tracking complete for movie %d at %s.\n',iMov,datestr(now));
        end
      else
        warningNoTrace('Tracking complete, but movieset %d has changed in current project.',...
          int32(mIdx));
        % conservative, take no action for now
      end
    end

    function trkPostProcIfNec(obj,mIdx,trkfiles,varargin) % obj const
      % When appropriate, perform postprocessing and re-save trkfiles in
      % place.
      
      pp3dtype = myparse(varargin,...
        'pp3dtype',obj.sPrmAll.ROOT.PostProcess.reconcile3dType ...
        );
      
      do3dreconcile = ~strcmp(pp3dtype,'none');      
      nvw = obj.lObj.nview;
      %npts = obj.lObj.nPhysPoints;
      
      if do3dreconcile && nvw==2
        vcd = obj.lObj.getViewCalibrationDataMovIdx(mIdx);
        if isempty(vcd)
          moviestr = obj.lObj.moviePrettyStr(mIdx);
          warningNoTrace('Cannot perform 3D postprocessing; calibration data unset for %s.',moviestr);
          return;
        end
          
        assert(numel(trkfiles)==nvw);
        
        [trks,tfsucc] = ...
          cellfun(@(x)DeepTracker.hlpLoadTrk(x,'rawload',true),trkfiles,'uni',0);
        tfsucc = cell2mat(tfsucc);
        if ~all(tfsucc)
          ivwFailed = find(~tfsucc);
          ivwFailedStr = num2str(ivwFailed(:)');
          warningNoTrace('Cannot perform 3D postprocessing; could not load trkfiles for views: %s.',ivwFailedStr);
          return;
        end
        
        trk1 = trks{1};
        trk2 = trks{2};                
        rois = obj.lObj.getMovieRoiMovIdx(mIdx);
        
        try
          [trk1save,trk2save] = PostProcess.triangulate(trk1,trk2,...
            rois,vcd,pp3dtype);
        catch ME
          warningNoTrace('3d postprocessing failed: %s',ME.getReport());
          return;
        end
        
        save(trkfiles{1},'-append','-struct','trk1save');
        fprintf(1,'Saved/appended variables ''pTrkSingleView'', ''pTrk'', ''pTrk3d'' to trkfile %s.\n',...
          trkfiles{1});
        save(trkfiles{2},'-append','-struct','trk2save');
        fprintf(1,'Saved/appended variables ''pTrkSingleView'', ''pTrk'', to trkfile %s.\n',...
          trkfiles{2});
      end
    end

    function trainStoppedCbk(obj,varargin)
      obj.trainCleanup();
      obj.notify('trainEnd');
    end
    
    function trackStoppedCbk(obj,varargin)
      obj.trackCleanup();
      obj.notify('trackEnd');
    end

    function trackCleanup(obj,varargin)
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
    
    function trainCleanup(obj,varargin)

      if obj.bgTrkIsRunning,
        fprintf('Stopping tracking...\n');
        obj.bgTrkMonitor.stop();
        obj.bgTrkMonitor.reset();
        assert(~obj.bgTrkIsRunning);
      end

      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
      
      % are there tracking results from previous trackers? TODO This can be
      % moved under bgTrnIsRunning at some point, but right now there can
      % be mixed up tracking results, so let's always check. 
      isCurr = obj.checkTrackingResultsCurrent();
      if ~isCurr,
        
        res = questdlg('Tracking results exist for previous deep trackers. Delete these or retrack these frames?','Previous tracking results exist','Delete','Retrack','Delete');
        obj.cleanOutOfDateTrackingResults(isCurr);
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
        if strcmpi(res,'Retrack'),
          tblMFTRetrack = obj.getTrackedMFT();
          obj.track(tblMFTRetrack);
        end

      end
      
      % completed/stopped training. old tracking results are deleted/updated, so trackerInfo should be updated
      obj.updateTrackerInfo();
      
      res = questdlg(sprintf('Training stopped after %d / %d iterations. Save trained model to file?',...
        obj.trackerInfo.iterCurr,obj.trackerInfo.iterFinal),'Save?','Save','Save as...','No','Save');
      if strcmpi(res,'Save'),
        obj.lObj.projSaveSmart();
        obj.lObj.projAssignProjNameFromProjFileIfAppropriate();
      elseif strcmpi(res,'Save as...'),
        obj.lObj.projSaveAs();
        obj.lObj.projAssignProjNameFromProjFileIfAppropriate();
      end
      
    end
    
    function [trnstrs,modelFiles] = getTrkFileTrnStr(obj)
      % AL: odd method name
      
      obj.updateLastDMCsCurrInfo();
      
      trnstrs = cell(size(obj.trnLastDMC));
      modelFiles = cell(size(obj.trnLastDMC));
      for i = 1:numel(obj.trnLastDMC),
        trnstrs{i} = sprintf('trn%s_iter%d',obj.trnName,obj.trnLastDMC(i).iterCurr);
        modelFiles{i} = obj.trnLastDMC(i).trainCurrModelLnx;
        modelFiles{i} = regexprep(modelFiles{i},'\.index$','');
      end
    end
    
  end
  methods (Static) % train/track codegen
    
    function downloadPretrainedWeights(varargin) 
      aptroot = myparse(varargin,...
        'aptroot',APT.Root...
        );
      
      urlsAll = DeepTracker.pretrained_weights_urls;
      weightfilepats = DeepTracker.pretrained_weights_files_pat_lnx;
      deepnetrootlnx = [aptroot '/deepnet'];
      pretrainedlnx = [deepnetrootlnx '/pretrained'];
      for i = 1:numel(urlsAll)
        url = urlsAll{i};
        pat = weightfilepats{i};
        wfile = sprintf(pat,deepnetrootlnx);

        if exist(wfile,'file')>0
          fprintf('Tensorflow resnet pretrained weights %s already downloaded.\n',url);
          continue;
        end
          
        % hmm what happens when the weightfilenames change?
        fprintf('Downloading tensorflow resnet pretrained weights %s (APT)..\n',url);
        outfiles = untar(url,pretrainedlnx);
        sprintf('Downloaded and extracted the following files/directories:\n');
        fprintf('%s\n',outfiles{:});
      end      
    end
    function codestr = codeGenSSHGeneral(remotecmd,varargin)
      [host,bg,prefix,sshoptions] = myparse(varargin,...
        'host',DeepTracker.jrchost,... % 'logfile','/dev/null',...
        'bg',true,...
        'prefix',DeepTracker.jrcprefix,...
        'sshoptions','-o "StrictHostKeyChecking no"');
      
      if ~isempty(prefix),
        remotecmd = [prefix,'; ',remotecmd];
      end
      if ~ischar(sshoptions) || isempty(sshoptions),
        sshcmd = 'ssh';
      else
        sshcmd = ['ssh ',sshoptions];
      end
            
      if bg
        codestr = sprintf('%s %s ''%s </dev/null &''',sshcmd,host,remotecmd);
      else
        codestr = sprintf('%s %s ''%s''',sshcmd,host,remotecmd);
      end

%       codestr = sprintf('ssh %s ''%s </dev/null >%s 2>&1 &''',...
%         host,remotecmd,logfile);    
    end
    function codestr = codeGenSingGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      DFLTBINDPATH = {
        '/groups/branson/bransonlab'
        '/groups/branson/home'
        '/nrs/branson'
        '/scratch'};      
      [bindpath,singimg] = myparse(varargin,...
        'bindpath',DFLTBINDPATH,...
        'singimg','/misc/local/singularity/branson_cuda10_mayank.simg');
      
      bindpath = cellfun(@(x)['"' x '"'],bindpath,'uni',0);      
      Bflags = [repmat({'-B'},1,numel(bindpath)); bindpath(:)'];
      Bflagsstr = sprintf('%s ',Bflags{:});
      codestr = sprintf('singularity exec --nv %s %s bash -c ". /opt/venv/bin/activate && %s"',...
        Bflagsstr,singimg,basecmd);
    end
    
    function plnx = codeGenPathUpdateWin2LnxContainer(pwin,mntloc)
      PAT1 = '^(?<drivelet>[a-zA-Z]):\\';
      REP1 = sprintf('%s/$<drivelet>/',mntloc);
      PAT2 = '^\\\\(?<server>[^/\\]+)[/\\]';
      REP2 = sprintf('%s/$<server>/',mntloc);
      PAT3 = '\\';
      REP3 = '/';
      plnx = regexprep(pwin,PAT1,REP1);
      plnx = regexprep(plnx,PAT2,REP2);
      plnx = regexprep(plnx,PAT3,REP3);
    end
    
    function codestr = codeGenCondaGeneral(basecmd,varargin)
      % Take a base command and run it in a sing img
      [condaEnv,gpuid] = myparse(varargin,...
        'condaEnv','APT',...
        'gpuid',0);
      if ispc,
        envcmd = sprintf('set CUDA_DEVICE_ORDER=PCI_BUS_ID&& set CUDA_VISIBLE_DEVICES=%d',gpuid);
      else
        envcmd = sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID&& export CUDA_VISIBLE_DEVICES=%d',gpuid);
      end
      codestr = sprintf('activate %s&& %s&& %s',condaEnv,envcmd,basecmd);
    end
    function codestr = codeGenBsubGeneral(basecmd,varargin)
      [nslots,gpuqueue,outfile] = myparse(varargin,...
        'nslots',1,...
        'gpuqueue','gpu_any',...
        'outfile','/dev/null');
      codestr = sprintf('bsub -n %d -gpu "num=1" -q %s -o "%s" -R"affinity[core(1)]" %s',...
        nslots,gpuqueue,outfile,basecmd);      
    end
    function codestr = trainCodeGen(trnID,dllbl,cache,errfile,netType,...
        varargin)
      [view,deepnetroot,trainType,fs,filequote] = myparse(varargin,...
        'view',[],... % (opt) 1-based view index. If supplied, train only that view. If not, all views trained serially
        'deepnetroot',APT.getpathdl,...
        'trainType',DLTrainType.New,...
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths. 
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller 
                        ... % is expected to wrap in enclosing regular double-quotes " !!
          );
      tfview = ~isempty(view);
      
      aptintrf = [deepnetroot fs 'APT_interface.py'];
      
      switch trainType
        case DLTrainType.New
          continueflags = '';
        case DLTrainType.Restart
          continueflags = '-continue -skip_db';
        case DLTrainType.RestartAug
          continueflags = '-continue';
        otherwise
          assert(false);
      end
      
      codestr = sprintf('python %s -name %s',...
        [filequote aptintrf filequote],trnID);
      if tfview
        codestr = sprintf('%s -view %d',codestr,view); % APT_interface accepts 1-based view
      end      
      codestr = sprintf('%s -cache %s -err_file %s -type %s %s train -use_cache %s',...
        codestr,...
        [filequote cache filequote], ... % String.escapeSpaces(cache),...
        [filequote errfile filequote], ... % String.escapeSpaces(errfile),...
        netType,...
        [filequote dllbl filequote], ... % String.escapeSpaces(dllbl),...
        continueflags);
    end
    function [codestr,containerName] = trainCodeGenDocker(backend,...
        modelChainID,trainID,dllbl,cache,errfile,netType,trainType,...
        view1b,mntPaths,gpuid,varargin)
                  
      [dockerargs,isMultiView] = myparse(varargin,'dockerargs',{},'isMultiView',false);
      %baseargs = {'view' view1b};
      baseargs = {'trainType' trainType};
      if ~isMultiView,
        baseargs = [baseargs,{'view' view1b}];
      end

      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.trainCodeGen(modelChainID,dllbl,cache,errfile,...
        netType,baseargs{:},'filequote',filequote);

      if isempty(view1b),      
        containerName = [modelChainID '_' trainID];
      else
        containerName = [modelChainID '_' trainID '_view' num2str(view1b)];
      end
     
      codestr = backend.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,'gpuid',gpuid,dockerargs{:});      
    end
    function [codestr] = trainCodeGenConda(modelChainID,trainID,...
        dllbl,cache,errfile,netType,trainType,view1b,gpuid,varargin)
      
      [condaargs,isMultiView,outfile] = myparse(varargin,'condaargs',{},'isMultiView',false,...
        'outfile','');
      %fprintf(2,'TODO: restart/trainType\n');
      %baseargs = {'view' view1b};
      baseargs = {'trainType' trainType};
      if ~isMultiView,
        baseargs = [baseargs,{'view' view1b}];
      end
      
      basecmd = DeepTracker.trainCodeGen(modelChainID,dllbl,cache,errfile,...
        netType,baseargs{:},'filesep',filesep);
      
      if ~isempty(outfile),
        basecmd = sprintf('%s > %s 2>&1',basecmd,outfile);
      end
      
      codestr = DeepTracker.codeGenCondaGeneral(basecmd,...
        'gpuid',gpuid,condaargs{:});
      
    end
    function [codestr,containerName] = trainCodeGenDockerDMC(dmc,backend,mntPaths,gpuid,varargin)
      [trnCmdType,leftovers] = myparse_nocheck(varargin,'trnCmdType',dmc.trainType);
      [codestr,containerName] = DeepTracker.trainCodeGenDocker(backend,...
        dmc.modelChainID,dmc.trainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,trnCmdType,dmc.view+1,mntPaths,gpuid,leftovers{:});
    end
    function [codestr] = trainCodeGenCondaDMC(dmc,gpuid,varargin)
      [trnCmdType,leftovers] = myparse_nocheck(varargin,'trnCmdType',dmc.trainType);
      [codestr] = DeepTracker.trainCodeGenConda(...
        dmc.modelChainID,dmc.trainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,trnCmdType,dmc.view+1,gpuid,...
        'outfile',dmc.trainLogLnx,leftovers{:});
    end
    function codestr = trainCodeGenSing(trnID,dllbl,cache,errfile,netType,...
        varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.trainCodeGen(trnID,dllbl,cache,errfile,...
        netType,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trainCodeGenBsubSing(trnID,dllbl,cache,errfile,...
        netType,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trainCodeGenSing(trnID,dllbl,cache,errfile,...
        netType,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end    
    function codestr = trainCodeGenSSHBsubSing(trnID,dllbl,cache,errfile,...
        netType,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{});
      remotecmd = DeepTracker.trainCodeGenBsubSing(trnID,dllbl,cache,...
        errfile,netType,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    function codestr = trainCodeGenSSHBsubSingDMC(aptroot,dmc,varargin)
      [singargs,bsubargs,trnCmdType] = myparse(varargin,...
        'singargs',{},...
        'bsubargs',{},...
        'trnCmdType',dmc.trainType...
        );
      
      if isempty(aptroot)
        aptroot = dmc.dirAptRootLnx;
      end
        
      repoSSscriptLnx = [aptroot '/matlab/repo_snapshot.sh'];
      repoSScmd = sprintf('"%s" "%s" > "%s"',repoSSscriptLnx,aptroot,dmc.aptRepoSnapshotLnx);
      prefix = [DeepTracker.jrcprefix '; ' repoSScmd];
      
      codestr = DeepTracker.trainCodeGenSSHBsubSing(...
        dmc.modelChainID,dmc.lblStrippedLnx,...
        dmc.rootDir,dmc.errfileLnx,dmc.netType,...
        'baseArgs',{'view' dmc.view+1 'trainType' trnCmdType 'deepnetroot' [aptroot '/deepnet']},...
        'singargs',singargs,...
        'bsubArgs',[bsubargs {'outfile' dmc.trainLogLnx}],...
        'sshargs',{'prefix' prefix});
    end
        
    function downloadPretrainedExec(aptroot)
      % kb investigate: This doesn't work well on the cluster due to tf 
      % being a restricted site, plus /tmp acts weird
      assert(isunix,'Only supported on *nix platforms.');
      deepnetroot = [aptroot '/deepnet'];
      cmd = sprintf(DeepTracker.pretrained_download_script_py,deepnetroot);
      [~,res] = AWSec2.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end      
    function codestr = updateAPTRepoCmd(varargin)
      [aptparent,downloadpretrained,branch] = myparse(varargin,...
        'aptparent','/home/ubuntu',...
        'downloadpretrained',false,...
        'branch','develop'... % branch to checkout
        );
      
      aptroot = [aptparent '/APT/deepnet'];
      
      codestr = {
        sprintf('cd %s;',aptroot);
        sprintf('git checkout %s;',branch);
        'git pull;'; 
        };
      if downloadpretrained
        % assumes we are on lnx. we cd-ed into deepnet above
        codestr{end+1,1} = sprintf(DeepTracker.pretrained_download_script_py,'.');
      end
      codestr = cat(2,codestr{:});
    end
    function updateAPTRepoExecAWS(aws,varargin) % throws if fails
      updateCmdArgs = myparse(varargin,...
        'updateCmdArgs',{}... % addnl PVs for updateAPTRepoCmd
        );        
      
      cmdremote = DeepTracker.updateAPTRepoCmd('downloadpretrained',true,updateCmdArgs{:});
      [tfsucc,res] = aws.cmdInstance(cmdremote,'dispcmd',true); %#ok<ASGLU>
      if tfsucc
        fprintf('Updated remote APT repo.\n\n');
      else
        error('Failed to update remote APT repo.');
      end
    end
    function updateAPTRepoExecJRC(cacheRoot) % throws if fails
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      updatecmd = DeepTracker.updateAPTRepoCmd('aptparent',cacheRoot);
      updatecmd = DeepTracker.codeGenSSHGeneral(updatecmd,'bg',false);
      [~,res] = AWSec2.syscmd(updatecmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = cpPTWfromJRCProdLnx(aptrootLnx)
      % copy cmd (lnx) deepnet/pretrained from production repo to JRC loc 
      srcPTWlnx = [DeepTracker.jrcprodrepo '/deepnet/pretrained'];
      dstPTWlnx = [aptrootLnx '/deepnet'];      
      cmd = sprintf('cp -r -u "%s" "%s"',srcPTWlnx,dstPTWlnx);
    end
    function cpupdatePTWfromJRCProdExec(aptrootLnx) % throws if errors
      cmd = DeepTracker.cpPTWfromJRCProdLnx(aptrootLnx);
      cmd = DeepTracker.codeGenSSHGeneral(cmd,'bg',false);
      [~,res] = AWSec2.syscmd(cmd,...
        'dispcmd',true,...
        'failbehavior','err');
    end
    function cmd = dirExistsCmd(ddir)
      cmd = sprintf('bash -c "[ -d ''%s'' ] && echo ''y'' || echo ''n''"',ddir);
    end      
    function cloneJRCRepoIfNec(cacheRoot) % throws on fail
      % Clone 'remote' repo into cacheRoot from prod, if necessary
      % 
      % cacheRoot: 'remote' cachedir, ie cachedir on JRC filesys
      
      % does repo in 'remote' cache exist?
      aptroot = [cacheRoot '/APT'];
      aptrootexistscmd = DeepTracker.dirExistsCmd(aptroot);
      aptrootexistscmd = DeepTracker.codeGenSSHGeneral(aptrootexistscmd,...
        'bg',false);
      
      [~,res] = AWSec2.syscmd(aptrootexistscmd,...
        'dispcmd',true,...
        'failbehavior','err');
      res = strtrim(res);
      
      % clone it if nec
      switch res
        case 'y'
          fprintf('Found JRC/APT repo at %s.\n',aptroot);
        case 'n'
          cloneaptcmd = sprintf('git clone %s %s',DeepTracker.jrcprodrepo,aptroot);
          cloneaptcmd = DeepTracker.codeGenSSHGeneral(cloneaptcmd,'bg',false);
          [~,res] = AWSec2.syscmd(cloneaptcmd,...
            'dispcmd',true,...
            'failbehavior','err');
          fprintf('Cloned JRC/APT repo into %s.\n',aptroot);
        otherwise
          error('Failed to update APT repo on JRC filesystem.');
      end
    end
          
    function codestr = trainCodeGenAWS(dmc,varargin)
      incViewFlag = myparse(varargin,...
        'incViewFlag',false... % if true, include -view flag to train a single view. if false, no -view flag specified, all views trained serially
        );
      
      assert(isscalar(dmc));
      
      trnCodeGenArgs = {
        dmc.modelChainID,dmc.lblStrippedLnx,dmc.rootDir, ...
        dmc.errfileLnx,char(dmc.netType),...
        'deepnetroot','/home/ubuntu/APT/deepnet',...
        'trainType',dmc.trainType};
      if incViewFlag
        trnCodeGenArgs = [trnCodeGenArgs {'view' dmc.view+1}];
      end
      
      codestr = {
        'cd /home/ubuntu/APT/deepnet;';
        'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
        DeepTracker.trainCodeGen(trnCodeGenArgs{:});
        };
      codestr = cat(2,codestr{:});
    end
    function str = cellstr2SpaceDelimWithEscapedSpace(c)
      % c: cellstr
      %
      % Use this to convert c to a space-delimited string for use as a
      % command-line argument. It is assumed this argument will be used in 
      % a *nix environment with eg python/argparse; individual elements of 
      % c will have any naked whitespaces escaped so that any such elements 
      % will not be (mis)interpretered as 2+ separate arguments.
      c = cellfun(@String.escapeSpaces,c,'uni',0);
      str = String.cellstr2DelimList(c,' ');
    end
    function str = cellstr2SpaceDelimWithQuote(c,quotechar)
      c = cellfun(@(x)[quotechar x quotechar],c,'uni',0);
      str = String.cellstr2DelimList(c,' '); 
    end
    function codestr = trackCodeGenBaseListFile(trnID,cache,dllbl,outfile,...
        errfile,nettype,view,listfile,varargin)
      % view: 1-based
      
      [deepnetroot,model_file,fs,filequote] = myparse(varargin,...
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... 
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        );

      tfmodel = ~isempty(model_file);      
      aptintrf = [deepnetroot fs 'APT_interface.py'];

      code = { ...
        'python' [filequote aptintrf filequote] ...
        '-name' trnID ...
        '-view' num2str(view) ... % 1b 
        '-cache' [filequote cache filequote] ...
        '-err_file' [filequote errfile filequote] ...
        };
      if tfmodel
        code(end+1:end+2) = {'-model_files' [filequote model_file filequote]};
      end
      code = [code ...
        '-type' char(nettype) ...
        [filequote dllbl filequote] 'track' ...
        '-out' [filequote outfile filequote] ...
        '-list_file' [filequote listfile filequote] ];
      
      codestr = String.cellstr2DelimList(code,' ');
    end
    function codestr = trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,... % either char or [nviewx1] cellstr
        outtrk,... % either char of [nviewx1] cellstr
        frm0,frm1,... % (opt) can be empty. these should prob be in optional P-Vs
        varargin)
      
      [cache,trxtrk,trxids,view,croproi,hmaps,deepnetroot,model_file,log_file,...
        updateWinPaths2LnxContainer,lnxContainerMntLoc,fs,filequote] = ...
        myparse(varargin,...
        'cache',[],... % (opt) cachedir
        'trxtrk','',... % (opt) trxfile for movtrk to be tracked 
        'trxids',[],... % (opt) 1-based index into trx structure in trxtrk. empty=>all trx
        'view',[],... % (opt) 1-based view index. If supplied, track only that view. If not, all views tracked serially 
        'croproi',[],... % (opt) 1-based [xlo xhi ylo yhi] roi (inclusive). can be [nview x 4] for multiview
        'hmaps',false,...% (opt) if true, generate heatmaps
        'deepnetroot',APT.getpathdl,...
        'model_file',[], ... % can be [nview] cellstr
        'log_file',[],... (opt)
        'updateWinPaths2LnxContainer',ispc, ... % if true, all paths will be massaged from win->lnx for use in container 
        'lnxContainerMntLoc','/mnt',... % used when updateWinPaths2LnxContainer==true
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!
        );
     
      tffrm = ~isempty(frm0) && ~isempty(frm1);
      tfcache = ~isempty(cache);
      tftrx = ~isempty(trxtrk);
      tftrxids = ~isempty(trxids);
      tfview = ~isempty(view);
      tfcrop = ~isempty(croproi);
      tfmodel = ~isempty(model_file);
      tflog = ~isempty(log_file);
      
      movtrk = cellstr(movtrk);
      outtrk = cellstr(outtrk);
      if tftrx
        trxtrk = cellstr(trxtrk);
      end
      if tfmodel
        model_file = cellstr(model_file);
      end
      
      if tfview % view specified. track a single movie
        nview = 1;
        assert(isscalar(view));
        if tftrx
          assert(isscalar(trxtrk));
        end
      else
        nview = numel(movtrk);
        if nview>1
          assert(~tftrx && ~tftrxids,'Trx not supported for multiple views.');
        end
      end
      assert(isequal(nview,numel(movtrk),numel(outtrk)));
      if tfmodel
        assert(numel(model_file)==nview);
      end
      if tfcrop
        szassert(croproi,[nview 4]);
      end      
            
      assert(~(tftrx && tfcrop));
      aptintrf = [deepnetroot fs 'APT_interface.py'];
      
      if updateWinPaths2LnxContainer
        fcnPathUpdate = @(x)DeepTracker.codeGenPathUpdateWin2LnxContainer(x,lnxContainerMntLoc);
        aptintrf = fcnPathUpdate(aptintrf);

        movtrk = cellfun(fcnPathUpdate,movtrk,'uni',0);
        outtrk = cellfun(fcnPathUpdate,outtrk,'uni',0);
        if tftrx
          trxtrk = cellfun(fcnPathUpdate,trxtrk,'uni',0);
        end
        if tfmodel
          model_file = cellfun(fcnPathUpdate,model_file,'uni',0);
        end
        if tflog
          log_file = fcnPathUpdate(log_file);
        end
        if tfcache
          cache = fcnPathUpdate(cache);
        end
        errfile = fcnPathUpdate(errfile);
        dllbl = fcnPathUpdate(dllbl);
      end

      codestr = {'python' [filequote aptintrf filequote] '-name' trnID};
      if tfview
        codestr = [codestr {'-view' num2str(view)}]; % view: 1-based for APT_interface
      end
      if tfcache
        codestr = [codestr {'-cache' [filequote cache filequote]}];
      end
      codestr = [codestr {'-err_file' [filequote errfile filequote]}];
      if tfmodel
        codestr = [codestr {'-model_files' ...
                            DeepTracker.cellstr2SpaceDelimWithQuote(model_file,filequote)}];
      end
      if tflog
        codestr = [codestr {'-log_file' [filequote log_file filequote]}];
      end
      codestr = [codestr {'-type' char(nettype) ...
                          [filequote dllbl filequote] ...
                          'track' ...
                          '-mov' DeepTracker.cellstr2SpaceDelimWithQuote(movtrk,filequote) ...
                          '-out' DeepTracker.cellstr2SpaceDelimWithQuote(outtrk,filequote) }];
      if tffrm
        codestr = [codestr {'-start_frame' num2str(frm0) '-end_frame' num2str(frm1)}];
      end
      if tftrx
        codestr = [codestr {'-trx' DeepTracker.cellstr2SpaceDelimWithQuote(trxtrk,filequote)}];
        if tftrxids
          trxids = num2cell(trxids); % 1-based for APT_interface
          trxidstr = sprintf('%d ',trxids{:});
          trxidstr = trxidstr(1:end-1);
          codestr = [codestr {'-trx_ids' trxidstr}];
        end
      end
      if tfcrop
        croproirowvec = croproi';
        croproirowvec = croproirowvec(:)'; % [xlovw1 xhivw1 ylovw1 yhivw1 xlovw2 ...]
        roistr = mat2str(croproirowvec);
        roistr = roistr(2:end-1);
        codestr = [codestr {'-crop_loc' roistr}];
      end
      if hmaps
        codestr = [codestr {'-hmaps'}];
      end
      
      codestr = String.cellstr2DelimList(codestr,' ');
    end
    
    function codestr = dataAugCodeGenSSHBsubSing(ID,dllbl,cache,errfile,netType,outfile,varargin)

      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{});
      remotecmd = DeepTracker.dataAugCodeGenBsubSing(ID,dllbl,cache,...
        errfile,netType,outfile,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    
    function codestr = dataAugCodeGenBsubSing(ID,dllbl,cache,errfile,netType,outfile,varargin)
    
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.dataAugCodeGenSing(ID,dllbl,cache,errfile,...
        netType,outfile,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
      
    end
    
    function codestr = dataAugCodeGenSing(ID,dllbl,cache,errfile,netType,outfile,...
        varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.dataAugCodeGenBase(ID,dllbl,cache,errfile,...
        netType,outfile,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    
    function [codestr] = dataAugCodeGenDocker(backend,...
        ID,dllbl,cache,errfile,netType,outfile,varargin)
      
      [baseargs,dockerargs,mntPaths] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{});
      
      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.dataAugCodeGenBase(ID,dllbl,cache,errfile,...
        netType,outfile,baseargs{:},'filequote',filequote);
      
      codestr = backend.codeGenDockerGeneral(basecmd,ID,...
        'bindpath',mntPaths,dockerargs{:});
    end    
    
    function codestr = dataAugCodeGenBase(ID,dllbl,cache,errfile,...
        nettype,outfile,varargin)
      
      [deepnetroot,model_file,fs,filequote] = myparse(varargin,...
        'deepnetroot',APT.getpathdl,...
        'model_file',[],... % can be [nview] cellstr
        'filesep','/',...
        'filequote','\"'... % quote char used to protect filenames/paths.
                        ... % *IMPORTANT*: Default is escaped double-quote \" => caller
                        ... % is expected to wrap in enclosing regular double-quotes " !!        
        ); 
     
      tfcache = ~isempty(cache);
      tfmodel = ~isempty(model_file);
      
      if tfmodel
        model_file = cellstr(model_file);
      end

      aptintrf = [deepnetroot fs 'APT_interface.py'];      
    
      codestr = sprintf('python %s -name %s',...
        [filequote aptintrf filequote],ID);
      if tfcache
        %cache = String.escapeSpaces(cache);
        codestr = [codestr ' -cache ' [filequote cache filequote]];
      end
      %errfile = String.escapeSpaces(errfile);
      codestr = [codestr ' -err_file ' [filequote errfile filequote]];
      if tfmodel
        %modelfilestr = DeepTracker.cellstr2SpaceDelimWithEscapedSpace(model_file);
        codestr = sprintf('%s -model_files %s',codestr,...
          DeepTracker.cellstr2SpaceDelimWithQuote(model_file,filequote));
      end
      codestr = [codestr sprintf(' -type %s %s data_aug -out_file %s',...
        char(nettype),[filequote dllbl filequote],[filequote outfile filequote])];
    end    
    
    function [codestr,containerName] = trackCodeGenDocker(backend,...
        trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,dockerargs,mntPaths,containerName] = myparse(varargin,...
        'baseargs',{},'dockerargs',{},'mntPaths',{},'containerName','');
      
      baseargs = [{'cache' cache} baseargs];
      filequote = backend.getFileQuoteDockerCodeGen;
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:},'filequote',filequote);

      if isempty(containerName),
        if iscell(outtrk),
          [~,containerName] = fileparts(outtrk{1});
        else
          [~,containerName] = fileparts(outtrk);
        end
      end
      
      codestr = backend.codeGenDockerGeneral(basecmd,containerName,...
        'bindpath',mntPaths,dockerargs{:});
    end
    
    function [codestr] = trackCodeGenConda(...
        trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)
%         movtrk,outtrk,frm0,frm1,...
%         modelChainID,trainID,dllbl,cache,errfile,netType,view1b,mntPaths,...
%         varargin)

      % varargin: see trackCodeGenBase, except for 'cache' and 'view'
      
      [baseargs,condaargs,outfile] = myparse(varargin,...
        'baseargs',{},'condaargs',{},'outfile','');
      
      baseargs = [{'cache' cache} baseargs];
        
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:});
      if ~isempty(outfile),
        basecmd = sprintf('%s > %s 2>&1',basecmd,outfile);
      end
      codestr = DeepTracker.codeGenCondaGeneral(basecmd,...
        condaargs{:});
    end
    
    function codestr = trackCodeGenVenv(trnID,dllbl,movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,venvHost,venv,cudaVisDevice,logFile] = myparse(varargin,...
        'baseargs',{},... % p-v cell for trackCodeGenBase
        'venvHost','10.103.20.155',... % host to run DL verman-ws1
        'venv','/groups/branson/bransonlab/mayank/venv',... 
        'cudaVisDevice',[],... % if supplied, export CUDA_VISIBLE_DEVICES to this
        'logFile','/dev/null'...
      ); 
      
      basecode = DeepTracker.trackCodeGenBase(trnID,dllbl,movtrk,outtrk,...
        frm0,frm1,baseargs{:});
      if ~isempty(cudaVisDevice)
        cudaDeviceStr = ...
          sprintf('export CUDA_DEVICE_ORDER=PCI_BUS_ID; export CUDA_VISIBLE_DEVICES=%d; ',...
          cudaVisDevice);
      else
        cudaDeviceStr = '';
      end
        
      codestrremote = sprintf('cd %s; source bin/activate; %s%s',venv,...
        cudaDeviceStr,basecode);
      codestr = DeepTracker.codeGenSSHGeneral(codestrremote,...
        'host',venvHost,'logfile',logFile);
    end
    function codestr = trackCodeGenSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{});
      basecmd = DeepTracker.trackCodeGenBase(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,baseargs{:});
      codestr = DeepTracker.codeGenSingGeneral(basecmd,singargs{:});
    end
    function codestr = trackCodeGenBsubSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{});
      basecmd = DeepTracker.trackCodeGenSing(trnID,dllbl,errfile,nettype,...
        movtrk,outtrk,frm0,frm1,'baseargs',baseargs,'singargs',singargs);
      codestr = DeepTracker.codeGenBsubGeneral(basecmd,bsubargs{:});
    end
    
    function codestr = trackCodeGenSSHBsubSing(trnID,cache,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,varargin)
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );
      baseargs = [baseargs {'cache' cache}];      
            
      remotecmd = DeepTracker.trackCodeGenBsubSing(trnID,dllbl,errfile,...
        nettype,movtrk,outtrk,frm0,frm1,...
        'baseargs',baseargs,'singargs',singargs,'bsubargs',bsubargs);
      codestr = DeepTracker.codeGenSSHGeneral(remotecmd,sshargs{:});
    end
    
    function codestr = trackCodeGenListFileSSHBsubSing(trnID,cache,dllbl,...
        errfile,nettype,view,outfile,listfile,varargin)
      
      [baseargs,singargs,bsubargs,sshargs] = myparse(varargin,...
        'baseargs',{},...
        'singargs',{},...
        'bsubargs',{},...
        'sshargs',{}...
        );      
      
      codebase = DeepTracker.trackCodeGenBaseListFile(trnID,cache,dllbl,...
        outfile,errfile,nettype,view,listfile,baseargs{:});
      codesing = DeepTracker.codeGenSingGeneral(codebase,singargs{:});
      codebsub = DeepTracker.codeGenBsubGeneral(codesing,bsubargs{:});
      codestr = DeepTracker.codeGenSSHGeneral(codebsub,sshargs{:});      
    end
    function codestr = trackCodeGenAWS(...
        trnID,cacheRemote,dlLblRemote,errfileRemote,netType,movRemoteFull,...
        trkRemoteFull,frm0,frm1,baseargs)
      % movRemoteFull: can be cellstr when tracking all views
      % trkRemoteFull: "
      % 
      % baseargs: PV cell vector that goes to .trackCodeGenBase
      
      deepnetroot = '/home/ubuntu/APT/deepnet';
      baseargs = [baseargs {'cache' cacheRemote}];
      codestrbase = DeepTracker.trackCodeGenBase(trnID,dlLblRemote,...
        errfileRemote,netType,movRemoteFull,trkRemoteFull,frm0,frm1,...
        'deepnetroot',deepnetroot,baseargs{:});
      
      codestr = {
         'cd /home/ubuntu/APT/deepnet;';
         'export LD_LIBRARY_PATH=/home/ubuntu/src/cntk/bindings/python/cntk/libs:/usr/local/cuda/lib64:/usr/local/lib:/usr/lib:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/mpi/lib;';
         codestrbase
        };
      codestr = cat(2,codestr{:});
    end
    
    function [m,tfsuccess,isold] = parseTrkFileName(trkfile)
      
      tfsuccess = false;
      isold = false;
      [p,n,e] = fileparts(trkfile);
      m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>.*)_iter(?<iter>.*)_(?<trk_ts>.*)$','names','once');
      if isempty(m),
        m = regexp(n,'^(?<base>.*)_trn(?<trn_ts>.*)_(?<trk_ts>.*)$','names','once');
        if ~isempty(m),
          fprintf('trkfile %s does not have iteration name in it. parsing trkInfo.model_file to determine...\n',trkfile);
          try
            tmp = load(trkfile,'trkInfo','-mat');
            iter = DeepModelChainOnDisk.getModelFileIter(char(tmp.trkInfo.model_file));
            m.iter = iter(1);
            isold = true;
          catch ME,
            warning('Could not parse iteration from trkInfo.model_file');
            getReport(ME);
            return;
          end
        else
          warning('Could not parse trkfile name %s',trkfile);
          return;
        end
      else
        m.iter = str2double(m.iter);
        isold = false;
      end
      m.path = p;
      m.ext = e;
      m.newName = fullfile(m.path,[m.base '_trn' m.trn_ts '_iter' num2str(m.iter) '_' m.trk_ts m.ext]);
      tfsuccess = true;
    end
    
    function [tfsucc,res] = waitForBsubComplete(jobid,cmd,nout,maxWaitTime,doKill)
      starttime = tic;
      res = cell(1,nout);
      bjobscmd = sprintf('bjobs %d',jobid);
      bjobscmd = DeepTracker.codeGenSSHGeneral(bjobscmd,'bg',false);
      killcmd = sprintf('bkill %d',jobid);
      killcmd = DeepTracker.codeGenSSHGeneral(killcmd,'bg',false);
      runStatuses = {'PEND','RUN','PROV','WAIT'};
      doneStatuses = {'DONE'};
      tfJobRunning = false;
      tfJobDone = false;
      
      while true,
        if toc(starttime) > maxWaitTime,
          break;
        end
        [tfsucc,res{:}] = cmd();
        %[augims,tfsucc] = DeepTracker.loadAugmentedData(outfile,obj.lObj.nview);
        if tfsucc,
          break;
        end
        tfJobRunning = false;
        [st2,res2] = system(bjobscmd);
        if st2 == 0,
          ss = strsplit(res2,'\n');
          ism = ~cellfun(@isempty,regexp(ss,'^JOBID','once'));
          i = find(ism,1);
          if ~isempty(i) && i < numel(ss),
            
            % make sure outout is formatted as I think it should be
            assert(~isempty(regexp(ss{i},'^\s*JOBID\s*USER\s*STAT','once')))
            res3 = ss{i+1};
            m = regexp(res3,'^(?<jobid>\d+)\s+(?<user>\w+)\s+(?<stat>\w+)','names','once');
            assert(~isempty(m));
            tfJobRunning = ismember(m.stat,runStatuses);
            tfJobDone = ismember(m.stat,doneStatuses);
            %fprintf('%fs: %s\n',toc(starttime),m.stat);
            
          end
        end
        if ~tfJobRunning && ~tfJobDone,
          warning('Could not find results. Output of bjobs:\n%s\n',res2);
          break;
        end
        drawnow;
      end
      if ~tfsucc && tfJobRunning && doKill,
        [st4,res4] = system(killcmd);
        if ~st4 == 0,
          error('Error killing:\n%s',res4);
        end
      end
      
    end


  end
  methods (Static) % train/track broker util
    function hdir = dlerrGetHomeDir
      m = getenvall;
      hdir = m('HOME');
    end
%     function errfile = dlGetTrackErrFile(trnID,hdir)
%       if exist('hdir','var')==0
%         hdir = DeepTracker.dlerrGetHomeDir;
%       end
%       nowstr = datestr(now,'yyyymmddTHHMMSS');
%       errfileS = [trnID '_' nowstr '.err'];
%       errfile = fullfile(hdir,errfileS);
%     end
  end
  
  %% TrackRes = Tracking DB. all known tracking results on disk.  
  methods
    function trackResInit(obj)
      m = containers.Map('keytype','int32','valuetype','any');
      obj.movIdx2trkfile = m;
    end
    function trackResAddTrkfile(obj,mIdx,trkfiles)
      % Remember/add a set of [nview] trkfiles associated with mIdx
      
      assert(isscalar(mIdx));
      assert(iscellstr(trkfiles));
            
      [v,id] = obj.trackResGetTrkfiles(mIdx);      
      v(end+1,:) = trkfiles(:)';
      obj.movIdx2trkfile(id) = v;
    end
    function [trkfiles,id] = trackResGetTrkfiles(obj,mIdx)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        trkfiles = m(id);
      else
        trkfiles = cell(0,obj.lObj.nview);
      end      
    end
    function trackResSetTrkfiles(obj,mIdx,trkfiles)
      % trkfiles: [ntrkfilesxnview] fullpath trkfiles for given scalar
      % MovieIndex
      m = obj.movIdx2trkfile;
      id = mIdx.id32();
      if m.isKey(id)
        obj.movIdx2trkfile(id) = trkfiles;
      else
        obj.trackResAddTrkfile(mIdx,trkfiles)
      end      
    end
    function removeMissingTrkFiles(obj,mIdx)
      [trkfiles,id] = obj.trackResGetTrkfiles(mIdx);
      tfexists = cellfun(@(x) exist(x,'file'),trkfiles)>0;
      if ~all(tfexists),
        obj.movIdx2trkfile(id) = trkfiles(tfexists);
      end
    end
    function [tpos,taux,tauxlbl] = getTrackingResultsCurrMovie(obj)
      tpos = obj.trkP;
      taux = obj.trkAux;
      tauxlbl = obj.trkAuxLbl;
    end
    function [trkfileObjs,tfHasRes] = getTrackingResults(obj,mIdx)
      % Get tracking results for MovieIndices mIdx
      %
      % mIdx: [nMov] vector of MovieIndices
      %
      % trkfiles: [nMovxnView] cell of TrkFile objects, or [] if tfHasRes(...) is false
      % tfHasRes: [nMov] logical. If true, corresponding movie(set) has 
      %   tracking nontrivial (nonempty) tracking results
      %
      % DeepTracker uses the filesys as the tracking result DB. This loads 
      % from known/expected trkfiles.
            
      assert(isa(mIdx,'MovieIndex'));
      nMov = numel(mIdx);
      nView = obj.nview;
      trkfileObjs = cell(nMov,nView);
      tfHasRes = false(nMov,1);
      for i=1:nMov
        trkfilesI = obj.trackResGetTrkfiles(mIdx(i));
        ntrk = size(trkfilesI,1);
        
        if ntrk==0
          % trkfileObjs, tfHasRes, trkfiles initted appropriately
          continue;
        end          
        if ntrk>1
          warningNoTrace('Merging tracking results from %d poseTF trkfiles.\n',ntrk);
        end        
        for ivw=1:nView
          [trkfilesIobj,tfsuccload] = cellfun(@DeepTracker.hlpLoadTrk,...
            trkfilesI(:,ivw),'uni',0);
          tfsuccload = cell2mat(tfsuccload);
          trkfilesIobj = trkfilesIobj(tfsuccload);
          if isempty(trkfilesIobj)
            % if all loads failed
            % none; trkfiles, tfHasRes OK
          else
            tObj = trkfilesIobj{1};
            for iTmp=2:numel(trkfilesIobj)
              tObj.mergePartial(trkfilesIobj{iTmp});
            end
            trkfileObjs{i,ivw} = tObj;
            tfHasRes(i) = true;
          end
        end
      end
    end
    function isCurr = checkTrackingResultsCurrent(obj)
      
      isCurr = true;
      obj.updateLastDMCsCurrInfo();
      
      for moviei = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(moviei);
        % some trkfiles don't exist for some reason
        obj.removeMissingTrkFiles(mIdx);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if isempty(trkfiles),
          continue;
        end
        
        isFixed = false;
        newtrkfiles = trkfiles;
        for i = 1:size(trkfiles,1),
          for ivw = 1:size(trkfiles,2),
            [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfiles{i,ivw},ivw);
            assert(tfSuccess);
            if isOldFileName,
              isFixed = true;
              [tfSucc,msg] = copyfile(trkfiles{i,ivw},trkInfo.newName);
              if ~tfSucc,
                warning('Could not rename %s to %s: %s',trkfiles{i,ivw},newtrkfiles{i,ivw},msg);
              else
                newtrkfiles{i,ivw} = trkInfo.newName;
              end
            end
            if ~isCurr,
              %fprintf('Trkfile %s out of date, removing all tracking for movie %d\n',trkfiles{i},moviei);
              break;
            end
          end
        end
        if isFixed,
          obj.trackResSetTrkfiles(mIdx,newtrkfiles);
        end
        if ~isCurr,
          break;
        end

      end
      
    end
    
    function tblMFT = getTrackedMFT(obj,mIdxs)
      
      tblMFT = [];
      if nargin < 2,
        mIdxs = MovieIndex(1:obj.lObj.nmovies);
      end
      
      for mIdx = mIdxs(:)',
        [tblTrkRes] = obj.getAllTrackResTable(mIdx);
        if isempty(tblTrkRes),
          continue;
        end
        frm = tblTrkRes.frm;
        iTgt = tblTrkRes.iTgt;
        mov = repmat(mIdx,size(frm));
        tblMFT = [tblMFT;table(mov,frm,iTgt)]; %#ok<AGROW>

      end
      
    end
    
    function cleanOutOfDateTrackingResults(obj,isCurr)

      if nargin < 2,
        isCurr = obj.checkTrackingResultsCurrent();
      end
      if isCurr,
        return;
      end
      obj.trackResInit();
      obj.trackCurrResInit();
      % deleting old tracking results, so can switch to new tracker info
      obj.updateTrackerInfo();

%       for i = 1:numel(trkFilesToDelete),
%         delete(trkFilesToDelete{i});
%         if exist(trkFilesToDelete{i},'file'),
%           warning('Failed to delete trk file %s',trkFilesToDelete{i});
%         end
%       end
      
      
    end
    
    function [isCurr,tfSuccess,isOldFileName,trkInfo] = checkTrkFileCurrent(obj,trkfile,ivw)
      isCurr = true;
      [trkInfo,tfSuccess,isOldFileName] = DeepTracker.parseTrkFileName(trkfile);
      if ~tfSuccess,
        return;
      end
      isCurr = strcmp(obj.trnLastDMC(ivw).modelChainID,trkInfo.trn_ts) && ...
        (obj.trnLastDMC(ivw).iterCurr==trkInfo.iter);
    end
    
    function tf = isTrkFiles(obj)
    
      tf = false;
      for i = 1:obj.lObj.nmovies,
        mIdx = MovieIndex(i);
        [trkfiles] = obj.trackResGetTrkfiles(mIdx);
        if ~isempty(trkfiles),
          tf = true;
          return;
        end
      end
      
    end
    
  end
  methods (Static)
    function [trkfileObj,tfsuccload] = hlpLoadTrk(tfile,varargin)
      [rawload] = myparse(varargin,...
        'rawload',false...
        );
            
      try
        if rawload
          trkfileObj = load(tfile,'-mat');
        else
          trkfileObj = TrkFile.loadsilent(tfile);
        end
        tfsuccload = true;
      catch ME
        warningNoTrace('Failed to load trkfile: ''%s''. Error: %s',...
          tfile,ME.message);
        trkfileObj = [];
        tfsuccload  = false;
      end
    end
    
    
    function [tfsucc,augims] = loadAugmentedData(outfile,nview)

      tfsucc = false;
      augims = struct;
      for i = 1:nview,
        outfile_curr = sprintf('%s_%d.mat',outfile,i-1);
        if ~exist(outfile_curr,'file'),
          return;
        end
        da = load(outfile_curr);
        augims.ims{i} = permute(da.ims,[2,3,4,1]);
        augims.locs{i} = da.locs;
      end
      tfsucc = true;
    end
    
  end
  methods
    function [tblTrkRes,pTrkiPt] = getAllTrackResTable(obj,mIdxs) % obj const
      % Get all current tracking results in a table
      %
      % tblTrkRes: [NTrk x ncol] table of tracking results
      %            .pTrk, like obj.trkP; ABSOLUTE coords
      % pTrkiPt: [npttrk] indices into 1:obj.npts, tracked points. 
      %          size(tblTrkRes.pTrk,2)==npttrk*d

      m = obj.movIdx2trkfile;
      
      if m.isempty
        tblTrkRes = [];
        pTrkiPt = [];
        return;
      end
      
      if nargin < 2,
        mIdxs = m.keys;
        mIdxs = cell2mat(mIdxs(:));
      end
      if ~isa(mIdxs,'MovieIndex'),
        mIdxs = MovieIndex(mIdxs);
      end
      [trk,tfhasres] = obj.getTrackingResults(mIdxs);

      tblTrkRes = [];
      pTrkiPt = -1;
      for i=1:numel(mIdxs)
        if tfhasres(i)
          if isequal(pTrkiPt,-1)
            pTrkiPt = trk{i,1}.pTrkiPt;
          end
          if ~isequal(pTrkiPt,trk{i,1}.pTrkiPt)
            error('Trkfiles differ in tracked points .pTrkiPt.');
          end
          tbl = trk{i,1}.tableform;
          tblmov = table(repmat(mIdxs(i),height(tbl),1),'VariableNames',{'mov'});
          tbl = [tblmov tbl];
          tblTrkRes = [tblTrkRes;tbl]; %#ok<AGROW>
        end         
      end
    end
    function clearTrackingResults(obj)
      % FUTURE TODO: For now we do not actually delete the previous trkfiles.
      obj.trackResInit();
      obj.trackCurrResUpdate();
      obj.newLabelerFrame();
    end
  end
  
  %% TrackCurrRes = tracked state for current movie. Loaded into .trkP*
  methods
    function trackCurrResInit(obj)
      % Assumes that .trnNetType is set
      obj.trkP = [];
      obj.trkPTS = zeros(0,1);
      obj.trkAux = [];
      obj.trkAuxLbl = {obj.trnNetType.trkAuxFlds.label}';
    end
    function trackCurrResUpdate(obj)
      % update trackCurrRes (.trkP*) from trackRes (tracking DB)
      mIdx = obj.lObj.currMovIdx;
      if isempty(mIdx)
        % proj load etc
        return;
      end
      [trks,tfHasRes] = obj.getTrackingResults(mIdx);
      if tfHasRes
        obj.trackCurrResLoadFromTrks(trks);
        
%         tfTrx = obj.lObj.hasTrx;
%         
%         trkfilesCurr = obj.trackResGetTrkfiles(mIdx); % [ntrk x nview]
%         ntrkCurr = size(trkfilesCurr,1);
%         for ivw=1:1 % TODO: multiview
%           for itrk=1:ntrkCurr
%             trkfile = trkfilesCurr{itrk,ivw};
%             [trkfileP,trkfileF] = fileparts(trkfile);
%             hmapDirS = [trkfileF '_hmap'];
%             hmapDir = fullfile(trkfileP,hmapDirS);
%             if exist(hmapDir,'dir')>0
%               if tfTrx
%                 % Ideally the heatmaps size is related to 
%                 % sPrm....TargetCrop.Radius, but they might not have set
%                 % that, etc etc
%                 hmnr = [];
%                 hmnc = [];
%               else
%                 hmnr = obj.lObj.movienr;
%                 hmnc = obj.lObj.movienc;
%               end
%               obj.trkVizer.heatMapInit(hmapDir,hmnr,hmnc);
%               if ntrkCurr==1
%                 fprintf('Found heatmap dir: %s\n',hmapDirS);
%               else                
%                 fprintf('Found heatmap dir %s for trkfile %d/%d. Other heatmap dirs (if any) will be ignored.\n',...
%                   hmapDirS,itrk,ntrkCurr);
%               end
%               break;
%             end
%           end
%         end
      else
        obj.trackCurrResInit();
      end
      notify(obj,'newTrackingResults');
    end
    function trackCurrResLoadFromTrks(obj,trks)
      % trks: [nview] cell of TrkFile objs
      
      assert(numel(trks)==obj.nview);
      
      lObj = obj.lObj;
      ipt2view = lObj.labeledposIPt2View;
      
      npt = obj.nPts;
      nfrm = lObj.nframes;
      ntgt = lObj.nTargets;
      auxInfo = obj.trnNetType.trkAuxFlds;
      naux = numel(auxInfo);
      
      pTrk = nan(npt,2,nfrm,ntgt);
      pTrkTS = nan(npt,nfrm,ntgt); 
      aux = nan(npt,nfrm,ntgt,naux);
      
      for iview=1:obj.nview
        t = trks{iview};
        frms = t.pTrkFrm;
        itgts = t.pTrkiTgt;
        ipts = ipt2view==iview;
        pTrk(ipts,:,frms,itgts) = t.pTrk;
        pTrkTS(ipts,frms,itgts) = t.pTrkTS;
        
        for iaux=1:naux
          trkfld = auxInfo(iaux).trkfld;
          if isprop(t,trkfld)
            aux(ipts,frms,itgts,iaux) = t.(trkfld);
          else
            % aux els remain nan
            % Don't warn as not all auxflds must be there. eg pTrkocc is
            % only present if params request it etc.
            % warningNoTrace('Missing field ''%s'' in trkfile.',trkfld);
          end
        end
      end
      
      % For now we rely on this in eg getPredictionCurrentFrame
      assert(strcmp(obj.trkAuxLbl{end},'scr_occ')); 
      
      obj.trkP = pTrk;
      obj.trkPTS = pTrkTS;
      obj.trkAux = aux;
      %obj.trkAuxLbl = {auxInfo.label}';
    end
    function [xy,tfocc] = getPredictionCurrentFrame(obj)
      % xy: [nPtsx2xnTgt], tracking results for all targets in current frm
      % tfocc: [nPtsxnTgt] logical
      
      frm = obj.lObj.currFrame;
      xyPCM = obj.trkP;
      
      if isempty(xyPCM)
        npts = obj.nPts;
        nTgt = obj.lObj.nTargets;
        xy = nan(npts,2,nTgt);
        tfocc = false(npts,nTgt);
      else
        % AL20160502: When changing movies, order of updates to 
        % lObj.currMovie and lObj.currFrame is unspecified. currMovie can
        % be updated first, resulting in an OOB currFrame; protect against
        % this.
        frm = min(frm,size(xyPCM,3));
        xy = squeeze(xyPCM(:,:,frm,:)); % [npt x d x ntgt]
        
        if nargout>1          
          scrocc = squeeze(obj.trkAux(:,frm,:,end)); % currently expect last auxfld is occlusion stat
          tfocc = scrocc > DeepTracker.MDN_OCCLUDED_THRESH;
        end
      end
    end
  end
    
  %% Viz
  methods
    function vizInit(obj)
      obj.trkVizer.vizInit();
      obj.setHideViz(obj.hideViz);
    end
    function setHideViz(obj,tf)
      obj.trkVizer.setHideViz(tf);
      obj.hideViz = tf;
    end
    function updateLandmarkColors(obj)
      ptsClrs = obj.lObj.predPointsPlotInfo.Colors;
      ptsClrs = obj.lObj.Set2PointColors(ptsClrs);
      obj.trkVizer.updateLandmarkColors(ptsClrs);      
    end
    % For updating other cosmetics, go ahead and call obj.trkVizer methods
    % directly
  end

  %% Labeler nav
  methods
    function newLabelerFrame(obj)
      lObj = obj.lObj;
      if lObj.isinit || ~lObj.hasMovie
        return;
      end
            
      [xy,tfocc] = obj.getPredictionCurrentFrame();    
      frm = lObj.currFrame;
      itgt = lObj.currTarget;
      trx = lObj.currTrx;
      if isempty(trx)
        trxXY = [];
        trxTh = [];        
      else
        itrx = frm+trx.off;
        if itrx <= 0 || itrx > numel(trx.x),
          return;
        end
        trxXY = [trx.x(itrx) trx.y(itrx)];
        trxTh = trx.theta(itrx);        
      end        
      obj.trkVizer.updateTrackRes(xy(:,:,itgt),tfocc(:,itgt),frm,itgt,trxXY,trxTh);
    end
    function newLabelerTarget(obj)
      obj.newLabelerFrame();
    end
    function newLabelerMovie(obj)
      obj.vizInit(); % not sure why this is nec
      if obj.lObj.hasMovie
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end
    end
  end
  
  %% Labeler listeners
  methods
    function labelerMovieRemoved(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      tfLabeledRowRemoved = ~isempty(edata.mIdxRmedHadLbls);
      if tfLabeledRowRemoved
        warningNoTrace('Labeled row(s) removed from project. Clearing trained tracker and tracking results.');
        obj.initHook();
      else
        % relabel movie indices
        obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
        
        % this might not be nec b/c the preds for current movie might not
        % ever change
        obj.trackCurrResUpdate();
        obj.newLabelerFrame();
      end      
    end
    function labelerMoviesReordered(obj,edata)
      mIdxOrig2New = edata.mIdxOrig2New;
      obj.movIdx2trkfile = mapKeyRemap(obj.movIdx2trkfile,mIdxOrig2New);
      
      % Assume trackCurrRes does not need update
    end
  end  
  
end